\section{Background}
In our approach, we use Pex~\cite{Pex}as a DSE based tool. Pex starts the program exploration with some random inputs. Pex then collects constraints on program inputs from the predicates at the branching statements executed in the program. We refer these constraints at branching statements as branch conditions. 
The conjunction of all branch conditions in the path followed during execution with an input is referred to as a path constraint. Pex keeps track of the previous executions to build a dynamic execution tree. Pex, in the next run, chooses one of the unexplored branch in the execution tree (dynamically discovered thus far). Pex flips the chosen branching node in the dynamic execution tree (discovered thus far) to generate a new input that follows a new execution path. Pex uses various heuristics for choosing a branching node (to flip next) in the execution tree of the program using various search search strategies with an objective of achieving high statement coverage fast. Pex combines all search strategies it uses into a meta-strategy that gives a fair choice to all the strategies.
 
