\section{Related Work} 
\label{sec:related}

PR-Miner developed by Li and Zhou~\cite{Zhenmin2005PRMiner} uses frequent itemset mining to mine programming rules from C code and detect their violations. DynaMine developed by Livshits and Zimmermann~\cite{livshits05dynamine} uses
association rule mining to extract simple rules from software revision histories for Java code and detect defects related to rule violations. PR-Miner or DynaMine may suffer from issues of a high number of false positives since their rule elements are not necessarily associated with program dependencies. Furthermore, these approaches target at \emph{only} frequent patterns, whereas Alattin can mine alternative patterns that include both frequent and infrequent alternatives.

Another related approach to our Alattin approach is the approach developed by Chang et al.~\cite{chang07:finding} that applies frequent subgraph mining on C code to mine condition rules and to detect neglected conditions. Both Alattin and their approach target at the same type of defects: neglected conditions. Alattin significantly differs from Chang et al.'s approach in three main aspects. First, their approach cannot mine infrequent alternatives.
Second, their approach is limited on a much smaller scale of code repositories (in fact, only one project code base) than Alattin, which exploits a CSE to search for relevant code examples from open source code available on the web. Third, the
scalability of their approach is heavily limited by its underlying graph mining algorithms, which are known to suffer from scalability issues. In contrast, Alattin uses our new ImMiner algorithm based on frequent itemset mining, being much more scalable.

Williams and Hollingsworth~\cite{Chadd2005rule} incorporate an API call return value checker for C code, which checks that a value returned by an API call is checked before being used. This type of return-value checking before use falls into a subset of the types of rules being mined by Alattin. Different from their tool, Alattin does not require or rely on version histories, which may not include the types of defect fixing (required by their tool) related to the rules being mined. Acharya et al.~\cite{acharya06:mining} developed a tool to mine interface details (such as an API call's return values on success or failure and error flags) from model-checker traces for C code, and then mine interface robustness properties for defect detection. Similar to the tool of Williams and Hollingsworth~\cite{Chadd2005rule}, Acharya et al.'s tool mines only a subset of neglected conditions (e.g., return-value checking before use) mined by Alattin. In addition, as shown by Acharya et al.~\cite{acharya06:mining}, only the interface details of 22 out of 60 POSIX API functions can be successfully mined by their tool, whereas Alattin exploits a CSE to alleviate the issue by collecting relevant API call usages from the web. Furthermore, these approaches cannot mine alternative patterns targeted by Alattin.

Engler et al.~\cite{Engler2001deviant} proposed a general approach for detecting defects in C code by applying statistical analysis to rank deviations from programmer beliefs inferred from source code. Their approach allows users to define rule templates, which are not required by our approach. In addition, their approach also cannot mine infrequent alternatives targeted by our Alattin approach.

Finally, our previous approaches PARSEWeb~\cite{thummalapenta07:parseweb} and CAR-Miner~\cite{thummalapenta09:mining} also exploit code search engines for gathering relevant code samples. PARSEWeb accepts queries of the form ``\emph{Source} $\rightarrow$ \emph{Destination}'' and mines frequent method-invocation sequences that accept \emph{Source} and produce \emph{Destination}. Although Alattin uses code search engines for gathering relevant code examples, Alattin targets at mining patterns that describe programming rules that should be obeyed while reusing APIs. Unlike PARSEWeb, which mines frequent sequences, Alattin mines alternative patterns with both frequent and infrequent alternatives. CAR-Miner also incorporates a new mining algorithm for mining exception-handling rules in the form of sequence association rules. CAR-Miner and Alattin differ significantly in three major aspects. (1) CAR-Miner mines rules for detecting exception-handling-related defects, whereas Alattin mines rules for detecting neglected conditions. (2) Alattin is a more general approach compared to CAR-Miner and can be applied to enhance various existing mining-based approaches including CAR-Miner for detecting alternative rules. (3) CAR-Miner mines new kinds of patterns for reducing false negatives (i.e., detecting new kinds of exception-handling defects). In contrast, Alattin mines new kinds of  patterns for reducing false positives. 

\Comment{Alattin is also related to various approaches for mining temporal API properties, such as those approaches developed by Ammons et al.~\cite{ammons02mining}, Yang et al.~\cite{yang2006pmt}, Ramanathan et al.~\cite{ramanathan07:path}, Shoham et
al.~\cite{shoham07:static}, Acharya et al.~\cite{acharya07:mining}, and Wasylkowski et al.~\cite{wasylkowski07:detecting}. These approaches mine pairing or ordering information among API calls, whereas Alattin mines condition rules used to detect neglected conditions around API calls. When neglected conditions around API calls include another API call such as the one detected by both Wasylkowski et al.~\cite{wasylkowski07:detecting} and Alattin, some of these existing approaches can also be used to mine such rules. But Alattin can mine broader types of neglected conditions even when
there is no API call involved in the conditions in addition to mining from a much broader scope of open source code.}
