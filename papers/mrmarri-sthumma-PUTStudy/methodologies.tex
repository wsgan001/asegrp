\section{Testing Methodology}
\label{sec:methods}
Our methodology of writing PUTs in our study can be classified into two major phases: (1) test generalization and (2) writing additional PUTs to achieve high coverage. The first phase involves transforming existing
conventional unit tests into PUTs, where PUTs 
attempt to verify the same or more generalized behavior as the ones tested by conventional unit tests. The second phase involves discovering the code portions that were not covered by the PUTs in Phase 1 and write new PUTs to achieve high coverage. We next explain the systematic procedure used in Phases 1 and 2.

\textbf{Phase 1. Test Generalization.}
In Phase 1, for each conventional unit test, we identify possible variables that can be considered as parameters and replace constant values or variables with
parameters. We next identify a test pattern to which
the conventional unit test belongs. Identification of a test pattern for the PUT in advance helps
to assist in writing PUTs effectively. We also define new patterns,
if the conventional unit test does not fall into any of the existing test patterns. We next 
add necessary assumptions to make sure that the PUT tests the same or generalized expected
behavior of the conventional unit test. We consequently add assertions to validate the actual behaviour of the code under test against the expected behavior. In our test generalization phase, we use factory methods supported by Pex to assist Pex in generating test inputs. When there are any non-primitive parameters, Pex may not be able to generate method-call sequences to construct desirable
object states for those non-primitive parameters. These desirable object states are 
the states that help explore paths in the method under test by covering \CodeIn{true}
or \CodeIn{false} branches in the methods. We assist Pex by providing
factory methods to achieve desirable object states for non-primitive parameters. 

\textbf{Phase 2. Writing New PUTs.} In Phase 2, our objective is to modify existing PUTs or write new PUTs to achieve higher code coverage of the classes under test. In particular, we observe the detailed
coverage reports generated by Pex to identify un-covered code portions. We identify
techniques to extend existing PUTs to cover those un-covered portions.
In our study, we used two techniques to write additional PUTs: mock objects and input-space partitioning. We explain these supporting techniques in detail in Section~\ref{sec:helper}. 