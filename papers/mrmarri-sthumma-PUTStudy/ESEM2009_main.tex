% THIS IS SIGPROC-SP.TEX - VERSION 3.0
% WORKS WITH V3.1SP OF ACM_PROC_ARTICLE-SP.CLS
% JUNE 2007
%
% It is an example file showing how to use the 'acm_proc_article-sp.cls' V3.1SP
% LaTeX2e document class file for Conference Proceedings submissions.
% ----------------------------------------------------------------------------------------------------------------
% This .tex file (and associated .cls V3.1SP) *DOES NOT* produce:
%       1) The Permission Statement
%       2) The Conference (location) Info information
%       3) The Copyright Line with ACM data
%       4) Page numbering
% ---------------------------------------------------------------------------------------------------------------
% It is an example which *does* use the .bib file (from which the .bbl file
% is produced).
% REMEMBER HOWEVER: After having produced the .bbl file,
% and prior to final submission,
% you need to 'insert'  your .bbl file into your source .tex file so as to provide
% ONE 'self-contained' source file.
%
% Questions regarding SIGS should be sent to
% Adrienne Griscti ---> griscti@acm.org
%
% Questions/suggestions regarding the guidelines, .tex and .cls files, etc. to
% Gerald Murray ---> murray@acm.org
%
% For tracking purposes - this is V3.0SP - JUNE 2007

\documentclass{sig-alternate}
%\usepackage{latex8}
\include{macros}
\begin{document}

\title{Retrofitting Legacy Unit Tests for Parameterized Unit Testing}

%\numberofauthors{5} 
\author{Madhuri R. Marri$^1$, Suresh Thummalapenta$^1$, Tao Xie$^1$, Nikolai Tillmann$^2$, Jonathan de Halleux$^2$\\
\small{$^1$Department of Computer Science, North Carolina State University, Raleigh, NC}\\
\small{$^2$Microsoft Research, One Microsoft Way, Redmond, WA}\\
\small{$^1$\{mrmarri, sthumma, txie\}@ncsu.edu, $^2$\{nikolait, jhalleux\}@microsoft.com}\\}
\maketitle

\begin{abstract}
Owing to the significance of unit testing in the software development life cycle, unit testing has been widely adopted by software industry to ensure high-quality software. Recent advances in software testing introduced Parameterized Unit Tests (PUTs), which are a generalized form of Conventional Unit Tests (CUT). With PUTs, test data can be generated automatically using the Dynamic-Symbolic-Execution (DSE) approach. PUTs are powerful and provide an effective means of guided test generation when used with a DSE-based tool such as Pex from Microsoft Research. To leverage the benefits of PUTs in testing existing legacy applications in software industry, we propose the first systematic procedure of test generalization (transforming existing CUTs to PUTs). We also conduct an empirical study, on three real-world applications, that shows benefits of test generalization. We show that test generalization reduces $407$ CUTs to $224$ PUTs (45\%), thereby reducing the effort of maintaining test code. Along with achieving higher code coverage (a maximum increase of 53\% for one class under test and 10\% for one application used in our study), test generalization helped detect $16$ new defects that are not detected by existing CUTs. A few of these defects are quite complex and are hard to be detected using CUTs. Given these benefits of test generalization, we expect that developers in software industry can use our systematic procedure to transform their CUTs to PUTs to exploit the benefits of PUTs, and thereby increase the quality of their developed software.

%Although PUTs relieve developers from providing test data, PUTs still require test scenarios to exercise the code under test. On the other hand, most of the existing applications in software industry have CUTs that include valuable information of test scenarios. These CUTs can be transformed to PUTs (referred to as test generalization) to leverage the benefits of PUTs. In this paper, we propose the first systematic procedure that assists developers in performing test generalization. We also conduct an empirical study that shows benefits of the test generalization. We show that test generalization reduces $407$ CUTs to $224$ PUTs (45\%), thereby reducing the efforts of maintaining test code. Along with achieving higher code coverage (a maximum increase of 53\% for one class under test and 10\% for one application under analysis), test generalization detected $16$ new defects that are not detected by existing CUTs. A few of these defects are quite complex and are hard to be detected using CUTs. Given these benefits of test generalization, we expect that developers in the software industry can use our systematic procedure and transform their CUTs to PUTs to leverage the benefits of PUTs, and thereby increase the quality of their developed software.
\end{abstract}
%\vspace*{-4ex}
%----------------------------------------------------------------------------------------------
\input{introduction}
%----------------------------------------------------------------------------------------------
\input{background}
%----------------------------------------------------------------------------------------------
\input{procedure}
%----------------------------------------------------------------------------------------------
\input{helper}
%----------------------------------------------------------------------------------------------
\input{DoE}
%----------------------------------------------------------------------------------------------
\input{limitations}
%----------------------------------------------------------------------------------------------
\input{related}\vspace*{-1ex}
%----------------------------------------------------------------------------------------------
\input{tov}\vspace*{-1ex}
%----------------------------------------------------------------------------------------------
\input{conclusion}\vspace*{-1.5ex}
%----------------------------------------------------------------------------------------------
\bibliographystyle{abbrv}
\bibliography{references}
\end{document}
