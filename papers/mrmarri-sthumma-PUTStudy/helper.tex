\section{Supporting Techniques Used in Writing PUTs}
\label{sec:helper}

We next detail on the supporting techniques used in writing PUTs. In writing PUTs, we use the factory method and mock object supporting techniques. We used an additional technique of input-space partitioning to achieve higher code coverage in our Phase 2. We next describe these techniques used in our study.
%-------------------------------------------------------------------------
\subsection{Factory Methods} 
\label{sec:factory}

A commonly used technique in test generalization to assist effective test generation is writing factory methods. In our study of writing PUTs and executing them with Pex, we observed that one of the primary reasons for not achieving high block coverage is due to lack of method-call sequences for achieving desirable object states. Although Pex includes a heuristic demand-driven strategy for generating method-call sequences, we found that Pex's strategy can generate method-call sequences effectively in certain limited scenarios where the constructors either accept primitive arguments or explicitly state the actual type of the argument. To address this issue, we use the factory-method feature provided by Pex. These factory methods allow developers to write method-call sequences that can help Pex in achieving desirable object states. Figure~\ref{fig:factorymethd} shows an example factory method that we used in our study. Our factory method accepts two arrays of setting names and values, and adds those entries to the storage. This factory method helps generate different object states for \CodeIn{MemorySettingStorage}. For example, using our factory method, Pex can generate an object of \CodeIn{MemorySettingStorage} with five elements in the storage. 

In our test generalization, we constructed five factory methods for assisting Pex in generating desirable object states.  We observed that these factory methods are quite helpful in achieving high block coverage. 
%-------------------------------------------------------------------------
\subsection{Mock Objects} 
\label{sec:mock}

Mock objects help test features in isolation by replacing functionalities with mock objects. In Phase 2, we added 21 new PUTs and found two methods where we needed to use mock objects. Two existing test methods \CodeIn{SaveEmptyConfigs} and \CodeIn{SaveNormalProj- ect} involved testing saving of an \CodeIn{NUnitProject}. When a new project is created (i.e., an instance of \CodeIn{NUnitProject} is created), an \CodeIn{xml} file is saved in the project directory for saving the project configurations. These test methods add configurations on this project file and assert if the file is saved in the right format and contains the added configuration information. \CodeIn{SaveEmptyConfigs} test method tests an empty project, with default \CodeIn{debug} and \CodeIn{release} configurations and the latter tests a project saved with multiple configurations. In Phase 1, we were not able to generalize these two tests as they needed interaction with an \CodeIn{xml} file from a \emph{specific location} (the specific location refers to the directory location where the project is saved; when a project is saved, a new directory is created as the project directory). The \CodeIn{xml} file was expected to already exist physically for the test to execute so that the code under test can access the file and add configuration information to the file, and test if the project is correctly saved with the configurations. The existing tests save the projects and assert by reading the \CodeIn{xml} file using a stream reader and check against an expected string (which is constructed based on the configurations that are added). Generalization of these conventional unit tests is not straightforward as every conventional unit test generated by Pex requires a physical file in the expected file location. The code under test has high dependency on external factors, i.e., file reading and writing from a specific location. 

We handled this situation of not being able to generalize due to a high dependency on external environments by mocking the required \CodeIn{xml} file writer in Phase 2. When the code under test saves a project, it opens the \CodeIn{xml} file using \CodeIn{XmlTextWriter}. In order to avoid the complexity of generating a ``real'' file at a ``real'' file location (on creating a project) and writing into the file, we mocked the expected behaviour of \CodeIn{XmlTextWriter} as \CodeIn{MockXmlFileWriter}. This mock object, unlike the real object, appends the text to a string, preserving the output of the actual behaviour of \CodeIn{XmlTextWriter}. The mock object behavior results in the form of a string while the actual object would result in a file. Nevertheless, as suggested by the Pex tutorial~\cite{PEXDOC}, we did not mock every method of the actual class, but mocked only the methods used by the code under test. Figure~\ref{fig:mockobject} shows a code snippet from the mocked object.

\begin{figure}
\begin{CodeOut}
\begin{alltt}
.........
.........
01:\hspace*{0.1in}public MockXmlTextWriter(string filename,
\hspace*{0.3in} Encoding encoding)
02:\hspace*{0.1in}\{
03:\hspace*{0.3in}this.fileName = filename;
04:\hspace*{0.1in}\}

05:\hspace*{0.1in}public void WriteAttributeString
\hspace*{0.3in}(string attributeName, string value)
06:\hspace*{0.1in}\{
07:\hspace*{0.3in}xmlString = xmlString + " " + attributeName 
\hspace*{0.7in}+ "=" + "\"" + value + "\"";
08:\hspace*{0.1in}\}

09:\hspace*{0.1in}public void WriteEndElement()
10:\hspace*{0.1in}\{
11:\hspace*{0.3in}xmlString = xmlString + " />";
12:\hspace*{0.1in}\}

13:\hspace*{0.1in}public void Close()
14:\hspace*{0.1in}\{
15:\hspace*{0.3in}xmlString = xmlString.Replace("/> />", "/>" + 
   \hspace*{0.5in}System.Environment.NewLine + "</" 
   \hspace*{0.7in}+ startString + ">");
16:\hspace*{0.3in}CreatedProjects.currentProject = xmlString;
17:\hspace*{0.1in}\}
............
............
\end{alltt}
\end{CodeOut}
\caption{\label{fig:mockobject} Sample code from the \CodeIn{MockXmlTextWriter} mock object. \textit{In the \CodeIn{WriteAttributeString} method, we append the argument string to a global string \CodeIn{xmlString} and this global string represents the content written to the xml file.}}
\end{figure}

By using the mock object technique, we were able to achieve generalization of both the existing tests of \CodeIn{SaveEmptyConfigs} and \CodeIn{SaveNormalProject}, resulting in a block coverage of $61.64$\% and $67.92$\%, respectively. Recall that we were not able to generalize the existing conventional unit tests when we did not use the mock object. 
%------------------------------------------------------------------------------------------------------

\subsection{Input-Space Partitioning}
\label{sec:inputspace}

Input-space partitioning~\cite{paul:offut} helps partition the input space into disjoint blocks,
where the union of all the blocks should result in the complete input space.  
We explain how we performed the input-space partitioning in our study to achieve
a higher coverage of the method \CodeIn{SaveSetting} of the class
\CodeIn{SettingsGroup}. The \CodeIn{SaveSetting} method accepts an argument of type
\CodeIn{Object}. The method accepts several types such as \CodeIn{int}, \CodeIn{string},
\CodeIn{bool}, and \CodeIn{enum}, and a different path of the code is covered for each type. Therefore, in order to achieve high code coverage, a PUT to test this method should be designed to generate conventional unit tests that take different types of the argument. For simplicity, we explain how we dealt with
integers and strings only. We defined two partitions where the first partition includes
integers and the second partition includes strings. We wrote separate PUTs for
covering these partitions. We repeated the same procedure for other input types. Consequently, Pex achieved high coverage as it was able to generate different input types and cover several program paths.
%----------------------------------------------------------------------------
%\subsection{Delegates} 
%\label{sec:delegate}
%
%Delegates are used to encapsulate a method with a specific signature and 
%a return type. These delegates are used to pass methods as arguments instead
%of data, which is commonly used in practice. Such a feature is quite helpful
%when the method to be called is known \emph{only} during runtime. These delegates
%feature is often used in GUI applications for event-handling. In our study, we found that some code portions are not covered as those portions require the delegates
%to be defined. We next show an example delegate class we used in Phase 2 of our study.
%% We expect that Pex can be easily extended to provide support for
%%delegates also. We next explain how Pex can be extended to provide such support
%%with illustrative examples. 
%\begin{figure}
%\begin{CodeOut}
%\begin{alltt}
%00:namespace Application \{
%01:\hspace*{0.1in}public delegate int MyHandler(object sender, 
%02:\hspace*{0.8in}MyEventArgs e);
%03:\hspace*{0.1in}class DelegateClass \{
%04:\hspace*{0.2in}public int DMethod(object sender, MyEventArgs e)\{
%05:\hspace*{0.3in}Console.WriteLine("In Delegate {0}", e.m_id);
%06:\hspace*{0.2in}\}
%07:\hspace*{0.2in}public A(TestCls b)\{
%08:\hspace*{0.3in}MyHandler d1 = new MyHandler(DMethod);
%09:\hspace*{0.3in}b.Event += d1;
%10:\hspace*{0.2in}\} 
%11:\hspace*{0.1in}\}
%12:\hspace*{0.1in}class TestCls \{
%13:\hspace*{0.2in}public event MyHandler Event;        
%14:\hspace*{0.2in}public void MUT(MyEventArgs e)\{
%15:\hspace*{0.3in}if (Event != null) \{
%16:\hspace*{0.4in}Event(this, e); \}
%17:\hspace*{0.3in}\}
%18:\hspace*{0.2in}\} 
%19:\hspace*{0.1in}\}
%20:\}
%\end{alltt}
%\end{CodeOut}
%\Caption{\label{fig:delegateex} A code example with a delegate handler.}
%\end{figure}
%
%Figure~\ref{fig:delegateex} shows two classes \CodeIn{DelegateClass}
%and \CodeIn{TestCls}. \CodeIn{TestCls} defines a method under test
%with the name \CodeIn{MUT}. When the method \CodeIn{MUT} is executed 
%without defining any delegate handler, Pex cannot cover Statement 16. 
%We manually created a delegate handler 
%with the name \CodeIn{DelegateClass} and added the handler using
%the operator \CodeIn{+=} as shown in Statement 9. These delegate handlers
%are different from normal method calls as there can be multiple delegate handlers
%that can be registered for one event. 
%Pex can be extended 
%to provide additional feature to automatically take care of
%delegate handlers. Pex can generate mock methods based on the signature
%of delegate (shown in Statement 1). For example, Pex can generate a
%mock method with argument types \CodeIn{object} and \CodeIn{MyEventArgs}
%with the following code inside the method.

%\begin{CodeOut}
%\begin{alltt}
%\hspace*{0.1in}var chooser = PexChoose.FromCall(this);
%\hspace*{0.1in}return chooser.ChooseResult<int>();
%\end{alltt}
%\end{CodeOut}

%The preceding method can replace the manually written delegate handler
%shown in Statements 3 to 11 in Figure~\ref{fig:delegateex}.
%The reason for using \CodeIn{PexChoose} in the automatically generated
%mock methods is that Pex can later infer the return value of the mocked
%delegate handler based on the further branch conditions in the source code.
%Sometimes, there can be more than one delegate handler associated with 
%each event such as the method call \CodeIn{Event} in Statement 16. Pex can
%simulate such behavior by defining multiple mock methods for
%each \CodeIn{Event}. One issue that can arise is that when there are multiple
%delegate methods for each \CodeIn{Event}, there can be multiple return values.
%In this scenario, C\# documentation suggests to use the return value
%that is returned from the last delegate.