\section{Patterns and Supporting Techniques}
\label{sec:helper}

We next detail on the PUT patterns and supporting techniques that can be used in writing PUTs. In our study, we primarily use patterns to help generalize test oracles. In addition, we use the supporting techniques of factory methods and mock object to deal with the issues of desirable object states and interactions of the code under test with the environment, respectively. We next describe these techniques in detail.

%-------------------------------------------------------------------------
\subsection{PUT Patterns}
\label{sec:patterns}

A major challenge of writing PUTs is writing a generalized test oracle. When writing CUTs, it is not challenging to write test oracles since for a particular CUT, expected output values can be easily determined for the given input test data based on the method under test. In contrast, when testing with PUTs, determining the expected output values is not trivial; a PUT should be designed to assert output values based on a number of input values generated by Pex for that PUT. To address this issue, we propose $15$ PUT patterns~\cite{halleux08:putpatterns} that help developers to deal with this issue of generalizing test oracles. Table~\ref{tab:patterns} shows $13$ of the proposed $15$ PUT patterns\footnote{The other two PUT patterns are related to regression testing, which is not within the scope of our paper.}.

\setlength{\tabcolsep}{2pt}
\begin{table}[t]
\begin{center}
\begin {tabular} {|r|l|}
\hline
									\#			&	Pattern Name									\\				%&	Pex Supported Attributes or Methods\\
\hline
\hline
									1				&	Arrange, Act, Assert (AAA)					\\				%&	\\
\hline
									2				&	Assume, Arrange, Act, Assert (AAAA) 	\\			%&	\\
\hline
									3				&	Constructor Test							\\				%&	\\
\hline
									4				&	Roundtrip											\\				%&	\\
\hline
									5				&	Sanitized Roundtrip						\\				%&	\\
\hline
									6				&	State Relation								\\				%&	\\
\hline
									7				&	Same Observable Behavior			\\				%&	\\
\hline
									8				&	Commutative Diagram						\\					%&	\\
\hline
									9				&	Cases													\\					%&	PexAssert.Case() 			\\ 
\hline
									10			&	Allowed Exception							\\					%&	[PexAllowedException]	\\
\hline
									11			&	Reachability									\\					%&	[PexExpectedGoals]		\\
\hline
									12			&	Parameterized Stub						\\					%&	[PexAssumeUnderTest]	\\
\hline	
									13			&	Manual Output Review					\\					%&	PexObserve.Value			\\
\hline
%									14			&	Regression Tests							\\					%&	PexStore.ValueForValidation()\\
%\hline
%									15			&	Differential Regression Test Suite	\\%&	\\
%\hline
\end{tabular}
\caption {\label{tab:patterns} PUT Patterns}  \vspace*{-3ex}
\end{center}
\end{table}

The proposed PUT patterns serve two purposes: (1) they assist in designing a PUT based on the developers' test objective, and (2) they assist in determining test oracles that can deal with the generality of the PUT. Patterns 1, 2, 9, 10, and 11 (shown in Table~\ref{tab:patterns}) primarily assist developers in designing PUT based on the test objective. For example, developers can use Pattern 2 (AAAA) when the method under test needs to be tested for a particular range of input values (the PUT includes assumptions), and the behavior of the method under test can be asserted using assertion statements (the PUT includes assertions). Similarly, developers can use Pattern 10 (Allowed Exception) when a method under test may throw a particular exception, and such an exception being raised does not indicate that the unit test fails. 
The remaining patterns listed in the table assist developers in writing test oracles. For example, developers can use Pattern 6 (State Relation) when a method under test causes an internal change to the object state, which in turn can be observed through other methods. 

\begin{figure}
\begin{CodeOut}        
\begin{alltt}
01: public void Clear()
02: \{
03: \hspace{0.07in}root = null;
04: \hspace{0.07in}Count = 0;
05: \}
\end{alltt}        
\end{CodeOut}\vspace*{-4ex}
\caption{\CodeIn{Clear} method of \CodeIn{AvlTree} class of DSA.}
\label{fig:pattern}%

\begin{CodeOut}        
\begin{alltt}
01: public void ClearCUT()
02: \{
03: \hspace{0.07in}AvlTree<int> actual = new AvlTree<int> \{ 1,3,5,6,9,7 \};
04: \hspace{0.07in}Assert.AreEqual(6, actual.Count);
05: \hspace{0.07in}actual.Clear();
06: \hspace{0.07in}Assert.AreEqual(0, actual.Count);            
07: \}
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\caption{Existing CUT to test the \CodeIn{Clear} method.}%
\label{fig:patternCUT}%
\end{figure}

We next illustrate the use of PUT patterns in designing a PUT and in determining a test oracle. Figure~\ref{fig:pattern} shows the \CodeIn{Clear} method from \CodeIn{AvlTree} of the DSA~\cite{dsa} library. The \CodeIn{Clear} method clears the contents of the \CodeIn{AvlTree} object. Figure~\ref{fig:patternCUT} shows the existing CUT to test the \CodeIn{Clear} method. The objective of the CUT is to create an \CodeIn{AvlTree} object with the given list of items, invoke the \CodeIn{Clear} method, and assert if the elements are removed. To transform this CUT to a PUT, developers promote the input list to the constructor of \CodeIn{AvlTree} as a parameter to the PUT. Based on the test objective, developers identify two patterns to write the PUT: (1) AAAA, there should be an assumption on the parameter since the parameter should be non-null, and the result of the \CodeIn{Clear} method should be asserted, and (2) State Relation, since the behavior of the \CodeIn{Clear} method can be observed using the \CodeIn{Count} field, i.e., observe the change in the object state. Using the identified patterns, developers can write a PUT shown in Figure~\ref{fig:patternPUT}. 

\begin{figure}
\begin{CodeOut}        
\begin{alltt}
01: public void ClearPUT([PAUT]List<int> values)
02: \{
03: \hspace{0.07in}AvlTree<int> actual = new AvlTree<int>(values);
04: \hspace{0.07in}PexAssert.AreEqual(values.Count, actual.Count);
05: \hspace{0.07in}actual.Clear();
06: \hspace{0.07in}PexAssert.AreEqual(0, actual.Count);
07: \}
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\caption{PUT transformed from CUT in Figure~\ref{fig:patternCUT}, using the AAAA and State Relation patterns.}%
\label{fig:patternPUT}%
\end{figure}

%-------------------------------------------------------------------------
\subsection{Factory Methods}
\label{sec:factory}

Pex faces challenges in handling PUT parameters of non-primitive types, because these parameters require method-call sequences (that create and mutate objects of non-primitive types) to generate desirable object states. These desirable object states are the states that help explore new paths or branches in the code under test. For example, a desirable object state to cover the \CodeIn{true} branch of Statement 8 in Figure~\ref{fig:cut} is that the \CodeIn{storage} object should already include a value for the setting name \CodeIn{sn}. Although Pex includes a demand-driven strategy for generating method-call sequences, Pex's strategy can generate method-call sequences effectively in certain limited scenarios where the constructors either accept primitive parameters or explicitly state the actual type of the parameter.

To assist Pex in generating effective method-call sequences that can help achieve desirable object states, developers can write method-call sequences inside factory methods, supported by Pex. Figure~\ref{fig:factorymethd} shows an example factory method for the \CodeIn{MemorySettingsStorage} class. The factory method accepts two arrays of setting names (\CodeIn{sn}) and values (\CodeIn{sv}) and adds these entries to the storage. This factory method helps Pex to generate method-call sequences that can create desirable object states. For example, Pex can generate five names and five values as arguments to the factory method for creating a desirable object state with five elements in the storage\footnote{Note that the factory methods provide only an assistance to Pex in achieving the desirable object states, and Pex generates these object states based on the branching conditions in the code under test.}. The same factory method can be reused for all other PUTs using the \CodeIn{MemorySettingsStorage} class as parameter types.

%-------------------------------------------------------------------------
\subsection{Mock Objects} 
\label{sec:mock}

A mock object~\cite{mockobjects} is an implementation for simulating environments such as file systems. Mock objects help test unit behaviors in isolation where the interactions of the unit under test with the real environment are replaced with the mock objects. Automatic test generation tools such as Pex could require various desirable environment states to generate high-covering unit tests. Creating these desirable environment states requires extensive test setup. Since such test setup can generate a lot of garbage in the environment (such as adding extra files in the file system), a significant amount of test cleanup is also required. We next describe how developers can use mock objects with an example from our study. 

\begin{figure}
\begin{CodeOut}
\begin{alltt}
01: public class MockXmlTextWriter\{ 
02:\hspace*{0.1in}public MockXmlTextWriter(string filename,
\hspace*{0.25in} Encoding encoding)
03:\hspace*{0.1in}\{
04:\hspace*{0.3in}this.fileName = filename;
05:\hspace*{0.1in}\}

06:\hspace*{0.1in}public void WriteAttributeString
\hspace*{0.3in}(string attributeName, string value)
07:\hspace*{0.1in}\{
08:\hspace*{0.3in}xmlString = xmlString + " " + attributeName 
\hspace*{0.7in}+ "=" + "\"" + value + "\"";
09:\hspace*{0.1in}\}

10:\hspace*{0.1in}public void Close()
11:\hspace*{0.1in}\{
12:\hspace*{0.3in}xmlString = xmlString.Replace("/> />", "/>" + 
   \hspace*{0.5in}System.Environment.NewLine + "</" 
   \hspace*{0.7in}+ startString + ">");
13:\hspace*{0.3in}CreatedProjects.currentProject = xmlString;
14:\hspace*{0.1in}\}
\hspace*{0.3in}............
15: \}
\end{alltt}
\end{CodeOut}  \vspace*{-3ex}
\caption{\label{fig:mockobject} Sample code from the \CodeIn{MockXmlTextWriter} mock object. In the \CodeIn{WriteAttributeString} method, the argument string is appended to a global string \CodeIn{xmlString} and this global string represents the content written to the xml file.}  \vspace*{-3ex}
\end{figure}

In the \CodeIn{NUnitProject} class of the NUnit application, to test the \CodeIn{save} method, the developer can use a mock object to replace the interactions of code under test with the \CodeIn{XmlTextWriter}. The purpose of the \CodeIn{save} method is to write configuration information to an XML file. This XML file is expected to be created when the project is created, i.e., an instance of \CodeIn{NUnitProject} is created. Two existing CUTs \CodeIn{SaveEmptyConfigs} and \CodeIn{SaveNormalProject} test this \CodeIn{save} method. These CUTs add configurations to the XML project files and assert whether the files are saved in the right format and contain the added configuration information. Both the CUTs depend on a default empty project that is created using the test setup method. Therefore, the requirement to test the \CodeIn{save} method is to provide the project configuration file (the XML file) in a \emph{specific location}, i.e., the directory location where the project is saved (when a project is saved, a new directory is created as the project directory and the XML file is created in this directory). 

To generalize these CUTs, the developer can promote the project path (a parameter to the \CodeIn{save} method and a local variable in the CUTs) as a parameter to the PUT. However, generalization of these CUTs is not straightforward. By promoting the project path as the PUT's paramater, every unit test generated by Pex using the PUT requires an XML file in the location (reflected by the generated value for the parameter). The reason is that when the \CodeIn{save} method is invoked, the XML file is accessed using \CodeIn{XmlTextWriter}. Without the XML file, the \CodeIn{save} method throws an exception. Therefore, to avoid the complexity of creating a ``real'' file at a ``real'' location and to prevent the exception thrown by the \CodeIn{save} method, the developer can mock the expected behavior of \CodeIn{XmlTextWriter} with \CodeIn{MockXmlFileWriter}. This mock object simulates the behavior of \CodeIn{XmlTextWriter}, but unlike the real object, it appends the input text to a \CodeIn{string}, still preserving the output of the actual behavior of \CodeIn{XmlTextWriter}, and avoiding the interactions with the file system. Figure~\ref{fig:mockobject} shows a code snippet of the \CodeIn{MockXmlTextWriter} class. By using the mock-object technique, the developer can achieve generalization of both the CUTs to test the \CodeIn{save} method.

%The \CodeIn{xml} file was expected to already exist physically for the test to execute so that the code under test can access the file and add configuration information to the file, and test if the project is correctly saved with the configurations. The existing tests save the projects and assert by reading the \CodeIn{xml} file using a stream reader and check against an expected string (which is constructed based on the configurations that are added). 
%------------------------------------------------------------------------------------------------------

%\subsection{Input-Space Partitioning}
%\label{sec:inputspace}
%
%Input-space partitioning~\cite{paul:offut} helps partition the input space into disjoint blocks,
%where the union of all the blocks should result in the complete input space.  
%We explain how we performed the input-space partitioning in our study to achieve
%a higher coverage of the method \CodeIn{SaveSetting} of the class
%\CodeIn{SettingsGroup}. The \CodeIn{SaveSetting} method accepts an argument of type
%\CodeIn{Object}. The method accepts several types such as \CodeIn{int}, \CodeIn{string},
%\CodeIn{bool}, and \CodeIn{enum}, and a different path of the code is covered for each type. Therefore, in order to achieve high code coverage, a PUT to test this method should be designed to generate conventional unit tests that take different types of the argument. For simplicity, we explain how we dealt with
%integers and strings only. We defined two partitions where the first partition includes
%integers and the second partition includes strings. We wrote separate PUTs for
%covering these partitions. We repeated the same procedure for other input types. Consequently, Pex achieved high coverage as it was able to generate different input types and cover several program paths.
%----------------------------------------------------------------------------
%\subsection{Delegates} 
%\label{sec:delegate}
%
%Delegates are used to encapsulate a method with a specific signature and 
%a return type. These delegates are used to pass methods as arguments instead
%of data, which is commonly used in practice. Such a feature is quite helpful
%when the method to be called is known \emph{only} during runtime. These delegates
%feature is often used in GUI applications for event-handling. In our study, we found that some code portions are not covered as those portions require the delegates
%to be defined. We next show an example delegate class we used in Phase 2 of our study.
%% We expect that Pex can be easily extended to provide support for
%%delegates also. We next explain how Pex can be extended to provide such support
%%with illustrative examples. 
%\begin{figure}
%\begin{CodeOut}
%\begin{alltt}
%00:namespace Application \{
%01:\hspace*{0.1in}public delegate int MyHandler(object sender, 
%02:\hspace*{0.8in}MyEventArgs e);
%03:\hspace*{0.1in}class DelegateClass \{
%04:\hspace*{0.2in}public int DMethod(object sender, MyEventArgs e)\{
%05:\hspace*{0.3in}Console.WriteLine("In Delegate {0}", e.m_id);
%06:\hspace*{0.2in}\}
%07:\hspace*{0.2in}public A(TestCls b)\{
%08:\hspace*{0.3in}MyHandler d1 = new MyHandler(DMethod);
%09:\hspace*{0.3in}b.Event += d1;
%10:\hspace*{0.2in}\} 
%11:\hspace*{0.1in}\}
%12:\hspace*{0.1in}class TestCls \{
%13:\hspace*{0.2in}public event MyHandler Event;        
%14:\hspace*{0.2in}public void MUT(MyEventArgs e)\{
%15:\hspace*{0.3in}if (Event != null) \{
%16:\hspace*{0.4in}Event(this, e); \}
%17:\hspace*{0.3in}\}
%18:\hspace*{0.2in}\} 
%19:\hspace*{0.1in}\}
%20:\}
%\end{alltt}
%\end{CodeOut}
%\Caption{\label{fig:delegateex} A code example with a delegate handler.}
%\end{figure}
%
%Figure~\ref{fig:delegateex} shows two classes \CodeIn{DelegateClass}
%and \CodeIn{TestCls}. \CodeIn{TestCls} defines a method under test
%with the name \CodeIn{MUT}. When the method \CodeIn{MUT} is executed 
%without defining any delegate handler, Pex cannot cover Statement 16. 
%We manually created a delegate handler 
%with the name \CodeIn{DelegateClass} and added the handler using
%the operator \CodeIn{+=} as shown in Statement 9. These delegate handlers
%are different from normal method calls as there can be multiple delegate handlers
%that can be registered for one event. 
%Pex can be extended 
%to provide additional feature to automatically take care of
%delegate handlers. Pex can generate mock methods based on the signature
%of delegate (shown in Statement 1). For example, Pex can generate a
%mock method with argument types \CodeIn{object} and \CodeIn{MyEventArgs}
%with the following code inside the method.

%\begin{CodeOut}
%\begin{alltt}
%\hspace*{0.1in}var chooser = PexChoose.FromCall(this);
%\hspace*{0.1in}return chooser.ChooseResult<int>();
%\end{alltt}
%\end{CodeOut}

%The preceding method can replace the manually written delegate handler
%shown in Statements 3 to 11 in Figure~\ref{fig:delegateex}.
%The reason for using \CodeIn{PexChoose} in the automatically generated
%mock methods is that Pex can later infer the return value of the mocked
%delegate handler based on the further branch conditions in the source code.
%Sometimes, there can be more than one delegate handler associated with 
%each event such as the method call \CodeIn{Event} in Statement 16. Pex can
%simulate such behavior by defining multiple mock methods for
%each \CodeIn{Event}. One issue that can arise is that when there are multiple
%delegate methods for each \CodeIn{Event}, there can be multiple return values.
%In this scenario, C\# documentation suggests to use the return value
%that is returned from the last delegate.