\section{Patterns and Supporting Techniques}
\label{sec:helper}

We next detail on the PUT patterns and supporting techniques that can be used in writing PUTs. In our study, we primarily use patterns to generalize the test oracle. Additionally, we use the factory method and mock object supporting techniques to deal with the desirable object states and interactions of the code under test with the environment, repectively. We next describe these techniques used in our study.
%-------------------------------------------------------------------------
\subsection{PUT Patterns} 
\label{sec:patterns}
%-------------------------------------------------------------------------
\subsection{Factory Methods} 
\label{sec:factory}

A commonly used technique in test generalization to assist effective test generation is writing factory methods. In our study of writing PUTs and applying Pex on these PUTs to generate test cases, we observed that one of the primary reasons for not achieving high code coverage is due to lack of method-call sequences for achieving desirable object states. Although Pex includes a heuristic demand-driven strategy for generating method-call sequences, we found that Pex's strategy can generate method-call sequences effectively in certain limited scenarios where the constructors either accept primitive arguments or explicitly state the actual type of the argument. To address this issue, we use the factory-method feature provided by Pex. These factory methods allow developers to write method-call sequences that can help Pex in achieving desirable object states. Figure~\ref{fig:factorymethd} shows an example factory method that we used in our study. Our factory method accepts two arrays of setting names and values, and adds those entries to the storage. This factory method helps generate different object states for \CodeIn{MemorySettingStorage}. For example, using our factory method, Pex can generate an object of \CodeIn{MemorySettingStorage} with five elements in the storage. 
%-------------------------------------------------------------------------
\subsection{Mock Objects} 
\label{sec:mock}

A mock object~\cite{mockobjects} is an implementation for simulating environments such as file system. Mock objects help test features in isolation when the interactions of the code under test with real environment are replaced with the mock objects. For automatic test generation tools such as Pex, to generate high covering test inputs could require various environment states. Creating these required environment states could lead to an extensive test setup or generate a lot of noise in the environment, requiring a good amount of test clean up task. We next detail on the use of mock object with an example from our study. 

\begin{figure}
\begin{CodeOut}
\begin{alltt}
01: public class MockXmlTextWriter\{ 
02:\hspace*{0.1in}public MockXmlTextWriter(string filename,
\hspace*{0.25in} Encoding encoding)
03:\hspace*{0.1in}\{
04:\hspace*{0.3in}this.fileName = filename;
05:\hspace*{0.1in}\}

06:\hspace*{0.1in}public void WriteAttributeString
\hspace*{0.3in}(string attributeName, string value)
07:\hspace*{0.1in}\{
08:\hspace*{0.3in}xmlString = xmlString + " " + attributeName 
\hspace*{0.7in}+ "=" + "\"" + value + "\"";
09:\hspace*{0.1in}\}

10:\hspace*{0.1in}public void Close()
11:\hspace*{0.1in}\{
12:\hspace*{0.3in}xmlString = xmlString.Replace("/> />", "/>" + 
   \hspace*{0.5in}System.Environment.NewLine + "</" 
   \hspace*{0.7in}+ startString + ">");
13:\hspace*{0.3in}CreatedProjects.currentProject = xmlString;
14:\hspace*{0.1in}\}
\hspace*{0.3in}............
15: \}
\end{alltt}
\end{CodeOut}
\caption{\label{fig:mockobject} Sample code from the \CodeIn{MockXmlTextWriter} mock object. In the \CodeIn{WriteAttributeString} method, the argument string is appended to a global string \CodeIn{xmlString} and this global string represents the content written to the xml file.}
\end{figure}

In the \CodeIn{NUnitProject} class of NUnit subject application, to test the \CodeIn{save} method, we used a mock object to replace the interactions of code under test with the \CodeIn{XmlTextWriter}. The purpose of the \CodeIn{save} method is to write configuration information to an xml file. This xml file is expected to be created when the project is created i.e., an instance of \CodeIn{NUnitProject} is created. Two existing CUTs \CodeIn{SaveEmptyConfigs} and \CodeIn{SaveNormalProject} involved testing of this method. These CUTs add configurations on the xml project files and assert if the files are saved in the right format and contain the added configuration information. Both the CUTs depend on a default empty project that is created using the test set up method. Thus the requirement to test the \CodeIn{save} is to provide the project configuration file (the xml file) in a \emph{specific location}, i.e., the directory location where the project is saved (when a project is saved, a new directory is created as the project directory and the xml file is created in this directory). For generalizing these CUTs, we promoted the project path (a parameter to the \CodeIn{save} method and a local variable in the CUTs) as a parameter to the PUT. However, generalization of these CUTs is not straightforward. By promoting the project path as the PUT's paramater, every unit test generated by Pex using the PUT requires an xml file in the location (the generated value for the parameter) so that when the \CodeIn{save} method is invoked, the xml file can be accessed using \CodeIn{XmlTextWriter}. In order to avoid the complexity of creating a ``real'' file at a ``real'' location so that when the \CodeIn{save} method accesses the xml file and an exception is not thrown, we mocked the expected behaviour of \CodeIn{XmlTextWriter} as \CodeIn{MockXmlFileWriter}. This mock object simulates the behavior of \CodeIn{XmlTextWriter}, but unlike the real object, it appends the text to a \CodeIn{string}; still preserving the output of the actual behaviour of \CodeIn{XmlTextWriter} avoiding the interactions with the file system. 
%The mock object behavior results in the form of a \CodeIn{string} while the actual object would result in a ``real'' file. 

Figure~\ref{fig:mockobject} shows a code snippet of the \CodeIn{MockXmlTextWriter} class. By using the mock object technique, we were able to achieve generalization of both the CUTs to test the \CodeIn{save} method.

%The \CodeIn{xml} file was expected to already exist physically for the test to execute so that the code under test can access the file and add configuration information to the file, and test if the project is correctly saved with the configurations. The existing tests save the projects and assert by reading the \CodeIn{xml} file using a stream reader and check against an expected string (which is constructed based on the configurations that are added). 
%------------------------------------------------------------------------------------------------------

%\subsection{Input-Space Partitioning}
%\label{sec:inputspace}
%
%Input-space partitioning~\cite{paul:offut} helps partition the input space into disjoint blocks,
%where the union of all the blocks should result in the complete input space.  
%We explain how we performed the input-space partitioning in our study to achieve
%a higher coverage of the method \CodeIn{SaveSetting} of the class
%\CodeIn{SettingsGroup}. The \CodeIn{SaveSetting} method accepts an argument of type
%\CodeIn{Object}. The method accepts several types such as \CodeIn{int}, \CodeIn{string},
%\CodeIn{bool}, and \CodeIn{enum}, and a different path of the code is covered for each type. Therefore, in order to achieve high code coverage, a PUT to test this method should be designed to generate conventional unit tests that take different types of the argument. For simplicity, we explain how we dealt with
%integers and strings only. We defined two partitions where the first partition includes
%integers and the second partition includes strings. We wrote separate PUTs for
%covering these partitions. We repeated the same procedure for other input types. Consequently, Pex achieved high coverage as it was able to generate different input types and cover several program paths.
%----------------------------------------------------------------------------
%\subsection{Delegates} 
%\label{sec:delegate}
%
%Delegates are used to encapsulate a method with a specific signature and 
%a return type. These delegates are used to pass methods as arguments instead
%of data, which is commonly used in practice. Such a feature is quite helpful
%when the method to be called is known \emph{only} during runtime. These delegates
%feature is often used in GUI applications for event-handling. In our study, we found that some code portions are not covered as those portions require the delegates
%to be defined. We next show an example delegate class we used in Phase 2 of our study.
%% We expect that Pex can be easily extended to provide support for
%%delegates also. We next explain how Pex can be extended to provide such support
%%with illustrative examples. 
%\begin{figure}
%\begin{CodeOut}
%\begin{alltt}
%00:namespace Application \{
%01:\hspace*{0.1in}public delegate int MyHandler(object sender, 
%02:\hspace*{0.8in}MyEventArgs e);
%03:\hspace*{0.1in}class DelegateClass \{
%04:\hspace*{0.2in}public int DMethod(object sender, MyEventArgs e)\{
%05:\hspace*{0.3in}Console.WriteLine("In Delegate {0}", e.m_id);
%06:\hspace*{0.2in}\}
%07:\hspace*{0.2in}public A(TestCls b)\{
%08:\hspace*{0.3in}MyHandler d1 = new MyHandler(DMethod);
%09:\hspace*{0.3in}b.Event += d1;
%10:\hspace*{0.2in}\} 
%11:\hspace*{0.1in}\}
%12:\hspace*{0.1in}class TestCls \{
%13:\hspace*{0.2in}public event MyHandler Event;        
%14:\hspace*{0.2in}public void MUT(MyEventArgs e)\{
%15:\hspace*{0.3in}if (Event != null) \{
%16:\hspace*{0.4in}Event(this, e); \}
%17:\hspace*{0.3in}\}
%18:\hspace*{0.2in}\} 
%19:\hspace*{0.1in}\}
%20:\}
%\end{alltt}
%\end{CodeOut}
%\Caption{\label{fig:delegateex} A code example with a delegate handler.}
%\end{figure}
%
%Figure~\ref{fig:delegateex} shows two classes \CodeIn{DelegateClass}
%and \CodeIn{TestCls}. \CodeIn{TestCls} defines a method under test
%with the name \CodeIn{MUT}. When the method \CodeIn{MUT} is executed 
%without defining any delegate handler, Pex cannot cover Statement 16. 
%We manually created a delegate handler 
%with the name \CodeIn{DelegateClass} and added the handler using
%the operator \CodeIn{+=} as shown in Statement 9. These delegate handlers
%are different from normal method calls as there can be multiple delegate handlers
%that can be registered for one event. 
%Pex can be extended 
%to provide additional feature to automatically take care of
%delegate handlers. Pex can generate mock methods based on the signature
%of delegate (shown in Statement 1). For example, Pex can generate a
%mock method with argument types \CodeIn{object} and \CodeIn{MyEventArgs}
%with the following code inside the method.

%\begin{CodeOut}
%\begin{alltt}
%\hspace*{0.1in}var chooser = PexChoose.FromCall(this);
%\hspace*{0.1in}return chooser.ChooseResult<int>();
%\end{alltt}
%\end{CodeOut}

%The preceding method can replace the manually written delegate handler
%shown in Statements 3 to 11 in Figure~\ref{fig:delegateex}.
%The reason for using \CodeIn{PexChoose} in the automatically generated
%mock methods is that Pex can later infer the return value of the mocked
%delegate handler based on the further branch conditions in the source code.
%Sometimes, there can be more than one delegate handler associated with 
%each event such as the method call \CodeIn{Event} in Statement 16. Pex can
%simulate such behavior by defining multiple mock methods for
%each \CodeIn{Event}. One issue that can arise is that when there are multiple
%delegate methods for each \CodeIn{Event}, there can be multiple return values.
%In this scenario, C\# documentation suggests to use the return value
%that is returned from the last delegate.