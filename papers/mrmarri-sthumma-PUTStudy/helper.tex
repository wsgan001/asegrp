\section{Patterns and Supporting Techniques}
\label{sec:helper}

We next detail on the PUT patterns and supporting techniques that can be used in writing PUTs. In our study, we primarily use patterns to generalize the test oracle. Additionally, we use the factory method and mock object supporting techniques to deal with the desirable object states and interactions of the code under test with the environment, repectively. We next describe these techniques used in our study.
%-------------------------------------------------------------------------
\input{putpatterns}
%-------------------------------------------------------------------------
\subsection{Factory Methods}
\label{sec:factory}

Pex faces challenges in handling PUT parameters of non-primitive types, because these parameters require method-call sequences (that create and mutate objects of non-primitive types) to generate desirable object states. These desirable object states are the states that help explore paths in the code under test. For example, a desirable object state to cover the \CodeIn{true} branch of Statement 8 in Figure~\ref{fig:cut} is that the \CodeIn{storage} should already include a value for the setting name \CodeIn{sn}. 
Although Pex includes a heuristic demand-driven strategy for generating method-call sequences, we found that Pex's strategy can generate method-call sequences effectively in certain limited scenarios where the constructors either accept primitive arguments or explicitly state the actual type of the argument.

To assist Pex in generating effective method-call sequences that can help achieve desirable object states, developers can use a feature, called factory methods, provided by Pex. Figure~\ref{fig:factorymethd} shows an example factory method for the \CodeIn{MemorySettingsStorage} class. The factory method accepts two arrays of setting names (\CodeIn{sn}) and values (\CodeIn{sv}) and adds these entries to the storage. This factory method helps Pex to generate method-call sequences that can create desirable object states. For example, Pex can generate five names and five values as arguments to our factory method for creating a desirable object state with five elements in the storage\footnote{Note that the factory methods provide only an assistance to Pex in achieving the desirable object states, and Pex generates these object states based on the branching conditions in the code under test.}. The same factory method can be reused for all other PUTs using the \CodeIn{MemorySettingsStorage} class.

%-------------------------------------------------------------------------
\subsection{Mock Objects} 
\label{sec:mock}

A mock object~\cite{mockobjects} is an implementation for simulating environments such as file system. Mock objects help test features in isolation where the interactions of the code under test with the real environment are replaced with the mock objects. Automatic test generation tools such as Pex could require various desirable environment states to generate high-covering unit tests. Creating these desirable environment states requires an extensive test setup or generate a lot of noise in the environment, requiring a significant amount of test clean up task. We next describe how the developer can use mock object with an example from our study. 

\begin{figure}
\begin{CodeOut}
\begin{alltt}
01: public class MockXmlTextWriter\{ 
02:\hspace*{0.1in}public MockXmlTextWriter(string filename,
\hspace*{0.25in} Encoding encoding)
03:\hspace*{0.1in}\{
04:\hspace*{0.3in}this.fileName = filename;
05:\hspace*{0.1in}\}

06:\hspace*{0.1in}public void WriteAttributeString
\hspace*{0.3in}(string attributeName, string value)
07:\hspace*{0.1in}\{
08:\hspace*{0.3in}xmlString = xmlString + " " + attributeName 
\hspace*{0.7in}+ "=" + "\"" + value + "\"";
09:\hspace*{0.1in}\}

10:\hspace*{0.1in}public void Close()
11:\hspace*{0.1in}\{
12:\hspace*{0.3in}xmlString = xmlString.Replace("/> />", "/>" + 
   \hspace*{0.5in}System.Environment.NewLine + "</" 
   \hspace*{0.7in}+ startString + ">");
13:\hspace*{0.3in}CreatedProjects.currentProject = xmlString;
14:\hspace*{0.1in}\}
\hspace*{0.3in}............
15: \}
\end{alltt}
\end{CodeOut}
\caption{\label{fig:mockobject} Sample code from the \CodeIn{MockXmlTextWriter} mock object. In the \CodeIn{WriteAttributeString} method, the argument string is appended to a global string \CodeIn{xmlString} and this global string represents the content written to the xml file.}
\end{figure}

In the \CodeIn{NUnitProject} class of the NUnit subject application, to test the \CodeIn{save} method, the developer can use a mock object to replace the interactions of code under test with the \CodeIn{XmlTextWriter}. The purpose of the \CodeIn{save} method is to write configuration information to an xml file. This xml file is expected to be created when the project is created i.e., an instance of \CodeIn{NUnitProject} is created. Two existing CUTs \CodeIn{SaveEmptyConfigs} and \CodeIn{SaveNormalProject} test this \CodeIn{save} method. These CUTs add configurations to the xml project files and assert if the files are saved in the right format and contain the added configuration information. Both the CUTs depend on a default empty project that is created using the test setup method. Thus the requirement to test the \CodeIn{save} method is to provide the project configuration file (the xml file) in a \emph{specific location}, i.e., the directory location where the project is saved (when a project is saved, a new directory is created as the project directory and the xml file is created in this directory). 

For generalizing these CUTs, the developer can promote the project path (a parameter to the \CodeIn{save} method and a local variable in the CUTs) as a parameter to the PUT. However, generalization of these CUTs is not straightforward. By promoting the project path as the PUT's paramater, every unit test generated by Pex using the PUT requires an xml file in the location (the generated value for the parameter). The reason is that when the \CodeIn{save} method is invoked, the xml file can be accessed using \CodeIn{XmlTextWriter}. Without the xml file, the \CodeIn{save} method throws an exception. Therefore, to avoid the complexity of creating a ``real'' file at a ``real'' location and to prevent the exception thrown by the \CodeIn{save} method, the developer can mock the expected behavior of \CodeIn{XmlTextWriter} with \CodeIn{MockXmlFileWriter}. This mock object simulates the behavior of \CodeIn{XmlTextWriter}, but unlike the real object, it appends the text to a \CodeIn{string}; still preserving the output of the actual behavior of \CodeIn{XmlTextWriter} avoiding the interactions with the file system. Figure~\ref{fig:mockobject} shows a code snippet of the \CodeIn{MockXmlTextWriter} class. By using the mock object technique, the developer can achieve generalization of both the CUTs to test the \CodeIn{save} method.

%The \CodeIn{xml} file was expected to already exist physically for the test to execute so that the code under test can access the file and add configuration information to the file, and test if the project is correctly saved with the configurations. The existing tests save the projects and assert by reading the \CodeIn{xml} file using a stream reader and check against an expected string (which is constructed based on the configurations that are added). 
%------------------------------------------------------------------------------------------------------

%\subsection{Input-Space Partitioning}
%\label{sec:inputspace}
%
%Input-space partitioning~\cite{paul:offut} helps partition the input space into disjoint blocks,
%where the union of all the blocks should result in the complete input space.  
%We explain how we performed the input-space partitioning in our study to achieve
%a higher coverage of the method \CodeIn{SaveSetting} of the class
%\CodeIn{SettingsGroup}. The \CodeIn{SaveSetting} method accepts an argument of type
%\CodeIn{Object}. The method accepts several types such as \CodeIn{int}, \CodeIn{string},
%\CodeIn{bool}, and \CodeIn{enum}, and a different path of the code is covered for each type. Therefore, in order to achieve high code coverage, a PUT to test this method should be designed to generate conventional unit tests that take different types of the argument. For simplicity, we explain how we dealt with
%integers and strings only. We defined two partitions where the first partition includes
%integers and the second partition includes strings. We wrote separate PUTs for
%covering these partitions. We repeated the same procedure for other input types. Consequently, Pex achieved high coverage as it was able to generate different input types and cover several program paths.
%----------------------------------------------------------------------------
%\subsection{Delegates} 
%\label{sec:delegate}
%
%Delegates are used to encapsulate a method with a specific signature and 
%a return type. These delegates are used to pass methods as arguments instead
%of data, which is commonly used in practice. Such a feature is quite helpful
%when the method to be called is known \emph{only} during runtime. These delegates
%feature is often used in GUI applications for event-handling. In our study, we found that some code portions are not covered as those portions require the delegates
%to be defined. We next show an example delegate class we used in Phase 2 of our study.
%% We expect that Pex can be easily extended to provide support for
%%delegates also. We next explain how Pex can be extended to provide such support
%%with illustrative examples. 
%\begin{figure}
%\begin{CodeOut}
%\begin{alltt}
%00:namespace Application \{
%01:\hspace*{0.1in}public delegate int MyHandler(object sender, 
%02:\hspace*{0.8in}MyEventArgs e);
%03:\hspace*{0.1in}class DelegateClass \{
%04:\hspace*{0.2in}public int DMethod(object sender, MyEventArgs e)\{
%05:\hspace*{0.3in}Console.WriteLine("In Delegate {0}", e.m_id);
%06:\hspace*{0.2in}\}
%07:\hspace*{0.2in}public A(TestCls b)\{
%08:\hspace*{0.3in}MyHandler d1 = new MyHandler(DMethod);
%09:\hspace*{0.3in}b.Event += d1;
%10:\hspace*{0.2in}\} 
%11:\hspace*{0.1in}\}
%12:\hspace*{0.1in}class TestCls \{
%13:\hspace*{0.2in}public event MyHandler Event;        
%14:\hspace*{0.2in}public void MUT(MyEventArgs e)\{
%15:\hspace*{0.3in}if (Event != null) \{
%16:\hspace*{0.4in}Event(this, e); \}
%17:\hspace*{0.3in}\}
%18:\hspace*{0.2in}\} 
%19:\hspace*{0.1in}\}
%20:\}
%\end{alltt}
%\end{CodeOut}
%\Caption{\label{fig:delegateex} A code example with a delegate handler.}
%\end{figure}
%
%Figure~\ref{fig:delegateex} shows two classes \CodeIn{DelegateClass}
%and \CodeIn{TestCls}. \CodeIn{TestCls} defines a method under test
%with the name \CodeIn{MUT}. When the method \CodeIn{MUT} is executed 
%without defining any delegate handler, Pex cannot cover Statement 16. 
%We manually created a delegate handler 
%with the name \CodeIn{DelegateClass} and added the handler using
%the operator \CodeIn{+=} as shown in Statement 9. These delegate handlers
%are different from normal method calls as there can be multiple delegate handlers
%that can be registered for one event. 
%Pex can be extended 
%to provide additional feature to automatically take care of
%delegate handlers. Pex can generate mock methods based on the signature
%of delegate (shown in Statement 1). For example, Pex can generate a
%mock method with argument types \CodeIn{object} and \CodeIn{MyEventArgs}
%with the following code inside the method.

%\begin{CodeOut}
%\begin{alltt}
%\hspace*{0.1in}var chooser = PexChoose.FromCall(this);
%\hspace*{0.1in}return chooser.ChooseResult<int>();
%\end{alltt}
%\end{CodeOut}

%The preceding method can replace the manually written delegate handler
%shown in Statements 3 to 11 in Figure~\ref{fig:delegateex}.
%The reason for using \CodeIn{PexChoose} in the automatically generated
%mock methods is that Pex can later infer the return value of the mocked
%delegate handler based on the further branch conditions in the source code.
%Sometimes, there can be more than one delegate handler associated with 
%each event such as the method call \CodeIn{Event} in Statement 16. Pex can
%simulate such behavior by defining multiple mock methods for
%each \CodeIn{Event}. One issue that can arise is that when there are multiple
%delegate methods for each \CodeIn{Event}, there can be multiple return values.
%In this scenario, C\# documentation suggests to use the return value
%that is returned from the last delegate.