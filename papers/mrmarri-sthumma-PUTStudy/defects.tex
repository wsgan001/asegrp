\subsection{RQ2: Defects}

To address RQ2, we identify the number of defects detected by PUTs. Since we are using the CUTs that are available with the sources, we did not find any failing CUTs, i.e., no defects are reported by the existing unit tests for any of the subjects. Therefore, any failing tests among the unit tests generated from PUTs are considered as new defects that are not detected by the CUTs. However, before confirming whether a failing unit test implies a defect in the code under test, we manually verify that the generated test data is valid and the defect is not a false positive due to an ineffective PUT. 

Through test generalization of the three subjects in our study, we found $13$ new defects in the DSA application and $3$ new defects in the NUnit application. Since we were sure that the resulting failing tests were due to the defects in the code under test, we reported the failing test scenarios on the hosting website and waiting for the confirmation from the developers\footnote{Reported bugs can be found at the DSA CodePlex website with defect IDs from $8846$ to $8858$ and the NUnit SourceForge website with defect IDs from $0$ to $0$.}.

We next explain an example defect detected in the \CodeIn{Heap} class for the DSA application by our test generalization. The \CodeIn{Heap} class is a heap data structure implementation in the \CodeIn{DataStructure} namespace. This class includes methods to add, remove, and to heapify the elements in the heap. The \CodeIn{Remove} method of the class takes an item to be removed as a parameter and returns \CodeIn{True} when the item to be removed is in the heap, and returns \CodeIn{False} otherwise. Figure~\ref{fig:defectCUT} shows the existing CUT that tests whether the \CodeIn{Remove} method returns \CodeIn{False} when an item that is not in the heap is passed as the parameter. On executing, this CUT passes indicating no defect in the code under test since there are no other CUTs in the test suite that test the behavior of the method. However, from our generalized PUT shown in Figure~\ref{fig:defectPUT}, a few of the generated unit tests failed indicating the possibility of a defect in the \CodeIn{Remove} method. The test data for the failing unit tests had the following common properties: the heap size is less than $4$ (the \CodeIn{input} parameter of the PUT is of size less than $4$), the item to be removed is $0$ (the \CodeIn{item} parameter of the PUT), and the item $0$ was not already added to the heap (generated value for \CodeIn{input} did not contain the item $0$). When we manually analyzed the cause of the failing unit tests, we found that in the constructor of the \CodeIn{Heap} class, a default array of size $4$ (of type \CodeIn{int}) is created to store the items. In C\# an integer array is by default assigned values zero to the elements of the array. Therefore, there is always an item $0$ in the heap unless an input list of size greater than or equal to $4$ is passed as parameter. Therefore, on calling the \CodeIn{Remove} method to remove the item $0$, even when there is no such item in the heap, the method returns \CodeIn{True} indicating that the item has been successfully removed and causing the assertion statement to fail (statement $6$ of the PUT). However, this defect was not detected by the CUT shown in Figure~\ref{fig:defectCUT} as the unit test assigns the heap with $5$ elements (statement $2$) and therefore the defect-exposing scenario of heap size $< 4$ cannot be encountered. 

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
//To test Remove item not present
01: public void RemoveCUT()\{
02: \hspace*{0.07in}Heap<int> actual = new Heap<int> \{2, 78, 1, 0, 56\};
03: \hspace*{0.07in}Assert.IsFalse(actual.Remove(99));
04: \hspace*{0.02in}\}
\end{alltt}
\end{CodeOut} \vspace*{-3ex}
\caption{Existing CUT to test the \CodeIn{Remove} method of \CodeIn{Heap}.}
\label{fig:defectCUT}

\begin{CodeOut}
\begin{alltt}
01: public void RemoveItemPUT(
\hspace*{0.7in} [PAUT]List<int> input, int item) \{
02: \hspace*{0.07in}Heap<int> actual = new Heap<int> (input);
03: \hspace*{0.07in}if (input.Contains(item)) \{
04: \hspace*{0.2in}..... \}
05: \hspace*{0.07in}else \{
06: \hspace*{0.2in}PexAssert.IsFalse(actual.Remove(randomPick));
07: \hspace*{0.2in}PexAssert.AreEqual(input.Count, actual.Count);
08: \hspace*{0.2in}CollectionAssert.AreEquivalent(actual, input);\}
09: \hspace*{0.02in}\}
\end{alltt}
\end{CodeOut} \vspace*{-3ex}
\caption{Transformed PUT of the CUT shown in Figure~\ref{fig:defectCUT}.} \vspace*{-1ex}
\label{fig:defectPUT} 
\end{figure}

This example defect that was detected in our study displays the strength of generalized unit tests such as PUTs. The $16$ defects reported in our study that were not detected by the existing unit tests show that PUTs can assist in an unbiased test generation and are an effective means for rigorous testing of the code under test.  
%------------------------------------------------------------------------------------------------------------------------------------------
%We conduct second evaluation based on mutation testing to further show the effectiveness of PUTs in detecting defects compared to CUTs. The reason for the second evaluation is that the existing CUTs do not detect any defects in the code under test. In this evaluation, we seed defects in the code under test using a mutation testing tool and verify
%how many mutants are killed by existing CUTs and PUTs. We consider that a mutant is killed if any previously passing test fails after executed with the seeded fault. 
%
%We use the following five basic mutation operators, recommended by Offutt, for seeding defects in the code under test.
%
%\begin{itemize}
%\item ABS: Forces each arithmetic expression to take values zero, positive and negative values.
%\item AOR: Replaces each arithmetic operator with every syntactically legal operator.
%\item LCR: Replaces logical connector (AND and OR) with other kinds of logical operators.
%\item ROR: Replaces each relational operator with other relational operators.
%\item UOI: Inserts unary operators in front of expressions.
%\end{itemize}