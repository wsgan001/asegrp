\subsection{RQ2: Defects}

To address RQ2, we identify the number of defects detected by PUTs. Since we used the CUTs that are available with the sources, we did not find any failing CUTs, i.e., no defects are reported by the existing unit tests for any of the subjects. Therefore, any failing tests among the unit tests generated from PUTs are considered as new defects that are not detected by the CUTs. However, before confirming whether a failing unit test indicates a defect in the code under test, we manually verify that the generated test data is valid and the defect is not a false positive due to an ineffective PUT. 

Through test generalization of the three subjects in our study, we found $13$ new defects in the DSA application and $3$ new defects in the NUnit application. Since we were sure that the resulting failing tests were due to defects in the code under test, we reported the failing tests on its hosting website and are waiting for the confirmation from the developers\footnote{Reported bugs can be found at the DSA CodePlex website with defect IDs from $8846$ to $8858$ and the NUnit SourceForge website with defect IDs $2872749$, $2872752$, and $2872753$.}.

We next explain an example defect detected in the \CodeIn{Heap} class from the DSA application by test generalization. The \CodeIn{Heap} class is a heap implementation in the \CodeIn{DataStructure} namespace. This class includes methods to add, remove, and to heapify the elements in the heap. The \CodeIn{Remove} method of the class takes an item to be removed as a parameter and returns \CodeIn{true} when the item to be removed is in the heap, and returns \CodeIn{false} otherwise. Figure~\ref{fig:defectCUT} shows the existing CUT that tests whether the \CodeIn{Remove} method returns \CodeIn{false} when an item that is not in the heap is passed as the parameter. On execution, this CUT passes exposing no defect in the code under test and there are no other CUTs in the test suite that test the behavior of the method. However, from our generalized PUT shown in Figure~\ref{fig:defectPUT}, a few of the generated unit tests failed exposing a defect in the \CodeIn{Remove} method. The test data for the failing unit tests had the following common characteristics: the heap size is less than $4$ (the \CodeIn{input} parameter of the PUT is of size less than $4$), the item to be removed is $0$ (the \CodeIn{item} parameter of the PUT), and the item $0$ was not already added to the heap (the generated value for \CodeIn{input} did not contain the item $0$). When we manually analyzed the cause of the failing unit tests, we found that in the constructor of the \CodeIn{Heap} class, a default array of size $4$ (of type \CodeIn{int}) is created to store the items. In C\#, an integer array is by default assigned values zero to the elements of the array. Therefore, there is always an item $0$ in the heap unless an input list of size greater than or equal to $4$ is passed as parameter. Therefore, on calling the \CodeIn{Remove} method to remove the item $0$, even when there is no such item in the heap, the method returns \CodeIn{true} indicating that the item has been successfully removed and causing the assertion statement to fail (Statement $6$ of the PUT). However, this defect was not detected by the CUT shown in Figure~\ref{fig:defectCUT} since the unit test assigns the heap with $5$ elements (Statement $2$) and therefore the defect-exposing scenario of heap size $< 4$ cannot be exercised. 

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
//To test Remove item not present
01: public void RemoveCUT()\{
02: \hspace*{0.07in}Heap<int> actual = new Heap<int> \{2, 78, 1, 0, 56\};
03: \hspace*{0.07in}Assert.IsFalse(actual.Remove(99));
04: \hspace*{0.02in}\}
\end{alltt}
\end{CodeOut} \vspace*{-4ex}
\caption{\label{fig:defectCUT}Existing CUT to test the \CodeIn{Remove} method of \CodeIn{Heap}.}\vspace*{-1.5ex}
\begin{CodeOut}
\begin{alltt}
01: public void RemoveItemPUT(
\hspace*{0.7in} [PAUT]List<int> input, int item) \{
02: \hspace*{0.07in}Heap<int> actual = new Heap<int> (input);
03: \hspace*{0.07in}if (input.Contains(item)) \{
04: \hspace*{0.2in}..... \}
05: \hspace*{0.07in}else \{
06: \hspace*{0.2in}PexAssert.IsFalse(actual.Remove(randomPick));
07: \hspace*{0.2in}PexAssert.AreEqual(input.Count, actual.Count);
08: \hspace*{0.2in}CollectionAssert.AreEquivalent(actual, input);\}
09: \hspace*{0.02in}\}
\end{alltt}
\end{CodeOut} \vspace*{-4ex}
\caption{Transformed PUT of the CUT shown in Figure~\ref{fig:defectCUT}.} \vspace*{-2ex}
\label{fig:defectPUT} 
\end{figure}

This example defect detected in our study demonstrates the strength of generalized unit tests such as PUTs. The $16$ defects reported in our study that were not detected by the existing unit tests show that PUTs an effective means for rigorous testing of the code under test.  
%------------------------------------------------------------------------------------------------------------------------------------------
%We conduct second evaluation based on mutation testing to further show the effectiveness of PUTs in detecting defects compared to CUTs. The reason for the second evaluation is that the existing CUTs do not detect any defects in the code under test. In this evaluation, we seed defects in the code under test using a mutation testing tool and verify
%how many mutants are killed by existing CUTs and PUTs. We consider that a mutant is killed if any previously passing test fails after executed with the seeded fault. 
%
%We use the following five basic mutation operators, recommended by Offutt, for seeding defects in the code under test.
%
%\begin{itemize}
%\item ABS: Forces each arithmetic expression to take values zero, positive and negative values.
%\item AOR: Replaces each arithmetic operator with every syntactically legal operator.
%\item LCR: Replaces logical connector (AND and OR) with other kinds of logical operators.
%\item ROR: Replaces each relational operator with other relational operators.
%\item UOI: Inserts unary operators in front of expressions.
%\end{itemize}