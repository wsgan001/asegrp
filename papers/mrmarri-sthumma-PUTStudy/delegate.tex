\subsection{Input-Space Partitioning}
\label{sec:inputspace}

Input-space partitioning helps partition the input space into disjoint blocks,
where the union of all the blocks should result in the complete input space.  
We explain how we performed the input-space partitioning in our study to achieve
a higher coverage of the method \CodeIn{SaveSetting} of the class
\CodeIn{SettingsGroup}. The \CodeIn{SaveSetting} method accepts an argument of type
\CodeIn{Object}. The method accepts several types such as \CodeIn{int}, \CodeIn{string},
\CodeIn{bool} and \CodeIn{enum} and a different path of the code is covered for each type. Therefore, in order to achieve high code coverage, a PUT to test this method should be designed to generate conventional unit tests that take different types of the argument. For simplicity, we explain how we dealt with
integers and strings. We defined two blocks where the first block includes
integers and the second block includes strings. We wrote separate PUTs for
covering these blocks. We repeated the same procedure for other input types. Consequently, Pex achieved high coverage as it was able to generate different input types and cover several program paths.
%----------------------------------------------------------------------------
\subsection{Delegates} 
\label{sec:delegate}

%Delegates are used to encapsulate a method with a specific signature and 
%a return type. These delegates are used to pass methods as arguments instead
%of data, which is commonly used in practice. Such a feature is quite helpful
%when the method to be called is known \emph{only} during runtime. These delegates
%feature is often used in GUI applications for event-handling. In our study, we found that some code portions are not covered as those portions require the delegates
%to be defined. We expect that Pex can be easily extended to provide support for
%delegates also. We next explain how Pex can be extended to provide such support
%with illustrative examples. 
%
%\begin{figure}
%\begin{CodeOut}
%\begin{alltt}
%00:namespace Application \{
%01:\hspace*{0.1in}public delegate int MyHandler(object sender, 
%02:\hspace*{0.8in}MyEventArgs e);
%03:\hspace*{0.1in}class DelegateClass \{
%04:\hspace*{0.2in}public int DMethod(object sender, MyEventArgs e)\{
%05:\hspace*{0.3in}Console.WriteLine("In Delegate {0}", e.m_id);
%06:\hspace*{0.2in}\}
%07:\hspace*{0.2in}public A(TestCls b)\{
%08:\hspace*{0.3in}MyHandler d1 = new MyHandler(DMethod);
%09:\hspace*{0.3in}b.Event += d1;
%10:\hspace*{0.2in}\} 
%11:\hspace*{0.1in}\}
%12:\hspace*{0.1in}class TestCls \{
%13:\hspace*{0.2in}public event MyHandler Event;        
%14:\hspace*{0.2in}public void MUT(MyEventArgs e)\{
%15:\hspace*{0.3in}if (Event != null) \{
%16:\hspace*{0.4in}Event(this, e); \}
%17:\hspace*{0.3in}\}
%18:\hspace*{0.2in}\} 
%19:\hspace*{0.1in}\}
%20:\}
%\end{alltt}
%\end{CodeOut}
%\Caption{\label{fig:delegateex} A code example with a delegate handler.}
%\end{figure}
%
%Figure~\ref{fig:delegateex} shows two classes \CodeIn{DelegateClass}
%and \CodeIn{TestCls}. \CodeIn{TestCls} defines a method under test
%with the name \CodeIn{MUT}. When the method \CodeIn{MUT} is executed 
%without defining any delegate handler, Pex cannot cover Statement 16.
%In the current example, we manually created a delegate handler
%with the name \CodeIn{DelegateClass} and added the handler using
%the operator \CodeIn{+=} as shown in Statement 9. These delegate handlers
%are different from normal method calls as there can be multiple delegate handlers
%that can be registered for one event. Pex can be extended 
%to provide additional feature to automatically take care of
%delegate handlers. Pex can generate mock methods based on the signature
%of delegate (shown in Statement 1). For example, Pex can generate a
%mock method with argument types \CodeIn{object} and \CodeIn{MyEventArgs}
%with the following code inside the method.
%
%\begin{CodeOut}
%\begin{alltt}
%\hspace*{0.1in}var chooser = PexChoose.FromCall(this);
%\hspace*{0.1in}return chooser.ChooseResult<int>();
%\end{alltt}
%\end{CodeOut}
%
%The preceding method can replace the manually written delegate handler
%shown in Statements 3 to 11 in Figure~\ref{fig:delegateex}.
%The reason for using \CodeIn{PexChoose} in the automatically generated
%mock methods is that Pex can later infer the return value of the mocked
%delegate handler based on the further branch conditions in the source code.
%Sometimes, there can be more than one delegate handler associated with 
%each event such as the method call \CodeIn{Event} in Statement 16. Pex can
%simulate such behavior by defining multiple mock methods for
%each \CodeIn{Event}. One issue that can arise is that when there are multiple
%delegate methods for each \CodeIn{Event}, there can be multiple return values.
%In this scenario, C\# documentation suggests to use the return value
%that is returned from the last delegate.