\subsection{RQ3: Test Code Maintenance}

We next address RQ3 of whether test generalization can reduce the effort in maintaining test code. We use two metrics to address this research question. First, we compare the number of CUTs and the number of PUTs. The lower the number of CUTs or PUTs, the less is the effort required in maintaining the test code. The reason is that whenever the behaviors of code under test is changed via code modifications, all failing tests need to be modified based on the new expected behavior of the code under test. Therefore, a lower number of PUTs can reduce the effort in maintaining the test code since only a few PUTs need to be modified. Second, we compare the Lines of Code (LOC) of CUTs and PUTs. The reason for the second metric is that a lower number of PUTs with a high number of LOC does not help in reducing the effort required in maintaining the test code.

\begin{figure}[t]
\centering
\includegraphics[scale=0.60,clip,trim=200 200 00 150]{charts/CUTs_PUTs_1.eps}\vspace*{-4ex}
\caption{\label{fig:cutsnputs}Comparison of the number of CUTs and PUTs} \vspace*{-4ex}
\end{figure}

\begin{table}[t]
\begin{CodeOut}
\begin{center}
\centering 
\begin {tabular} {|c|c|c|}
\hline \textbf{CUT} & \textbf{PUT} & \textbf{\# of occurrences}\\
\hline
\hline 1   & 1   & 129\\
\hline 1   & 2   & 2\\
\hline 2   & 1   & 29\\
\hline 3   & 1   & 14\\
\hline 4   & 1   & 15\\
\hline 5   & 1   & 4\\
\hline 6   & 1   & 4\\
\hline 7   & 1   & 1\\
\hline 8   & 1   & 2\\
\hline 9   & 1   & 1\\
\hline 15   & 1   & 1\\
\hline
\end{tabular}\vspace*{-2ex}
\caption {\label{tab:cutputmapping} Mapping of the number of CUTs and their transformed PUTs.} \vspace*{-4ex}
\end{center}
\end{CodeOut}
\end{table}

Figure~\ref{fig:cutsnputs} shows the comparison of the number of CUTs with PUTs for all subject applications. The x-axis shows the subject application and y-axis shows the number of CUTs or PUTs. In total, we generalized $407$ CUTs to $224$ PUTs that achieved higher branch coverage than CUTs and also detected new defects that are not detected by the CUTs. The figure shows that there is a significant reduction in the number of tests for the subjects DSA and NUnit. This reduction in the number of tests is because multiple CUTs are generalized to a single PUT. Table~\ref{tab:cutputmapping} shows the mappings between the number of CUTs and their transformed PUTs. For example, Row 1 shows that one CUT is transformed to one PUT in 129 occurrences. Similarly, the last row shows that 15 CUTs are transformed into a single PUT in one occurrence. Row 2 shows an exceptional case where a CUT is generalized to more than one PUT. Section~\ref{sec:limitations} discusses more about this exceptional case. 

Figure~\ref{fig:transformedPUT} shows an example PUT, which is a result of generalizing four CUTs of the \CodeIn{SinglyLinkedList} class of DSA. The objective of all four CUTs is to test the \CodeIn{AddFirst} method (method under test) that adds an element to a list object of type \CodeIn{SinglyLinkedList}. These four CUTs verify different behaviors by adding one element or two elements to a list and by verifying whether the \CodeIn{head} and \CodeIn{tail} values of the list are updated correctly. We generalized all these four CUTs into a single PUT shown in Figure~\ref{fig:transformedPUT}. The CUTs verify the behavior of the \CodeIn{AddTest} method by adding only a fixed number of elements (with fixed values) to the list. In contrast, our PUT can verify the behavior of the \CodeIn{AddFirst} method with a varied number of elements in the list. 

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
//PAUT = PexAssumeUnderTest
public void AddFirstTest([PAUT]SinglyLinkedList<int> sll, 
\hspace*{0.6in}[PAUT]int[] ne) \{            
\hspace*{0.2in}PexAssume.IsTrue(ne.Length > 1);
\hspace*{0.2in}PexAssume.IsTrue(sll.Count == 0);
\hspace*{0.2in}for (int i = 0; i < ne.Length; i++)
\hspace*{0.4in}sll.AddFirst(ne[i]);
\hspace*{0.2in}PexAssert.AreEqual(ne[ne.Length - 1], sll.Head.Value);            
\hspace*{0.2in}PexAssert.AreEqual(ne[0], sll.Tail.Value);
\hspace*{0.2in}PexAssert.AreEqual(ne.Length, sll.Count);
\}
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\Caption{\label{fig:transformedPUT} PUT for the \CodeIn{AddFirst} method under test.} \vspace*{-3ex}
\end{figure}

Figure~\ref{fig:loccomp} shows the results of comparing the LOC of CUTs and PUTs. For DSA and QuickGraph, the LOC of PUTs is less than the LOC of CUTs, whereas for NUnit, the LOC of PUTs is slightly more than the LOC of CUTs. Section~\ref{sec:limitations} describes why the LOC of PUTs for NUnit is slightly more than the LOC of CUTs. As shown, for QuickGraph, although there is no reduction in the number of CUTs, the LOC of PUTs is reduced by 37\%, showing the significance of test generalization. For DSA, the reduction in the LOC (7.8\%) is not as significant as the reduction in the number of tests (50.2\%). We identify that among new LOC written for PUTs, many statements are related to the additional using statements or new annotations that do not effect the efforts in maintaining test code. Therefore, our results show that test generalization can help reduce the number of tests (and LOC) and thereby reduce the efforts in maintaining test code.

\begin{figure}[t]
\centering
\includegraphics[scale=0.60,clip,trim=200 180 00 190]{charts/LOC_1.eps}\vspace*{-3ex}
\caption{\label{fig:loccomp}Comparison of Lines of Code of CUTs and PUTs.} \vspace*{-3.5ex}
\end{figure}
