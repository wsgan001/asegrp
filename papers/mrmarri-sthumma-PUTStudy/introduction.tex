\section{Introduction}
\label{sec:intro}

In software development life cycle, unit testing is a key phase that helps detect defects at an early stage. In practice, it is essential to write high-covering tests during unit testing to ensure high quality of the software under development. Conventionally, a unit test do not accept any parameters and include three major parts: test scenario, test data, and test oracle. Test scenario refers to a sequence of method calls invoked by the unit test. Test data refers to concrete values passed as arguments for the method calls. Test oracle refers to an assertion statement that verifies whether the actual behavior is the same as the expected behavior. 

%\textcolor{red}{Parameterized Unit Tests (PUTs)~\cite{tillmann05:parameterized} are a new advancement in the field of software testing. Unlike conventional unit tests, PUTs accept parameters. The major advantage of PUTs compared to conventional unit tests is that developers do not have to provide test data in PUT. An approach, called Dynamic Symbolic Execution (DSE)~\cite{king:symex, godefroid05:dart, sen07:cute}, can be used to automatically generate conventional unit tests that achieve a high coverage of code under test. Initially, DSE explores the code under test with random values and collects constraints along the path executed in the code under test. DSE next systematically flips collected constraints and uses a constraint solver to generate concrete values that guide program execution through alternate paths.In our empirical study, we use Pex~\cite{tillmann08:pex, pex:rel} as an example state-of-the-art DSE based approach. Pex generates a conventional unit test for each set of concrete values that explores a new path in the code under test. The reason for using Pex in our empirical study is its popularity indicated by the recent public releases, which recorded thousands of download counts~\cite{pex:rel}. Pex was previously used internally at Microsoft to test core components of the .NET framework and found serious defects~\cite{tillmann08:pex}.}

Parameterized Unit Tests (PUTs)~\cite{tillmann05:parameterized} are a new advancement in the field of software testing. Unlike conventional unit tests, PUTs accept parameters. The major advantage of PUTs compared to conventional unit tests is that developers do not need to provide test data in PUT, but only need to provide the variables that represent the test data as parameters. The concrete values for these parameters can be generated automatically using the Dynamic Symbolic Execution (DSE)~\cite{king:symex, godefroid05:dart, sen07:cute} approach. Given code under test, DSE explores the code under test with random values and collects constraints along the execution path. DSE next systematically flips collected constraints and uses a constraint solver to generate concrete values that guide program execution through alternate paths. Microsoft Pex~\cite{tillmann08:pex, pex:rel} is an example state-of-the-art DSE based test generation tool that accepts PUTs and uses DSE to generate test data. Pex explores the provided PUTs, and generates a conventional unit test for each set of concrete values that explores a new path in the PUT or the code under test. PUTs thus provide a generic representation of conventional unit tests and are more powerful as PUTs provide a means for guided test data generation when used with an automatic testing tool such as Pex. 
%The reason for using Pex in our empirical study is its popularity indicated by the recent public releases, which recorded thousands of download counts~\cite{pex:rel}. Pex was previously used internally at Microsoft to test core components of the .NET framework and found serious defects~\cite{tillmann08:pex}.

Although PUTs, in combination with DSE based tools such as Pex, are more beneficial than conventional unit tests, PUTs are not widely adopted by the software industry. One major reason for such a low application of PUTs in practice could be that writing PUTs is a challenging task. On the other hand, most of the software industry uses conventional unit tests as a primary means for ensuring the quality of their developed software. To leverage the benefits of PUTs and to alleviate the complexity in writing PUTs, we propose to transform the legacy conventional unit tests into PUTs. This process of transforming conventional unit tests into PUTs, referred to as \emph{test generalization}, has three major advantages. First, using PUTs, unit tests that can achieve a high coverage of the code under test can be automatically generated. Therefore, through test generalization, new conventional unit tests can be generated that cover additional paths (in the code under test), which are not covered by the legacy conventional unit tests. Second, test generalization increases the fault detection capabilities of the test suite by appending more unit tests to the legacy unit tests. Third, test generalization helps reduce the efforts required for test code maintenance since a single PUT can represent multiple conventional unit tests. Given these benefits of test generalization, we propose a systematic procedure for assisting developers in generalizing conventional unit tests for leveraging the benefits of PUTs. To the best of our knowledge, ours is the first empirical study that proposes a systematic procedure for generalizing conventional unit tests into PUTs and also shows the benefits of test generalization. 

The main objective of our systematic procedure is to take existing conventional unit tests and transform into PUTs to test the same or generalized behaviors as the ones tested by  conventional unit tests. To generalize a conventional unit test, we first identify elements in the conventional unit test (such as arguments or the receiver object of the method under test) and promote these elements as PUT parameters. We then generalize the existing test oracles to fit into the PUT. During test generalization, there are two major challenges with respect to handling parameters of PUTs: (1) generating legal input values for primitive argument types and (2) generating desirable object states for non-primitive argument types. These desirable object states are the states that help explore paths in the code under test by covering \CodeIn{true} or \CodeIn{false} branches. 
To assist Pex or any other DSE-based tool to generate legal input values, we need to provide a sufficient number of assumptions on the parameters of PUTs. For example, consider a method under test that accepts an integer argument and includes a precondition that the argument should be greater than $1000$. We add assumptions on the parameters of the PUTs to ensure that legal input values for primitive types are generated by the test generation tool. To address the second issue of generating desirable object states for non-primitive argument types, we write method-call sequences that create and mutate instances of non-primitive object types. Furthermore, there is an intrinsic challenge in generalizing test oracle and it might not be possible to fully generalize test oracles. To deal with these challenges and to ease the process of test generalization, we propose several test patterns~\cite{halleux08:putpatterns} and use various supporting techniques.  Furthermore, when a PUT requires desired states of the environment, external to the application, such as a file needs to exist in the file system for each generated unit test, we use mock objects to isolate the execution of the generated unit tests from the environment. 

We show the benefits of generalizing conventional unit tests into PUTs using our systematic procedure with three real-world applications. As we are not developers of these real-world applications, we generalize conventional unit tests of these applications as third-party developers using our systematic procedure. Our results show that test generalization increases the coverage of the code under test and also detects new defects that are not found by existing legacy unit tests. Our results also show that test generalization results in better test-code maintenance by reducing number of tests to be maintained. %We expect the benefits of PUTs can be much more if the developers of these applications perform the test generalization, since the developers can incorporate their domain knowledge into PUTs during test generalization. Along with the benefits, our empirical study also highlights some of the potential difficulties that can be encountered during test generalization.

In summary, the paper makes the following major contributions:

\begin{itemize}
	\item A systematic procedure for assisting developers in generalizing existing legacy unit tests into PUTs to leverage the benefits of PUTs.
	\item A first-of-a-kind empirical study that investigates the benefits of PUTs over conventional unit tests. In our empirical study, we show that testing with PUTs increased branch coverage by $0$\% over conventional unit tests and detects $0$ new defects. We also show that test generalization reduces the amount of test code, thereby, helping in better test-code maintenance. The detailed results of our empirical study are available at \url{http://ase.csc.ncsu.edu/projects/putstudy/}.	
	\item Empirical results that show the benefits of supporting techniques during test generalization. 
	\item Empirical results that show the utility of test patterns in test generalization.
	%\item Empirical evidences highlighting the potential difficulties during test generalization.
\end{itemize}

The rest of the paper is structured as follows. 
Section~\ref{sec:procedure} presents our systematic procedure designed based on our experience with the NUnit framework.
Section~\ref{sec:categorization} presents the categories of test patterns used in writing the PUTs. 
Section~\ref{sec:helper} describes how the supporting techniques are used in our test generalization. 
Section~\ref{sec:newbenefits} presents the benefits of test generalization found in our study. 
Section~\ref{sec:notamenable} describes the categories of conventional unit tests that are not amenable for test generalization.
Section~\ref{sec:limitations} discusses the limitations of PUTs. Section~\ref{sec:related} discusses the related work. Section~\ref{sec:tov} discusses the threats to validity. Finally, Section~\ref{sec:conclusion} concludes.