\section{Introduction}
\label{sec:intro}

In software development life cycle, unit testing is a key phase that helps detect defects at an early stage. In practice, it is essential to write high-covering tests during unit testing to ensure high quality of the software under development. Conventionally, unit tests do not accept any parameters and include three major parts: test scenario, test data and test oracles. Test scenario refers to sequence of method calls invoked by the unit test. Test data refers to concrete values passed as arguments for the method calls. Test oracles refer to assertions that verify whether the actual behavior is the same as the expected behavior. 

Parameterized Unit Tests (PUTs)~\cite{tillmann05:parameterized} are a new advancement in the field of software testing. Unlike conventional unit tests, these PUTs accept parameters. The major advantage of PUTs compared to conventional unit tests is that developers do not have to provide test data in PUT. An approach, called Dynamic Symbolic Execution (DSE)~\cite{king:symex, godefroid05:dart, sen07:cute}, can used to automatically generate conventional unit tests that achieve a high coverage of code under test. Initially, DSE explores the code under test with random values and collects constraints along the path executed in the code under test. DSE next systematically flips collected constraints and uses a constraint solver to generate concrete values that guide program execution through alternate paths. In our empirical study, we use Pex~\cite{tillmann08:pex, pex:rel} as an example state-of-the-art DSE based approach. Pex generates a conventional unit test for each set of concrete values that explores a new path in the code under test. The reason for using Pex in our empirical study is its popularity indicated by the recent public releases, which recorded thousands of download counts~\cite{pex:rel}. Pex was previously used internally at Microsoft to test core components of the .NET framework and found serious defects~\cite{tillmann08:pex}.

Although PUTs are more beneficial than conventional unit tests, PUTs are not widely adopted by the software industry. One major reason could be writing PUTs is a challenging task. On the other hand, many companies still use conventional unit tests as a primary means for ensuring the quality of their developed software. These legacy conventional unit tests can be transformed into PUTs to leverage the benefits of PUTs. This process of transforming conventional unit tests into PUTs, referred to as \emph{test generalization}, has three major benefits. First, conventional unit tests that achieve a high coverage of the code under test can be automatically generated from PUTs. Therefore, through test generalization, new conventional unit tests can be generated that cover additional paths (in the code under test), which are not covered by the legacy unit tests. Second, test generalization increases the fault detection capabilities of legacy unit tests. Third, test generalization helps reduce the efforts required for test code maintenance since a single PUT can represent multiple conventional unit tests. Based on our experience with PUTs, we identify that it is a non-trivial task to generalize conventional unit tests into PUTs. To address this issue, we propose a systematic procedure for generalizing legacy conventional unit tests into PUTs. To the best of our knowledge, ours is the first empirical study that proposes a systematic procedure for generalizing conventional unit tests into PUTs and also shows the benefits of test generalization.

The main objective of our systematic procedure is to take existing conventional unit tests and write PUTs to test the same or generalized behaviors as the ones tested by  conventional unit tests. To generalize a conventional unit test to a PUT, we first identify elements in the conventional unit test (such as arguments or the receiver object of the method under test) and promote these elements as PUT parameters. We also propose several test patterns~\cite{halleux08:putpatterns} and use various supporting techniques to further ease the process of test generalization. During test generalization, there are two major challenges with respect to handling parameters of PUTs: (1) generating legal input values for primitive argument types and (2) generating desirable object states for non-primitive argument types. These desirable object states are the states that help explore paths in the code under test by covering \CodeIn{true} or \CodeIn{false} branches. To address the first issue and to assist Pex or any other DSE-based tool in generating legal input values,  sufficient number of assumptions need to be specified in the PUT. For example, consider that a method under test is accepting an integer argument and includes a precondition that the argument should be greater than 1000. We add assumptions to PUTs to ensure that legal input values for primitive types are generated in conventional unit tests. To address the second issue of generating desirable object states for non-primitive argument types, we write method-call sequences that create and mutate instances of non-primitive object types. TODO: Write about mock objects here somewhere.

We show the benefits of generalizing conventional unit tests into PUTs using our systematic procedure with three real-world applications. As we are not developers of these real-world applications, we generalize conventional unit tests of these applications as third-party developers using our systematic procedure. Our results show that test generalization increases the coverage of the code under test and also detects new defects that are not found by existing legacy unit tests. Our results also show that the test generalization results in a better test-code maintenance by reducing number of tests to be maintained. We expect the benefits of PUTs can be much more if the developers of these applications perform the test generalization, since the developers can incorporate their domain knowledge into PUTs during test generalization. Along with the benefits, our empirical study also highlights some of the potential difficulties that can be encountered during test generalization.

This paper makes the following contributions:

\begin{itemize}
	\item A systematic procedure for assisting developers in generalizing existing legacy unit tests into PUTs to leverage the benefits of PUTs.
	\item A first-of-a-kind empirical study that investigates the benefits of PUTs over conventional unit tests. In our empirical study, we show that testing with PUTs increased branch coverage by $0$\% over conventional unit tests and detects $0$ new defects. We also show evidence that test generalization reduces the amount of test code, thereby, helping in better test-code maintenance. The detailed results of our empirical study are available at \url{http://ase.csc.ncsu.edu/projects/putstudy/}.	
	\item Empirical results that show the benefits of supporting techniques during test generalization. 
	\item Empirical results that show the utility of test patterns in test generalization.
	\item Empirical evidences highlighting the potential difficulties during test generalization.
\end{itemize}

The rest of the paper is structured as follows. 
Section~\ref{sec:procedure} presents our systematic procedure designed based on our experience with the NUnit framework. 
Section~\ref{sec:example} presents an example from the NUnit framework and explains the procedure for test generalization.  
Section~\ref{sec:categorization} presents the categories of test patterns used in writing the PUTs. 
Section~\ref{sec:helper} describes how the supporting techniques are used in our test generalization. 
Section~\ref{sec:newbenefits} presents the benefits of test generalization found in our study. 
Section~\ref{sec:notamenable} describes the categories of conventional unit tests that are not amenable for test generalization.
Section~\ref{sec:limitations} discusses the limitations of PUTs. Section~\ref{sec:related} discusses the related work. Section~\ref{sec:tov} discusses the threats to validity. Finally, Section~\ref{sec:conclusion} concludes.