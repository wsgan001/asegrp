\section{Introduction}
\label{sec:intro}

In software development life cycle, unit testing is a key phase that helps detect defects at an early stage. In practice, it is essential to write high-covering tests during unit testing to ensure high quality of the software under development. Conventionally, a unit test does not accept any parameters and includes three major parts: test scenario, test data, and test oracle. Test scenario refers to a sequence of method calls invoked by the unit test. Test data refers to concrete values passed as arguments for the method calls. Test oracle refers to an assertion statement that verifies whether the actual behavior is the same as the expected behavior. 

Parameterized Unit Tests (PUTs)~\cite{tillmann05:parameterized} are a new advancement in the field of software testing. Unlike Conventional Unit Tests (CUT), PUTs accept parameters. The major advantage of PUTs compared to CUTs is that developers do not need to provide test data in PUT, but need to provide only the variables that represent the test data as parameters. The concrete values for these parameters can be generated automatically using the Dynamic Symbolic Execution (DSE)~\cite{king:symex, godefroid05:dart, sen07:cute} approach. Given code under test, DSE explores the code under test with random or default values and collects constraints along the execution path. DSE next systematically flips collected constraints and uses a constraint solver to generate concrete values that guide program execution through alternate paths. Pex~\cite{tillmann08:pex, pex:rel} from Microsoft Research is an example state-of-the-art DSE-based test generation tool that accepts PUTs and uses DSE to generate test data. Pex explores PUTs and generates a CUT (for each set of concrete values) that explores a new path in the PUT and the code under test. PUTs thus provide a generic representation of CUTs and are more powerful since PUTs provide a means for guided test generation when used with an automatic test generation tool such as Pex. 

Although PUTs relieve developers from providing test data in CUTs, PUTs still require test scenarios for exercising the code under test. Writing realistic test scenarios requires the knowledge regarding the behavior of the code under test. On the other hand, most of the existing applications in software industry have CUTs that include valuable information of test scenarios. In practice, CUTs are often used as specifications to understand the behavior of the code under test. Therefore, either developers of existing applications or third-party testers can transform CUTs to PUTs by reusing test scenarios described in those CUTs. We refer to this process of transforming CUTs to PUTs for leveraging the benefits of PUTs as \emph{test generalization}. (TODO: Write about TDD here to increase the value of CUTs in describing test scenarios.)

In practice, test generalization has three major benefits. First, from PUTs, DSE-based approaches can be used to automatically generate CUTs that achieve a high coverage
of the code under test. Therefore, test generalization helps generate new CUTs that cover additional paths (in the code under test), which are not covered by the legacy CUTs. Second, test generalization increases the fault-detection capabilities of the test suite by appending more CUTs to the existing CUTs. Third, test generalization helps reduce the efforts required in maintenance of test code since a single PUT can represent multiple CUTs. 

Given the benefits of test generalization, in this paper, we propose a systematic procedure for assisting developers in generalizing CUTs to PUTs. To the best of our knowledge, ours is the first empirical study that proposes a systematic procedure for generalizing CUTs to PUTs and also shows an empirical evidence of the benefits of test generalization. The main objective of our systematic procedure is to take existing CUTs and transform them to PUTs to test the same or generalized behaviors as the ones tested by CUTs. 
Our systematic procedure describes challenges that are faced during test generalization and proposes solutions of how developers can address those challenges. These challenges can be classified into two categories: challenges specific to our test generalization and challenges specific to the existing state-of-the-art DSE-based approaches in generating CUTs from PUTs. 

An example challenge faced during test generalization is that Pex or any other DSE-based approach requires guidance in generating legal values for the parameters of PUTs. Without these legal values, the detected defects turn out to be false positives. These legal values are the values that satisfy preconditions of the code under test and help setting up test scenarios to pass test assertions. For example, consider a method under test that accepts an integer parameter and includes a precondition that the parameter should be greater than $1000$. Pex requires guidance to generate a legal value greater than $1000$ for satisfying the precondition of the method under test. To address this issue, in our systematic procedure, we suggest developers how to add necessary assumptions to PUTs in guiding Pex to generate legal values. Another example challenge during  is developers may face difficulties while generalizing test oracles in CUTs. We propose several test patterns~\cite{halleux08:putpatterns} that help developers in addressing the challenges faced during generalization of test oracles.

Our systematic procedure also describes alternative solutions for addressing the second category of challenges specific to the existing state-of-the-art DSE-based approaches in generating CUTs from PUTs. 

To generalize a CUT, we first identify elements in the CUT (such as arguments or the receiver object of the method under test) and promote these elements as PUT parameters. We then generalize the existing test oracles to fit into the PUT. During test generalization, there are two major challenges with respect to handling parameters of PUTs: (1) generating legal input values for primitive argument types and (2) generating desirable object states for non-primitive argument types. These desirable object states are the states that help explore paths in the code under test by covering \CodeIn{true} or \CodeIn{false} branches. To assist Pex or any other DSE-based tool to generate legal input values, we need to provide a sufficient number of assumptions on the parameters of PUTs. For example, consider a method under test that accepts an integer argument and includes a precondition that the argument should be greater than $1000$. We add assumptions on the parameters of the PUTs to ensure that legal input values for primitive types are generated by the test generation tool. To address the second issue of generating desirable object states for non-primitive argument types, we write method-call sequences that create and mutate instances of non-primitive object types. Furthermore, there is an intrinsic challenge in generalizing test oracle and it might not be possible to fully generalize test oracles. To deal with these challenges and to ease the process of test generalization, we propose several test patterns~\cite{halleux08:putpatterns} and use various supporting techniques.  Furthermore, when a PUT requires desired states of the environment, external to the application, such as a file needs to exist in the file system for each generated unit test, we use mock objects to isolate the execution of the generated unit tests from the environment. 

We show the benefits of generalizing CUTs into PUTs using our systematic procedure with three real-world applications. As we are not developers of these real-world applications, we generalize CUTs of these applications as third-party developers using our systematic procedure. Our results show that test generalization increases the coverage of the code under test and also detects new defects that are not found by existing legacy unit tests. Our results also show that test generalization results in better test-code maintenance by reducing number of tests to be maintained. 

In summary, the paper makes the following major contributions:

\begin{itemize}
	\item A systematic procedure for assisting developers in generalizing existing legacy unit tests into PUTs to leverage the benefits of PUTs.
	\item A first-of-a-kind empirical study that investigates the benefits of PUTs over CUTs. In our empirical study, we show that testing with PUTs increased branch coverage by $0$\% over CUTs and detects $0$ new defects. We also show that test generalization reduces the amount of test code, thereby, helping in better test-code maintenance. The detailed results of our empirical study are available at \url{http://ase.csc.ncsu.edu/projects/putstudy/}.	
	\item Empirical results that show the benefits of supporting techniques during test generalization. 
	\item Empirical results that show the utility of test patterns in test generalization.
	%\item Empirical evidences highlighting the potential difficulties during test generalization.
\end{itemize}

The rest of the paper is structured as follows. 
Section~\ref{sec:procedure} presents our systematic procedure designed based on our experience with the NUnit framework.
Section~\ref{sec:categorization} presents the categories of test patterns used in writing the PUTs. 
Section~\ref{sec:helper} describes how the supporting techniques are used in our test generalization. 
Section~\ref{sec:newbenefits} presents the benefits of test generalization found in our study. 
Section~\ref{sec:notamenable} describes the categories of CUTs that are not amenable for test generalization.
Section~\ref{sec:limitations} discusses the limitations of PUTs. Section~\ref{sec:related} discusses the related work. Section~\ref{sec:tov} discusses the threats to validity. Finally, Section~\ref{sec:conclusion} concludes.



%\textcolor{red}{Parameterized Unit Tests (PUTs)~\cite{tillmann05:parameterized} are a new advancement in the field of software testing. Unlike conventional unit tests, PUTs accept parameters. The major advantage of PUTs compared to conventional unit tests is that developers do not have to provide test data in PUT. An approach, called Dynamic Symbolic Execution (DSE)~\cite{king:symex, godefroid05:dart, sen07:cute}, can be used to automatically generate conventional unit tests that achieve a high coverage of code under test. Initially, DSE explores the code under test with random values and collects constraints along the path executed in the code under test. DSE next systematically flips collected constraints and uses a constraint solver to generate concrete values that guide program execution through alternate paths.In our empirical study, we use Pex~\cite{tillmann08:pex, pex:rel} as an example state-of-the-art DSE based approach. Pex generates a conventional unit test for each set of concrete values that explores a new path in the code under test. The reason for using Pex in our empirical study is its popularity indicated by the recent public releases, which recorded thousands of download counts~\cite{pex:rel}. Pex was previously used internally at Microsoft to test core components of the .NET framework and found serious defects~\cite{tillmann08:pex}.}

%The reason for using Pex in our empirical study is its popularity indicated by the recent public releases, which recorded thousands of download counts~\cite{pex:rel}. Pex was previously used internally at Microsoft to test core components of the .NET framework and found serious defects~\cite{tillmann08:pex}.

%We expect the benefits of PUTs can be much more if the developers of these applications perform the test generalization, since the developers can incorporate their domain knowledge into PUTs during test generalization. Along with the benefits, our empirical study also highlights some of the potential difficulties that can be encountered during test generalization.

%Although PUTs, in combination with DSE based tools such as Pex, are more beneficial than CUTs, PUTs are not widely adopted by the software industry. One major reason for such a low application of PUTs in practice could be that writing PUTs is a challenging task. On the other hand, most of the software industry uses CUTs as a primary means for ensuring the quality of their developed software. To leverage the benefits of PUTs and to alleviate the complexity in writing PUTs, we propose to transform the legacy CUTs into PUTs. This process of transforming CUTs into PUTs, referred to as \emph{test generalization}, has three major advantages. 

%Furthermore, there is an intrinsic challenge in generalizing test oracle and it might not be possible to fully generalize test oracles. To deal with these challenges and to ease the process of test generalization, we propose several test patterns~\cite{halleux08:putpatterns} and use various supporting techniques.