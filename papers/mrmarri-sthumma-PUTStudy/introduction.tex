\section{Introduction}
\label{sec:intro}

In software development life cycle, unit testing is a key phase that helps detect defects at an early stage. In practice, it is essential to write high-covering tests during unit testing to ensure high quality of the software under development. Conventionally, a unit test does not accept any parameters and includes three major parts: test scenario, test data, and test oracle. Test scenario refers to a sequence of method calls invoked by the unit test. Test data refers to concrete values passed as arguments for the method calls. Test oracle refers to an assertion statement that verifies whether the actual behavior is the same as the expected behavior. 

Parameterized Unit Tests (PUTs)~\cite{tillmann05:parameterized} are a new advancement in the field of software testing. Unlike Conventional Unit Tests (CUT), PUTs accept parameters. The major advantage of PUTs compared to CUTs is that developers do not need to provide test data in PUT, but need to provide only the variables that represent the test data as parameters. The concrete values for these parameters can be generated automatically using the Dynamic Symbolic Execution (DSE)~\cite{king:symex, godefroid05:dart, sen07:cute} approach. Given code under test, DSE explores the code under test with random or default values and collects constraints along the execution path. DSE next systematically flips collected constraints and uses a constraint solver to generate concrete values that guide program execution through alternate paths. Pex~\cite{tillmann08:pex, pex:rel} from Microsoft Research is an example state-of-the-art DSE-based test generation tool that accepts PUTs and uses DSE to generate test data. Pex explores PUTs and generates a CUT (for each set of concrete values) that explores a new path in the PUT and the code under test. PUTs thus provide a generic representation of CUTs and are more powerful since PUTs provide a means for guided test generation when used with an automatic test generation tool such as Pex. 

Although it is known that PUTs are powerful, it is quite challenging to write PUTs for existing legacy applications. Despite the fact that PUTs relieve developers from providing test data in CUTs, PUTs still require test scenarios for exercising the code under test. Writing realistic test scenarios requires the knowledge regarding the behavior of the code under test. On the other hand, most of the existing applications in software industry have CUTs that include valuable information of test scenarios. In practice, CUTs are often used as specifications to understand the behavior of the code under test. Therefore, either developers of existing applications or third-party testers can transform these CUTs to PUTs by reusing test scenarios described in those CUTs. We refer to this process of transforming CUTs to PUTs for leveraging the benefits of PUTs as \emph{test generalization}. %(TODO: Write about TDD here to increase the value of CUTs in describing test scenarios.)

In practice, test generalization has three major benefits. First, from PUTs, DSE-based approaches can be used to automatically generate CUTs that achieve a high coverage
of the code under test. Therefore, test generalization helps generate new CUTs that cover additional paths (in the code under test), which are not covered by the legacy CUTs. Second, test generalization increases the fault-detection capabilities of the test suite by appending more CUTs to the existing CUTs. Third, test generalization helps reduce the efforts required in maintenance of test code since a single PUT can represent multiple CUTs. 

Given the benefits of test generalization, in this paper, we propose a systematic procedure for assisting developers in generalizing CUTs to PUTs. To the best of our knowledge, ours is the first empirical study that proposes a systematic procedure for generalizing CUTs to PUTs and also shows an empirical evidence of the benefits of test generalization. The main objective of our systematic procedure is to take existing CUTs and transform them to PUTs to test the same or generalized behaviors as the ones tested by the existing CUTs. Our systematic procedure describes challenges that are faced during test generalization and proposes solutions of how developers can address those challenges. These challenges can be classified into two categories: challenges specific to our test generalization and challenges in general for the existing state-of-the-art DSE-based approaches in generating CUTs from PUTs. 

An example challenge faced during our test generalization (first category) is that Pex or any other DSE-based approach requires guidance in generating legal values for the parameters of PUTs. Without these legal values, the detected defects turn out to be false positives. These legal values are the values that satisfy preconditions of the code under test and help setting up test scenarios to pass test assertions. For example, consider a method under test that accepts an integer parameter and includes a precondition that the parameter should be greater than $1000$. Pex requires guidance to generate a legal value greater than $1000$ for satisfying the precondition of the method under test. To address this issue, in our systematic procedure, we suggest developers how to add necessary assumptions to PUTs in guiding Pex to generate legal values. Another example challenge during test generalization is developers may face difficulties while generalizing test oracles in CUTs. We propose several test patterns~\cite{halleux08:putpatterns} that help developers in addressing the challenges faced during generalization of test oracles.

Our systematic procedure also presents alternative solutions for addressing the second category of challenges, which are generally faced by the existing state-of-the-art DSE-based approaches in generating CUTs from PUTs~\cite{thummalapenta09:mseqgen}. For example, Pex faces challenges in generating method-call sequences for achieving desirable object states of non-primitive parameters of PUTs. These desirable object states are the states that help explore paths in the code under test by covering \CodeIn{true} or \CodeIn{false} branches. Another example challenge is related to PUTs that require desired states of the environment, external to the application, such as a file needs to exist in the file system for each generated CUT. In our systematic procedure, we suggest developers of how to assist Pex in addressing these challenges.

We show the benefits of generalizing CUTs to PUTs using our systematic procedure with three open source applications that are widely used in the software industry (as shown by their number of downloads). As we are not developers of these applications, we generalize CUTs of these applications as third-party testers using our systematic procedure. Our results show that test generalization reduces $407$ CUTs to $224$ PUTs (45\%), showing the significance of test generalization in reducing the efforts of maintaining test code. Test generalization also detected $16$ new defects that are not detected by existing CUTs of the applications. A few of these defects are quite complex and are hard to be detected using the existing CUTs. 

%In practice, many developers use CUTs as a primary means for ensuring the quality of their developed software. Given the benefits of test generalization, we expect that these developers can use our systematic procedure and generalize their CUTs to PUTs to leverage the benefits of PUTs, and thereby increase the quality of their developed software.

In summary, the paper makes the following major contributions:
\begin{itemize}
	\item A systematic procedure for assisting developers in generalizing existing legacy unit tests to PUTs to leverage the benefits of PUTs.
	\item The first empirical study that investigates the benefits of test generalization. In our empirical study, we show that test generalization increases branch coverage by 4\% (with a maximum increase of 53\% for one class under test and 10\% for one application under analysis) on an average for all three applications used in our empirical study. We show that test generalization detects $16$ new defects that are not detected by existing CUTs. We also show that test generalization reduces the number of unit tests by 45\% ($407$ CUTs are transformed to $224$ PUTs), thereby reducing the efforts required in maintaining the test code. The detailed results of our empirical study are available at \url{https://sites.google.com/site/asergrp/projects/putstudy}.	
	%\item Empirical results that show the benefits of supporting techniques during test generalization. 
	\item Supporting techniques and PUT patterns that can assist developers in writing PUTs.
	%\item Empirical evidences highlighting the potential difficulties during test generalization.
\end{itemize}

The rest of the paper is structured as follows. 
Section~\ref{sec:background} presents background information about Pex. Section~\ref{sec:procedure} presents our systematic procedure.  
Section~\ref{sec:helper} describes how the PUT patterns and supporting techniques can assist developers in writing PUTs. 
Section~\ref{sec:study} presents the results of our empirical study. Section~\ref{sec:limitations} discusses the limitations of PUTs. Section~\ref{sec:related} discusses the related work. Section~\ref{sec:tov} discusses the threats to validity. Finally, Section~\ref{sec:conclusion} concludes.

%\textcolor{red}{Parameterized Unit Tests (PUTs)~\cite{tillmann05:parameterized} are a new advancement in the field of software testing. Unlike conventional unit tests, PUTs accept parameters. The major advantage of PUTs compared to conventional unit tests is that developers do not have to provide test data in PUT. An approach, called Dynamic Symbolic Execution (DSE)~\cite{king:symex, godefroid05:dart, sen07:cute}, can be used to automatically generate conventional unit tests that achieve a high coverage of code under test. Initially, DSE explores the code under test with random values and collects constraints along the path executed in the code under test. DSE next systematically flips collected constraints and uses a constraint solver to generate concrete values that guide program execution through alternate paths.In our empirical study, we use Pex~\cite{tillmann08:pex, pex:rel} as an example state-of-the-art DSE based approach. Pex generates a conventional unit test for each set of concrete values that explores a new path in the code under test. The reason for using Pex in our empirical study is its popularity indicated by the recent public releases, which recorded thousands of download counts~\cite{pex:rel}. Pex was previously used internally at Microsoft to test core components of the .NET framework and found serious defects~\cite{tillmann08:pex}.}

%The reason for using Pex in our empirical study is its popularity indicated by the recent public releases, which recorded thousands of download counts~\cite{pex:rel}. Pex was previously used internally at Microsoft to test core components of the .NET framework and found serious defects~\cite{tillmann08:pex}.

%We expect the benefits of PUTs can be much more if the developers of these applications perform the test generalization, since the developers can incorporate their domain knowledge into PUTs during test generalization. Along with the benefits, our empirical study also highlights some of the potential difficulties that can be encountered during test generalization.

%Although PUTs, in combination with DSE based tools such as Pex, are more beneficial than CUTs, PUTs are not widely adopted by the software industry. One major reason for such a low application of PUTs in practice could be that writing PUTs is a challenging task. On the other hand, most of the software industry uses CUTs as a primary means for ensuring the quality of their developed software. To leverage the benefits of PUTs and to alleviate the complexity in writing PUTs, we propose to transform the legacy CUTs into PUTs. This process of transforming CUTs into PUTs, referred to as \emph{test generalization}, has three major advantages. 

%Furthermore, there is an intrinsic challenge in generalizing test oracle and it might not be possible to fully generalize test oracles. To deal with these challenges and to ease the process of test generalization, we propose several test patterns~\cite{halleux08:putpatterns} and use various supporting techniques.

%To generalize a CUT, we first identify elements in the CUT (such as arguments or the receiver object of the method under test) and promote these elements as PUT parameters. We then generalize the existing test oracles to fit into the PUT. During test generalization, there are two major challenges with respect to handling parameters of PUTs: (1) generating legal input values for primitive argument types and (2) generating desirable object states for non-primitive argument types. These desirable object states are the states that help explore paths in the code under test by covering \CodeIn{true} or \CodeIn{false} branches. To assist Pex or any other DSE-based tool to generate legal input values, we need to provide a sufficient number of assumptions on the parameters of PUTs. For example, consider a method under test that accepts an integer argument and includes a precondition that the argument should be greater than $1000$. We add assumptions on the parameters of the PUTs to ensure that legal input values for primitive types are generated by the test generation tool. To address the second issue of generating desirable object states for non-primitive argument types, we write method-call sequences that create and mutate instances of non-primitive object types. Furthermore, there is an intrinsic challenge in generalizing test oracle and it might not be possible to fully generalize test oracles. To deal with these challenges and to ease the process of test generalization, we propose several test patterns~\cite{halleux08:putpatterns} and use various supporting techniques.  Furthermore, when a PUT requires desired states of the environment, external to the application, such as a file needs to exist in the file system for each generated unit test, we use mock objects to isolate the execution of the generated unit tests from the environment. 
