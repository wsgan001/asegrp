\section{Related Work}
\label{sec:related}
\vspace*{2ex}
Pex~\cite{tillmann08:pex, tillmann05:parameterized, tillmann06:unit} accepts PUTs and uses symbolic execution to generate test inputs. Similarly, other existing tools such as Parasoft Jtest~\cite{jtest} and CodeProAnalytiX~\cite{codepro} adopt the design-by-contract approach~\cite{dbc} and allow developers to specify method preconditions, postconditions, and class invariants for the unit under test and carry out symbolic execution or random testing to generate test inputs. More recently, Saff et al.~\cite{ernst:theory} propose theory-based testing and generalize six Java applications to show that the proposed theory-based testing is more effective compared to traditional example-based testing. A theory is a partial specification of a program behavior and is a generic form of test methods where assertions should hold for all inputs that satisfy the assumptions specified in the test methods. A theory is similar to a PUT and Saff et al.'s approach uses these defined theories and applies the constraint solving mechanism based on path coverage to generate test inputs similar to Pex. In contrast to our study, their study does not provide the systematic procedure of writing generalized PUTs or show empirical evidence of benefits of PUTs that are shown in our study. 

There are existing approaches~\cite{pacheco:feedback, csallner:jcrasher, khurshid:symbolic} that can automatically generate required method-call sequences that achieve different object states. However, in practice, each approach has its own limitations. For example, Pacheco et al.'s approach~\cite{pacheco:feedback} generates method-call sequences randomly by incorporating feedback from already generated method-call sequences. However, such a random approach can still face challenges in generating desirable method-call sequences, as often there is little chance of generating required sequences at random. In our test generalization, we manually write factory methods to assist Pex in generating desirable object states for non-primitive data types.

In our previous work~\cite{marri09:empirical}, we presented an empirical study to analyze the use of parameterized model in unit testing with PUTs. We showed that using a mock object can ease the process of unit testing and identified challenges faced in testing code when there are multiple APIs that need to be mocked. In our current study, we also use mock objects in our testing with PUTs. However, our previous study showed the benefits of mock objects in unit testing, while our current study shows the use of mock objects to help achieve test generalization. In another of our previous work around PUTs~\cite{xie09:mutation}, we propose mutation analysis to help developers in identifying likely locations in PUTs that can be improved to make more general PUTs. In contrast, our current study suggests a systematic procedure of retrofitting conventional unit tests for parameterized unit testing.