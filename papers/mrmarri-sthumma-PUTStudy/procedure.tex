\section{Systematic Procedure}
\label{sec:procedure}

In this section, we present how a developer can generalize existing CUTs to PUTs by using our systematic procedure. We use illustrative examples from the NUnit framework~\cite{nunit} for explaining our procedure. Our procedure includes four major steps. First, the developer promotes concrete values and other local variables in the CUT as parameters for PUTs (S1). Second, the developer identifies the test pattern for the PUT that best matches the existing CUT to be generalized (S2). Identification of test pattern helps the developer in generalizing test oracles. Third, the developer adds necessary assumptions to PUTs to guide Pex in generating only legal values for the parameters of PUTs (S3). Fourth, the developer uses supporting techniques to assist Pex while generating unit tests from PUTs (S4). We first present a method under test and a CUT from the NUnit framework and next explain each step in detail.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
00:public class SettingsGroup \{
01:\hspace*{0.1in}MemorySettingsStorage storage; ...
02:\hspace*{0.1in}public SettingsGroup(MemorySettingsStorage storage) \{
03:\hspace*{0.2in}this.storage = storage;
04:\hspace*{0.1in}\}
05:\hspace*{0.1in}public void \textbf{SaveSetting}(string sn, object sv) \{
06:\hspace*{0.2in}object ov = storage.GetSetting( sn );
07:\hspace*{0.2in}//Avoid change if there is no real change
08:\hspace*{0.2in}if (ov != null ) \{
09:\hspace*{0.3in}if (ov is string && sv is string && 
\hspace*{1.0in}(string)ov == (string)sv ||
10:\hspace*{0.4in}ov is int && sv is int && (int)ov == (int)sv ||
11:\hspace*{0.4in}ov is bool && sv is bool && (bool)ov == (bool)sv ||
12:\hspace*{0.4in}ov is Enum && sv is Enum && ov.Equals(sv))
13:\hspace*{0.5in}return;
14:\hspace*{0.2in}\}
15:\hspace*{0.2in}storage.SaveSetting(sn, sv);
16:\hspace*{0.2in}if (Changed != null)
17:\hspace*{0.3in}Changed(this, new SettingsEventArgs(sn));
18:\hspace*{0.1in}\}
19:\}
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\Caption{\label{fig:cut} The \CodeIn{SettingsGroup} class of the NUnit framework with the \CodeIn{SaveSetting} method under test.}
\begin{CodeOut}
\begin{alltt}
00://testGroup is of type SettingsGroup
01:[Test]
02:public void TestSettingsGroup() \{
03:\hspace*{0.1in}testGroup.SaveSetting("X", 5);
04:\hspace*{0.1in}testGroup.SaveSetting("NAME", "Charlie");
05:\hspace*{0.1in}Assert.AreEqual(5, testGroup.GetSetting("X"));
06:\hspace*{0.1in}Assert.AreEqual("Charlie", testGroup.GetSetting("NAME"));
07:\}
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\Caption{\label{fig:connuit} A CUT to test the \CodeIn{SaveSetting} method (shown in Figure~\ref{fig:cut})}\vspace*{-2ex}
\end{figure}

%----------------------------------------------------------------------------------------------------------
\subsection{Method Under Test and CUT}

Figure~\ref{fig:cut} shows a method under test \CodeIn{SaveSetting} from the \CodeIn{SettingsGroup} class of the NUnit framework. The \CodeIn{SaveSetting} method accepts a setting name \CodeIn{sn} and a setting value \CodeIn{sv}, and stores the setting in a storage (represented by the member variable \CodeIn{storage}). The setting value can be of type \CodeIn{int}, \CodeIn{bool}, \CodeIn{string}, or \CodeIn{enum}. Before storing the value, \CodeIn{SaveSetting} checks whether the same value already exists for that setting in the storage. If the same value already exists for that setting, \CodeIn{SaveSetting} returns without making any changes to the storage.

Figure~\ref{fig:connuit} shows a CUT for testing the \CodeIn{SaveSetting} method. The CUT saves two setting values (of types \CodeIn{int} and \CodeIn{string}) and verifies whether the values are set properly using the \CodeIn{GetSetting} method. The CUT verifies the expected behavior of the \CodeIn{SaveSetting} method only for the setting values of types \CodeIn{int} and \CodeIn{string}. This CUT is the only test for verifying \CodeIn{SaveSetting} and includes two major issues. First, the CUT does not verify the behavior for the types \CodeIn{bool} and \CodeIn{enum}. Second, the CUT does not cover the \CodeIn{true} branch in Statement 8 of Figure~\ref{fig:cut}. The reason is that the CUT does not invoke the \CodeIn{SaveSetting} method more than once with the same setting name. This CUT achieves $10$\% branch coverage of the \CodeIn{SaveSetting} method. We next explain how the developer can generalize CUT to a PUT and address these two major issues.

%------------------------------------------------------------------------------
\subsection{S1: Concrete values and Local Variables}

To generalize this CUT, the developer first identifies concrete values and local variables in the CUT and promotes them as parameters. For example, the unit test includes a \CodeIn{string} ``\CodeIn{Charlie}'' in Statement 4. The developer replaces this concrete value with a symbolic value by promoting the value as a parameter for the PUT. The advantage of replacing concrete values with symbolic values is that Pex can generate concrete values based on the constraints encountered in different paths of the code under test. Here, the developer can promote the \CodeIn{string} ``\CodeIn{Charlie}'' and the \CodeIn{int} \CodeIn{5} as a single parameter of type \CodeIn{object} for the PUT since \CodeIn{SaveSetting} accepts the parameter of type \CodeIn{object}. Pex automatically identifies the possible types for the \CodeIn{object} type such as \CodeIn{int} or \CodeIn{bool} from the code under test and generates concrete values for those types. This example shows that a single PUT can achieve the same test effectiveness as multiple CUTs with different concrete values. In addition to promoting concrete values as parameters of PUTs, the developer promotes other local variables such as the receiver object (\CodeIn{testGroup}) of \CodeIn{SaveSetting} as parameters. Promoting such receiver objects as parameters can help generate different object states (for those receiver objects) that can help cover additional paths in the code under test. Figure~\ref{fig:putskel} shows the PUT generalized from the CUT shown in Figure~\ref{fig:connuit}.
%For example, consider that there is a defect in the \CodeIn{SaveSetting} method that can be exposed when there are five elements in the storage. Promoting the receiver object of \CodeIn{SaveSetting} as a parameter can help generate such desirable object states and expose those related defects. 
%However, it is quite challenging to automatically generate method-call sequences that can create and mutate instances of non-primitive parameters~\cite{}\textcolor{red}{to cite Suresh's FSE paper}. We address this issue by using a feature called \emph{factory} methods in Pex. Section~\ref{sec:supporting} provides more details on how we use factory methods.
%--------------------------------------------------------------------------------
\subsection{S2: PUT Patterns and Test Oracles}

The developer next analyzes the CUT to identify a pattern~\cite{halleux08:putpatterns} for the PUT that best match the existing CUT. Identifying PUT patterns can help in generalization of the CUT since these patterns can serve as guidelines for designing the PUT and for adding test oracles. In our CUT, a setting is stored in the storage using \CodeIn{SaveSetting} and is verified using \CodeIn{GetSetting}. An analysis of the CUT suggests that the PUT can apply the round-trip pattern, which applies to classes such as \CodeIn{SettingsGroup} that has a method (such as \CodeIn{SaveSetting}) and an inverse method (such as \CodeIn{GetSetting}). Based on the identified pattern, the developer can find that the test oracle can include the \CodeIn{GetSetting} method to assert the behavior of the \CodeIn{SaveSetting} method under test. Section~\ref{sec:helper} presents more details on the use of PUT patterns during test generalization. In our empirical study, we identify that these patterns cover a broad range of CUTs and assist during test generalization.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
//PAUT: PexAssumeUnderTest
00:[PexMethod]
01:public void TestSettingsGroupPUT([PAUT] SettingsGroup st, 
02:\hspace*{0.1in}[PAUT] string sn, [PAUT] object sv) \{
03:\hspace*{0.2in}st.SaveSetting(sn, sv);
04:\hspace*{0.2in}PexAssert.AreEqual(sv, st.GetSetting(sn));
05:\}
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\Caption{\label{fig:putskel} A PUT for the CUT shown in Figure~\ref{fig:connuit}.}

\begin{CodeOut}
\begin{alltt}
//MSS: MemorySettingsStorage (class)
//PAUT: PexAssumeUnderTest	(Pex attribute)
00:[PexFactoryMethod(typeof(MSS))]
01:public static MSS Create([PAUT]string[] 
02:\hspace*{0.3in}sn, [PAUT]object[] sv) \{
03:\hspace*{0.2in}PexAssume.IsTrue(sn.Length == sv.Length);
04:\hspace*{0.2in}PexAssume.IsTrue(sn.Length > 0);
05:\hspace*{0.2in}MSS mss = new MSS();
06:\hspace*{0.2in}for (int count = 0; count < sn.Length; count++) \{
07:\hspace*{0.3in}mss.SaveSetting(sn[count], sv[count]);
08:\hspace*{0.2in}\}
09:\hspace*{0.2in}return mss;
10:\}
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\Caption{\label{fig:factorymethd} An example factory method for the type \CodeIn{MemorySettingsStorage}.} \vspace*{-1ex}
\end{figure}

%--------------------------------------------------------------------------------
\subsection{S3: Assumptions}

A challenge faced during test generalization is that Pex requires guidance in generating only legal values for the parameters of PUTs. These legal values are the values that satisfy preconditions of the code under test and help setting up test scenarios to pass test assertions. For example, without any assumptions, Pex by default generates \CodeIn{null} values for non-primitive parameters such as \CodeIn{st} of the PUT. To guide Pex in generating legal values, the developer can add sufficient assumptions to PUTs. For example, in our PUT, the developer annotates each parameter with the tag \CodeIn{PexAssumeUnderTest}\footnote{\CodeIn{PexAssumeUnderTest} is a custom attribute provided by Pex.}, which describes that the parameter should not be \CodeIn{null} and the type of generated object should be the same as the specified type. The developer can add further assumptions such as Statements 3 and 4 to PUTs based on the behavior verified by the CUT.

%--------------------------------------------------------------------------------
\subsection{S4: Supporting Techniques}

In general, Pex (or any other existing DSE-based approaches) faces challenges in generating CUTs from PUTs that include parameters of non-primitive types or require interactions with the environment. To address these challenges, the developer needs to provide assistance to Pex. To assist Pex in addressing the first challenge related to non-primitive types, developers can write factory methods that produce instances of non-primitive types such as \CodeIn{st} in the PUT. Figure~\ref{fig:factorymethd} shows an example factory method for the \CodeIn{MemorySettingsStorage} class. To address the second challenge related to the interactions with the environment, developers can write mock objects. These mock objects help test features in isolation especially when the test interacts with environments such as file system. Section~\ref{sec:helper} provides more details on how to use these two supporting techniques: factory methods and mock objects.

%-------------------------------------------------------------------------------
\subsection{Transformed PUT}

Figure~\ref{fig:putskel} shows the PUT after applying Steps 1 to 4 on the CUT. Our PUT accepts three parameters: an instance of \CodeIn{SettingsGroup}, name of the setting, and its value. The \CodeIn{SaveSetting} method can be used to save either an \CodeIn{int} value or a \CodeIn{string} value (the method accepts both types for its arguments). Therefore, the CUT requires two method calls shown in Statements $3$ and $4$ of Figure~\ref{fig:connuit} to verify whether \CodeIn{SaveSetting} correctly handles these types. On the other hand, only one method call is sufficient in the PUT as the variable is promoted to a PUT parameter of type \CodeIn{object}. Pex automatically explores the code under test and generates tests that cover both \CodeIn{int} and \CodeIn{string} types. Indeed, the \CodeIn{SaveSetting} method also accepts \CodeIn{bool} and \CodeIn{enum} types. The existing CUT did not include tests for verifying these two types. Our generalized PUT automatically handles these additional types, serving as a primary advantage of PUT since it helps reduce the test code significantly without reducing the behavior tested by the CUT.

When we applied Pex on the PUT, Pex generated $8$ CUTs from the PUT. These CUTs verify the \CodeIn{SaveSetting} method with different setting values of types such as \CodeIn{int} or \CodeIn{string} or other non-primitive object types. As described, a single PUT can substitute multiple CUTs, resulting in a reduced test code maintenance. Furthermore, the CUT used for generalization achieved a branch coverage of $10$\%, whereas the CUTs generated from the PUT has achieved a final branch coverage of $90$\%. Although PUT achieved a higher code coverage compared to the CUT, the PUT still could not cover the \CodeIn{true} branch of Statement 16. Developers while doing generalization can verify these not covered portions and can either enhance PUTs or write new PUTs for achieving additional coverage of those not covered portions\footnote{Recall that the objective of our study is to generalize CUTs to PUTs for comparing the benefits of PUTs over existing CUTs. Therefore, we did not write additional PUTs that can achieve better branch coverage.}. 
%To cover this branch, an event handler has to be registered for the variable \CodeIn{Changed}. The reason for not able to cover this branch is that the CUT also do not register the event handler. 
%----------------------------------COMMENTED BY MADHURI --------------------------
%We first present the open source project used in our procedure and next explain each step in detail.

%\setlength{\tabcolsep}{3pt}
%\begin{table}[t]
%\begin{center}
%\centering
%\begin{tabular}{|l|r|}
%\hline
%\textbf{Attribute} & \textbf{Value} \\
%\hline
%\# Total Files & 560\\
%\hline
%\# Files in NUnit.Util & 72\\
%\hline
%Total LOC & 53K\\
%\hline
%NUnit.Util LOC & 7.2K\\
%\hline
%\# Test Files of NUnit.Util & 32\\
%\hline
%\end{tabular}
%\end{center}
%%\end{SmallOut}
%\caption{Characteristics of the NUnit framework and the util package\label{tab:utilmetrics}}
%\end{table}
%--------------------------------------------------------------------------------------------------------
%\textbf{Open Source Project.} We use an open source project, called NUnit~\cite{nunit}, for describing our systematic procedure. NUnit, a counterpart of JUnit for Java~\cite{JUnit}, is a widely used open source unit-testing framework for all .NET languages. NUnit is written in C\# and uses attribute-based programming model~\cite{TDD} through a variety of attributes such as \CodeIn{[TestFixture]} and \CodeIn{[Test]}. The rationale behind choosing NUnit for test generalization is the large number of manually written unit tests available with the project. The source code of the entire project includes 560 files and 53 KLOC. The test code includes 264 source files with 25 KLOC. This significant amount of test code makes this project suitable for our empirical study. For the purpose of the study, we use the util package (\CodeIn{nunit.util.dll}), which is one of the core components of the framework. The util package includes 7.2 KLOC with 72 classes and 326 methods. The number of test files, test methods, and test LOC in the util package are 32, 335, and 3.4 KLOC, respectively. We chose the \CodeIn{util} package in the study for two reasons: (1) it is one of the first modules being developed for the framework (2) it is an independent module and is not dependent on the other modules of the NUnit framework. Table~\ref{tab:utilmetrics} shows the characteristics of NUnit framework and the util package.
%--------------------------------END COMMENTED BY MADHURI------------------------------------------------

%In a few cases, we identify that direct generalization of CUTs might not achieve 100\% block coverage. There could be several reasons such as the portions of 
%the code are not covered by the behavior tested by CUTs. In those cases, we identify the un-covered portions of the code and write new PUTs or modify the transformed PUTs to cover these code portions. Consider a sample code example shown in Figure~\ref{fig:handleexample}. We highlight 
%the un-covered portion of the code in \textbf{bold}. The reason for the un-covered code portion in this code example is that the code portion requires a delegate handler to be defined in the class. A delegate handler can be treated as a pointer to a function. These delegates can be used to encapsulate a method with a specific signature and return type. To achieve 100\% coverage of the \CodeIn{RemoveSetting} method in the preceding code example, we created a trivial delegate handler and set the value to \CodeIn{Changed}.
%We present details on the usage of supporting techniques in our study in Section~\ref{sec:helper}.
%
%\begin{figure}[t]
%\begin{CodeOut}
%\begin{alltt}
%00:[PexMethod]
%//MSS: MemorySettingsStorage (class)
%//PAUT: PexAssumeUnderTest	(Pex attribute)
%//Changed is of type Delegate
%01:public void RemoveSetting(MSS st,
%\hspace*{0.3in}[PAUT]string settingName) \{
%02:\hspace*{0.1in}st.RemoveSetting( settingName );
%03:\hspace*{0.1in}if (Changed != null)
%04:\hspace*{0.2in}\textbf{Changed(this, new SettingsEventArgs(settingName))};
%05:\}
%\end{alltt}
%\end{CodeOut}
%\Caption{\label{fig:handleexample} A code sample with an un-covered portion (shown in bold) with PUTs written by transforming CUTs.}
%\end{figure}

%During test generalization, we identified that another major challenge is to handle parameters of non-primitive types. Pex can effectively handle primitive-type parameters such as \CodeIn{string} or \CodeIn{int}. However, for non-primitive types, method-call sequences are required for generating desirable object states. These desirable object states are the states that help explore paths in the code under test. For example, a desirable object state to cover the \CodeIn{true} branch of Statement 8 in Figure~\ref{fig:cut} is that the storage should already include a value for the setting name. 

%The primary challenge in constructing desirable states for non-primitive arguments is to construct a sequence of method calls that create and mutate objects. However, similar to the other state-of-the-art method-call sequence generation approaches~\cite{}, Pex also faces challenges in generating sequences for non-primitive types such as \CodeIn{st}. To address this issue, we use a feature, called factory methods, to assist Pex in generating effective method-call sequences that can help achieve desirable object states. Figure~\ref{fig:factorymethd} shows an example factory method for the \CodeIn{MemorySettingsStorage} type written manually. We wrote the factory method for \CodeIn{MemorySettingsStorage} as the member variable \CodeIn{storage} is of type \CodeIn{MemorySettingsStorage}. Our factory method accepts two arrays of setting names (\CodeIn{sn}) and values (\CodeIn{sv}) and adds these entries to the storage. This factory method helps Pex to generate method-call sequences that can create desirable object states. For example, Pex can generate five names and five values as arguments to our factory method for creating a desirable object state with five elements in the storage\footnote{Note that the factory methods only provide an assistance to Pex in achieving the desirable object states, and that the desirable object states are defined by assumptions or Pex generates these object states based on the branching conditions in the code under test.}. The same factory can be reused for all other PUTs using the \CodeIn{MemorySettingsStorage} type.

%Along with factory methods, we use another supporting technique called mock objects. These mock objects help test features in isolation especially when the unit test interacts with environments such as file system. Section~\ref{} provides more details on how we use these both factory methods and mock objects.
