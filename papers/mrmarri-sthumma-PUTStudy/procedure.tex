\section{Systematic Procedure}
\label{sec:procedure}

We next present our systematic procedure for generalizing conventional unit tests into PUTs using illustrative examples from the NUnit framework. Our systematic procedure includes four major steps. First, we promote concrete values and other local variables in the conventional unit test as parameters for PUTs. Second, we identify the test pattern for the conventional unit test. Identification of test pattern help ease the process of test generalization. Third, we use supporting techniques such as factory methods and mock objects to assist Pex while exploring PUTs. Fourth, we add necessary assumptions to guide Pex in generating legal values for both primitive and non-primitive types. We first present the open source project used in our procedure and next explain each step in detail.

\setlength{\tabcolsep}{3pt}
\begin{table}[t]
\begin{center}
\centering
\begin{tabular}{|l|r|}
\hline
\textbf{Attribute} & \textbf{Value} \\
\hline
\# Total Files & 560\\
\hline
\# Files in NUnit.Util & 72\\
\hline
Total LOC & 53K\\
\hline
NUnit.Util LOC & 7.2K\\
\hline
\# Test Files of NUnit.Util & 32\\
\hline
\end{tabular}
\end{center}
%\end{SmallOut}
\caption{Characteristics of the NUnit framework and the util package\label{tab:utilmetrics}}
\end{table}
%--------------------------------------------------------------------------------------------------------
\textbf{Open Source Project.} We use an open source project, called NUnit~\cite{nunit}, for describing our systematic procedure. NUnit, a counterpart of JUnit for Java~\cite{JUnit}, is a widely used open source unit-testing framework for all .NET languages. NUnit is written in C\# and uses attribute-based programming model~\cite{TDD} through a variety of attributes such as \CodeIn{[TestFixture]} and \CodeIn{[Test]}. The rationale behind choosing NUnit for test generalization is the large number of manually written unit tests available with the project. The source code of the entire project includes 560 files and 53 KLOC. The test code includes 264 source files with 25 KLOC. This significant amount of test code makes this project suitable for our empirical study. For the purpose of the study, we use the util package (\CodeIn{nunit.util.dll}), which is one of the core components of the framework. The util package includes 7.2 KLOC with 72 classes and 326 methods. The number of test files, test methods, and test LOC in the util package are 32, 335, and 3.4 KLOC, respectively. We chose the \CodeIn{util} package in the study for two reasons: (1) it is one of the first modules being developed for the framework (2) it is an independent module and is not dependent on the other modules of the NUnit framework. Table~\ref{tab:utilmetrics} shows the characteristics of NUnit framework and the util package.

Figure~\ref{fig:cut} shows a method under test \CodeIn{SaveSetting} from the class \CodeIn{SettingsGroup}. The \CodeIn{SaveSetting} method accepts a setting name \CodeIn{sn} and a setting value \CodeIn{sv}, and stores the setting in a storage (represented my member variable \CodeIn{storage}). The setting value can be types \CodeIn{int}, \CodeIn{bool}, \CodeIn{string} or \CodeIn{enum}. Before storing the value, \CodeIn{SaveSetting} checks whether the same value already exists for that setting in the storage. If the same value exists for that setting, \CodeIn{SaveSetting} returns without making any changes to the storage.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
00:public class SettingsGroup \{
01:\hspace*{0.1in}MemorySettingsStorage storage; ...
02:\hspace*{0.1in}public SettingsGroup(MemorySettingsStorage storage) \{
03:\hspace*{0.2in}this.storage = storage;
04:\hspace*{0.1in}\}
05:\hspace*{0.1in}public void SaveSetting(string sn, object sv) \{
06:\hspace*{0.2in}object ov = storage.GetSetting( sn );
07:\hspace*{0.2in}//Avoid change if there is no real change
08:\hspace*{0.2in}if (ov != null ) \{
09:\hspace*{0.3in}if (ov is string && sv is string && 
\hspace*{1.0in}(string)ov == (string)sv ||
10:\hspace*{0.4in}ov is int && sv is int && (int)ov == (int)sv ||
11:\hspace*{0.4in}ov is bool && sv is bool && (bool)ov == (bool)sv ||
12:\hspace*{0.4in}ov is Enum && sv is Enum && ov.Equals(sv))
13:\hspace*{0.5in}return;
14:\hspace*{0.2in}\}
15:\hspace*{0.2in}storage.SaveSetting(sn, sv);
16:\hspace*{0.2in}if (Changed != null)
17:\hspace*{0.3in}Changed(this, new SettingsEventArgs(sn));
18:\hspace*{0.2in}\}
19:\}
\end{alltt}
\end{CodeOut}
\Caption{\label{fig:cut} A method under test from the NUnit framework.}
\end{figure}

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
00://testGroup is of type SettingsGroup
01:[Test]
02:public void TopLevelSettings() \{
03:\hspace*{0.1in}testGroup.SaveSetting("X", 5);
04:\hspace*{0.1in}testGroup.SaveSetting("NAME", "Charlie");
05:\hspace*{0.1in}Assert.AreEqual(5, testGroup.GetSetting("X"));
06:\hspace*{0.1in}Assert.AreEqual("Charlie", testGroup.GetSetting("NAME"));
07:\}
\end{alltt}
\end{CodeOut}
\Caption{\label{fig:connuit} A conventional unit test from the \CodeIn{Util}
package of the NUnit framework.}
\end{figure}

Figure~\ref{fig:connuit} shows a conventional unit test for testing the \CodeIn{SaveSetting} method. The conventional unit test saves two setting values (of types \CodeIn{int} and \CodeIn{string}) and verifies whether the values are set properly using the \CodeIn{GetSetting} method. The conventional unit test verifies the expected behavior of the \CodeIn{SaveSetting} method only for the setting values of types \CodeIn{int} and \CodeIn{string}. The conventional unit test does not verify the behavior for types \CodeIn{bool} and \CodeIn{enum}. Furthermore, the conventional unit test does not cover the \CodeIn{true} branch in Statement 8 of Figure~\ref{fig:cut}. The reason is that the conventional unit test does not invoke the \CodeIn{SaveSetting} method more than once with the same setting name. This conventional unit test achieves $0$\% of branch coverage in the code under test. We next explain our systematic procedure and show how our generalized PUT can address the preceding issues.

%------------------------------------------------------------------------------
\textbf{Promoting concrete values and local variables.} 
To generalize this conventional unit test, we first identify the concrete values used in the test case. For example, the unit test includes a concrete \CodeIn{string} value ``\CodeIn{Charlie}'' in Statement 4. We replace these concrete values with symbolic values by promoting those values as parameters for the PUT. The advantage of replacing concrete values with symbolic values is that Pex can generate concrete values based on the constraints encountered in different paths of the code under test. For example, while promoting the ``\CodeIn{Charlie}'' as parameter for the PUT, we describe the type of the parameter as \CodeIn{object}. Pex automatically identifies the possible types for the \CodeIn{object} type such as \CodeIn{int} or \CodeIn{bool} from the code under test and generates concrete values for those types. Therefore, a single PUT can achieve the same test effectiveness as multiple conventional unit tests with different concrete values. 

Along with promoting concrete values as parameters of PUTs, we also promote other local variables such as the receiver object of the \CodeIn{SaveSetting} method as parameters for PUTs. In this example, the local variable \CodeIn{testGroup} is a non-primitive object. Promoting such receiver objects as parameters can help generate different states (for those receiver objects) that can help cover new paths in the code under test. For example, consider that there is a defect in the \CodeIn{SaveSetting} method that can be exposed when there are five elements in the storage. Promoting the receiver object of \CodeIn{SaveSetting} as a parameter can help generate such desirable object states and expose those related defects. However, it is quite challenging to automatically generate method-call sequences that can create and mutate instances of non-primitive parameters~\cite{}. We address this issue by using a feature called \emph{factory} methods in Pex. Section~\ref{sec:supporting} provides more details on how we use factory methods.

%--------------------------------------------------------------------------------
\textbf{Identification of test pattern.} We next analyze the conventional unit test to identify a test pattern~\cite{PEXDOC} that the test belongs to. Identifying the test pattern can help in easy generalization of the conventional unit test as these patterns can serve as guidelines during the test generalization. In our current conventional unit test, a setting is stored in the storage using the \CodeIn{SaveSetting} method and is verified with the \CodeIn{GetSetting} method. Such a conventional unit test belongs to the round-trip pattern, which applies to classes such as \CodeIn{SettingsGroup} that has a method (such as \CodeIn{SaveSetting}) and an inverse method (such as \CodeIn{GetSetting}). Section~\ref{} presents more details on our test patterns that can be used during our generalization phase. In our empirical study, we identify that these patterns cover a broad range of conventional unit tests and assist during test generalization.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
//PAUT: PexAssumeUnderTest
00:[PexMethod]
01:public void TopLevelSettingsPUT1([PAUT] SettingsGroup st, 
02:\hspace*{0.1in}[PAUT] string sn, [PexAssumeNotNull] object sv) \{
03:\hspace*{0.2in}st.SaveSetting(sn, sv);
04:\hspace*{0.2in}PexAssert.AreEqual(sv, st.GetSetting(sn));
05:\}
\end{alltt}
\end{CodeOut}
\Caption{\label{fig:putskel} PUT for the conventional unit test shown in Figure~\ref{fig:connuit}.}
\end{figure}

Figure~\ref{fig:putskel} shows the skeleton of the PUT after generalizing concrete values and the receiver object. Our PUT accepts three parameters: an instance of \CodeIn{SettingsGroup}, name of the setting, and its value. The \CodeIn{SaveSetting} method can be used to save either an \CodeIn{integer} value or a \CodeIn{string} value (the method accepts both types for its arguments). Therefore, the conventional unit test requires two method calls shown in Statements 3 and 4 of Figure~\ref{fig:connuit} to verify whether the method under test correctly handles these types. On the other hand, only one method call is sufficient in the generalized PUT as the argument type is promoted to \CodeIn{object}. Pex automatically explores the code under test and generates tests that cover both \CodeIn{int} and \CodeIn{string} types. Indeed, the \CodeIn{SaveSetting} method also accepts \CodeIn{bool} and \CodeIn{enum} types. Existing conventional unit test did not include tests for verifying these two types. Our generalized PUT automatically handles these additional types, serving as a primary advantage of PUT as it helps reduce the test code significantly without reducing the behavior tested by the conventional unit test.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
00:[PexFactoryMethod(typeof(MSS))]
\hspace*{0.3in}//MSS: MemorySettingsStorage (class)
\hspace*{0.3in}//PAUT: PexAssumeUnderTest	(Pex attribute)
01:public static MSS Create([PAUT]string[] 
02:\hspace*{0.3in}sn, [PexAssumeNotNull]object[] sv) \{
03:\hspace*{0.2in}PexAssume.IsTrue(sn.Length == sv.Length);
04:\hspace*{0.2in}PexAssume.IsTrue(sn.Length > 0);
05:\hspace*{0.2in}MSS mss = new MSS();
06:\hspace*{0.2in}for (int count = 0; count < sn.Length; count++) \{
07:\hspace*{0.3in}mss.SaveSetting(sn[count], sv[count]);
08:\hspace*{0.2in}\}
09:\hspace*{0.2in}return mss;            
10:\}
\end{alltt}
\end{CodeOut}
\Caption{\label{fig:factorymethd} An example factory method for the type \CodeIn{MemorySettingsStorage}.}
\end{figure}

\textbf{Adding assumptions.} During test generalization, we identify Pex requires guidance in generating legal values for PUTs. We address this challenge in our systematic procedure by adding sufficient assumptions to PUTs. For example, without any assumptions provided, Pex by default generates \CodeIn{null} values for non-primitive arguments of PUTs. To address this issue, we annotate a PUT method argument with a tag \CodeIn{PexAssumeUnderTest}\footnote{\CodeIn{PexAssumeUnderTest} is a custom attribute provided by Pex.}, which describes that the argument should not be \CodeIn{null} and the argument type should be the same type as specified. We add further assumptions based on the behavior verified by the conventional unit test. For example, if the conventional unit test requires an assumption that the setting to be added should not already exist in the storage, we add additional assumptions to the PUT.

%--------------------------------------------------------------------------------
\textbf{Using supporting techniques.} During test generalization, we identify that another major challenge is to handle parameters of non-primitive types. Pex can effectively handle primitive-type parameters such as \CodeIn{string} or \CodeIn{int}. However, for non-primitive types, method-call sequences are required for generating desirable object states. These desirable object states are the states that help explore paths in the code under test. For example, a desirable object state to cover the \CodeIn{true} branch of Statement 8 in Figure~\ref{fig:cut} is that the storage should already include a value for the setting name. 

The primary challenge in constructing desirable states for non-primitive arguments is to construct a sequence of method calls that create and mutate objects. However, similar to the other state-of-the-art method-call sequence generation approaches~\cite{}, Pex also faces challenges in generating sequences for non-primitive types such as \CodeIn{st}. To address this issue, we use a feature, called factory methods, to assist Pex in generating effective method-call sequences that can help achieve desirable object states. Figure~\ref{fig:factorymethd} shows an example factory method for the \CodeIn{MemorySettingsStorage} written manually. We wrote the factory method for \CodeIn{MemorySettingsStorage} as the \CodeIn{storage} is of type \CodeIn{MemorySettingsStorage}. Our factory method accepts two arrays of setting names and values, and adds those entries to the storage. This factory method helps Pex to generate method-call sequences that can create desirable object states. For example, Pex can generate five names and five values as arguments to our factory method for creating a desirable object state with five elements in the storage. The same factory can be reused for all other PUTs using the \CodeIn{MemorySettingsStorage} type.

Along with factory methods, we use another supporting technique called mock objects. These mock objects help test features in isolation especially when the unit test interacts with environments such as file system. Section~\ref{} provides more details on how we use these both factory methods and mock objects.

%-------------------------------------------------------------------------------



We next apply Pex on the \CodeIn{TopLevelSettingsPUT1} PUT. Pex generated $8$ conventional unit tests from the \CodeIn{TopLevelSettingsPUT1} PUT. These conventional unit tests verify the \CodeIn{SaveSetting} method with different setting values of types such as \CodeIn{int} or \CodeIn{string} or other non-primitive object types. Figure~\ref{} shows the conventional unit tests generated by Pex for the PUT. As shown, a single PUT can substitute multiple conventional unit tests, resulting in a better test code maintenance. Furthermore, the conventional unit test used for generalization has achieved a coverage of $0$\%, whereas the conventional unit tests generated from the generalized PUT has achieved the final coverage of $0$\%. 

TODO: To mention briefly about the uncovered portions.

%In a few cases, we identify that direct generalization of conventional unit tests might not achieve 100\% block coverage. There could be several reasons such as the portions of 
%the code are not covered by the behavior tested by conventional unit tests. In those cases, we identify the un-covered portions of the code and write new PUTs or modify the transformed PUTs to cover these code portions. Consider a sample code example shown in Figure~\ref{fig:handleexample}. We highlight 
%the un-covered portion of the code in \textbf{bold}. The reason for the un-covered code portion in this code example is that the code portion requires a delegate handler to be defined in the class. A delegate handler can be treated as a pointer to a function. These delegates can be used to encapsulate a method with a specific signature and return type. To achieve 100\% coverage of the \CodeIn{RemoveSetting} method in the preceding code example, we created a trivial delegate handler and set the value to \CodeIn{Changed}.
%We present details on the usage of supporting techniques in our study in Section~\ref{sec:helper}.
%
%\begin{figure}[t]
%\begin{CodeOut}
%\begin{alltt}
%00:[PexMethod]
%//MSS: MemorySettingsStorage (class)
%//PAUT: PexAssumeUnderTest	(Pex attribute)
%//Changed is of type Delegate
%01:public void RemoveSetting(MSS st,
%\hspace*{0.3in}[PAUT]string settingName) \{
%02:\hspace*{0.1in}st.RemoveSetting( settingName );
%03:\hspace*{0.1in}if (Changed != null)
%04:\hspace*{0.2in}\textbf{Changed(this, new SettingsEventArgs(settingName))};
%05:\}
%\end{alltt}
%\end{CodeOut}
%\Caption{\label{fig:handleexample} A code sample with an un-covered portion (shown in bold) with PUTs written by transforming conventional unit tests.}
%\end{figure}