\subsection{RQ1: Branch Coverage}

We next describe our empirical results for addressing RQ1. We execute the existing test suite (CUTs) and measure the branch coverage achieved by these CUTs. We then measure the branch coverage achieved by the unit tests generated by Pex from the given PUTs. Consequently, we compare the branch coverage achieved by both the CUTs and PUTs for each class or namespace.
%We use NCover~\cite{} coverage tool to measure the dynamic coverage achieved by both CUTs and PUTs.  
\begin{table}[t]%
\begin{tabular}{|l|l|r|r|c|}
\hline
%------Header --------------
\textbf{Subject} & \textbf{Namespace}/										& \multicolumn{2}{|c|}
																														{\textbf{Branch Coverage}}  &  \multicolumn{1}{|c|}{\textbf{Coverage}}\\
								 & 	\textbf{Class}												&	\multicolumn{2}{|c|}{}&  \multicolumn{1}{|c|}{\textbf{Increase}}\\
\hline
								 &																	 						&	CUTs							&	PUTs						&	     \\
%------end ------------------
\hline
\hline
NUnit 			& \multicolumn{3}{|c|}{}																					& 10\%\\ \hline
 						& MemorySettings 					&										& 									&			\\
 						&								Storage 	& 100.00\% 					& 100.00\% 					& 		\\ \cline{2-4}
 						& NunitProject						&  \textbf{76.00\%}	& \textbf{77.00\%}	& 		\\ \cline{2-4}
						& NunitRegistry						&  85.00\%					&  85.00\% 					& 		\\ \cline{2-4}
						&	PathUtils								&  79.00\% 					&  79.00\% 					& 		\\ \cline{2-4}
						& RegistrySettings				&										&										&			\\
						& 								Storage	&	\textbf{48.00\%} 	& \textbf{86.00\%}	& 		\\ \cline{2-4}
						& RemoteTestAgent					& 100.00\% 					&	100.00\% 					& 		\\ \cline{2-4}
						& ServerUtilities					&  91.00\% 					&  91.00\%					& 		\\ \cline{2-4}
						& SettingsGroup						& \textbf{39.00\%}	& \textbf{91.00\%}	& 		\\ \cline{2-4}
						& TestAgency 							&  86.00\%					&  86.00\%					& 		\\ \cline{2-4}
\hline
\hline
DSA 				& \multicolumn{3}{|c|}{} 																					& 1\% \\ \hline
						& Algorithms							& \textbf{93.00\%}	&  \textbf{94.00\%}	& 		\\ \cline{2-4}
						& DataStructures					& \textbf{99.00\%}	& \textbf{100.00\%}	&			\\ \cline{2-4}
						& Properties							& 96.00\%						&  96.00\%					& 		\\ \cline{2-4}
						& Utility 								& 78.00\% 					&  78.00\%					&			\\ \cline{2-4}
\hline
\hline
Quick				& \multicolumn{3}{|c|}{} 														  						&			\\ 
Graph				& \multicolumn{3}{|c|}{} 																					&	2\%	\\ \hline
						& Default									& 87.00\%						&  87.00\%					& 		\\ \cline{2-4}
						& Algorithms							& \textbf{90.00\%}	&  \textbf{92.00\%}	&			\\ \cline{2-4}
						& Collections							& 97.00\%						&  97.00\%					& 		\\ \cline{2-4}
						& Concepts 								& \textbf{72.00\%} 	&  \textbf{83.00\%}	&			\\ \cline{2-4}
						& Exceptions 							&100.00\% 					& 100.00\%					&			\\ \cline{2-4}
						& Predicates 							& 83.00\% 					&  83.00\%					&			\\ \cline{2-4}
						& Representations					& \textbf{82.00\%}	&  \textbf{84.00\%} &			\\ \cline{2-4}
\hline
\hline
\end{tabular}
\caption{Coverage of the existing CUTs and the unit tests generated by Pex using the generalized PUTs. A highlighted row indicates the class/namspace that had an increase in coverage.} \vspace*{-3ex}
\label{tab:coverage}
\end{table}

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
01: public void RemoveSetting(string settingName) \{
02: \hspace*{0.05in}int dot = settingName.IndexOf( '.' );
03: \hspace*{0.15in}if (dot < 0)
04: \hspace*{0.2in}storageKey.DeleteValue(settingName, false);
05: \hspace*{0.15in}else \{
06: \hspace*{0.2in}using(RegistryKey subKey = storageKey.OpenSubKey(
\hspace*{0.8in}settingName.Substring(0,dot),true))\{
07: \hspace*{0.3in}if (subKey != null)
08: \hspace*{0.5in}subKey.DeleteValue(
\hspace*{1.0in}settingName.Substring(dot + 1)); \} \}
09: \hspace*{0.02in}\} 
\end{alltt}
\end{CodeOut} \vspace*{-3ex}
\caption{\CodeIn{RemoveSetting} method whose coverage is increased by $60\%$ due to test generalization.} %\vspace*{-2ex}
\label{fig:excoverage}
\end{figure}

Table~\ref{tab:coverage} shows the branch coverage achieved by executing the existing CUTs and the unit tests generated by Pex using the transformed PUTs. Column ``Coverage Increase'' shows the overall increase in the branch coverage from using the existing CUTs and the generalized PUTs. We use NCover to measure these reported branch coverages. For the subjects DSA and QuickGraph, since we generalized all unit tests in the existing test suite, we report the coverage for each namespace. For NUnit, we generalized nine test classes and therefore, we report branch coverage individually for these nine classes under test. For NUnit, we excluded branch coverage for the classes that were covered by the unit tests but were not directly a part of our target code under test. However, the branch coverage for those classes (excluded from the table) were the same for both CUTs and PUTs.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
01: public void CUT() \{
02: \hspace*{0.07in}storage.SaveSetting("X",5);
03: \hspace*{0.07in}storage.SaveSetting("NAME","Charlie");
04: \hspace*{0.07in}storage.RemoveSetting("X");
05: \hspace*{0.07in}Assert.IsNull(storage.GetSetting("X"),
\hspace*{1.0in}"X not removed");
06: \hspace*{0.07in}Assert.AreEqual("Charlie", 
\hspace{1.0in}storage.GetSetting("NAME"));
07: \hspace*{0.07in}storage.RemoveSetting("NAME");
08: \hspace*{0.07in}Assert.IsNull(storage.GetSetting("NAME"), 
\hspace*{1.8in}"NAME not removed"); 
09: \hspace*{0.02in}\}
\end{alltt}
\end{CodeOut}  \vspace*{-3ex}
\caption{Existing CUT to test the \CodeIn{RemoveSetting} method.} \vspace*{-2ex}
\label{fig:excoveragetest}%
\end{figure}

Since generalized tests often help cover more paths in the code under test, we found that test generalization helped to achieve effective increase in the branch coverage. For example, for \CodeIn{Registry SettingsStorage}, Table~\ref{tab:coverage} shows increase in branch coverage by $38\%$. We next present an illustrative example to show how test generalization helps increase branch coverage of the code under test. Figure~\ref{fig:excoverage} shows the \CodeIn{RemoveSetting} method and Figure~\ref{fig:excoveragetest} shows the existing CUT for \CodeIn{RemoveSetting}. On executing the test and analyzing the code portions that are not covered in the \CodeIn{RegistrySettingsStorage} class, we observed that the code inside the \CodeIn{else} block (Statements $5$-$8$) was not covered by the unit test, i.e., the \CodeIn{false} branch was not covered. Figure~\ref{fig:excoveragePUT} shows the PUT that was generalized from the existing CUT. On executing Pex with this PUT, we observed that the code portions not covered by the CUT, i.e., Statements $5$-$8$ of the \CodeIn{RemoveSetting} method were covered by the new generated unit tests. This example shows that Pex was able to generate unit tests that covered both the \CodeIn{true} and \CodeIn{false} branches of the branching condition shown in Statement $3$. Using the generalized PUT, two types of test inputs for the ``\CodeIn{settingName}'' parameter were generated, those that contained `.' and those that did not contain `.'. Therefore, in contrast to the $20\%$ branch coverage achieved by executing the CUT, $80\%$ branch coverage was achieved by executing the unit tests generated by Pex using the PUT. 

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
01: public void PUT([PAUT]String[] name, 
\hspace*{1.7in}[PAUT]Object[] value) \{
02: \hspace*{0.07in}............
03: \hspace*{0.07in}for (int i = 0; i < name.Length; i++) \{
04: \hspace*{0.22in}storage.SaveSetting(name[i], value[i]); \}
05: \hspace*{0.07in}for (int i = 0; i < name.Length; i++) \{
06: \hspace*{0.17in}if (storage.GetSetting(name[i]) != null) \{
07: \hspace*{0.3in}storage.RemoveSetting(name[i]);
08: \hspace*{0.3in}PexAssert.IsNull(storage.GetSetting(name[i]), 
\hspace*{1.5in}name[i] + " not removed"); 
08: \hspace*{0.1in}\}\}\}
\end{alltt}
\end{CodeOut} \vspace*{-4ex}
\caption{Transformed PUT of the CUT shown in Figure~\ref{fig:excoveragetest}.} \vspace*{-3ex}
\label{fig:excoveragePUT}%
\end{figure}

For NUnit, the branch coverage of three classes is increased by $1\%$, $38\%$, and $52\%$ respectively. For QuickGraph, there is an increase in branch coverage for three namespaces, one with an increase of $11\%$ and the other two namespaces have an increase of $2\%$. In DSA, for two namespaces, the branch coverage is increased  by $1\%$. One major reason for not achieving a significant increase in the coverage for DSA is that the existing CUTs already achieved a high branch coverage and PUTs help achieve a little higher coverage than the existing CUTs. In summary, for the three subjects, NUnit, DSA, and QuickGraph, generalizing the existing CUTs resulted in an average increase in coverage by $10\%$, $1\%$, and $2\%$, respectively. For all of the three subjects, there is no decrease in the branch coverage due to test generalization. The reason is that we used the existing CUTs as test scenarios to write the transformed PUTs. Therefore, when the transformed PUTs are provided with necessary assumptions on the test data, the generated tests achieve at least as much coverage as the existing CUTs. Furthermore, through our systematic procedure we provide additional assistance to Pex to meet the same test objective as the existing CUT.


%-----------------------------------------------------------------------------------------------------------------------------------------
%\begin{table}%
%\begin{center}
%\begin{tabular}{|l|r|r|r|r|r|}
%\multicolumn{6}{c}{\textbf{A. DSA}}\\
%\hline
%&Overall 	& Algorithms & DataStructures &	Properties	& Utility\\
%\hline
%Existing &	93.25\% &	99.00\%	& 96.00\% &	78.00\%	& 100.00\% \\			
%\hline
%PexGenerated &	93.50\%	& 100.00\% &	96.00\% &	78.00\%	& 100.00\% \\
%\hline
%\hline
%\end{tabular}
%\vspace{2ex}
%\begin{tabular}{|l|r|r|r|r|r|r|r|r|}
%
%\multicolumn{9}{c}{\textbf{B. QuickGraph}} \\
%\hline							
%&Overall	& Default &	Algorithms	& Collections	& Concepts &	Exceptions & Predicates &	Representations \\
%\hline
%Existing	& 87.29\% &	87.00\% &	90.00\% &	97.00\% &	72.00\% &	100.00\% &	83.00\% &	82.00\% \\
%\hline
%PexGenerated &	87.71\% &	87.00\%	& 93.00\% &	97.00\% &	70.00\% &	100.00\% &	83.00\%	& 84.00\% \\
%\hline
%\hline
%\end{tabular}
%
%\vspace{2ex}
%
%\begin{tabular}{|l|r|r|r|r|r|r|r|r|r|r|}
%\multicolumn{11}{c}{\textbf{C. NUnit}} \\
%\hline	
%&	Overall &	MSS &	Project &	Registry & PU &	RSS &	RTA	& SU &	SG	& TA \\
%\hline
%Existing &	78.22\%	& 100.00\% &	76.00\%	& 85.00\% &	79.00\% &	48.00\% &	100.00\% & 91.00\% & 39.00\%	& 86.00\% \\
%\hline
%PexGenerated	 & 88.33\% &	100.00\% &	76.00\%	& 85.00\% &	79.00\%	& 86.00\%	& 100.00\% &	91.00\%	& 92.00\%	& 86.00\% \\
%\hline
%\hline
%\end{tabular}
%
%\end{center}
%\caption{Coverage of the existing CUTs and the unit tests generated by Pex for the given PUTs.}
%\label{tab:coverage}
%\end{table}