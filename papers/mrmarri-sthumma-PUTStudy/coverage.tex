\subsection{RQ1: Coverage}

We next describe our empirical results for addressing RQ1. We execute the existing test suite (CUTs) and measure the branch coverage achieved by these CUTs. We then measure the coverage achieved by the unit tests generated by Pex from the given PUTs. Consequently, we compare the code coverage achieved by both the CUTs and PUTs for each class or namespace.
%We use NCover~\cite{} coverage tool to measure the dynamic coverage achieved by both CUTs and PUTs.  
\begin{table}[t]%
\begin{tabular}{|l|l|r|r|c|}
\hline
%------Header --------------
\textbf{Subject} & \textbf{Namespace}$\backslash$					& \multicolumn{2}{|c|}
																														{\textbf{Branch Coverage}}  &  \multicolumn{1}{|c|}{\textbf{Coverage}}\\
								 & 	\textbf{Class}												&	\multicolumn{2}{|c|}{}&  \multicolumn{1}{|c|}{\textbf{Increase}}\\
\hline
								 &																	 						&	CUTs							&	PUTs						&	     \\
%------end ------------------
\hline
\hline
NUnit 			& \multicolumn{3}{|c|}{}																					& 10\%\\ \hline
 						& MemorySettings 					&										& 									&			\\
 						&								Storage 	& 100.00\% 					& 100.00\% 					& 		\\ \cline{2-4}
 						& NunitProject						&  76.00\%					&  76.00\% 					& 		\\ \cline{2-4}
						& NunitRegistry						&  85.00\%					&  85.00\% 					& 		\\ \cline{2-4}
						&	PathUtils								&  79.00\% 					&  79.00\% 					& 		\\ \cline{2-4}
						& RegistrySettings				&										&										&			\\
						& 								Storage	&	\textbf{48.00\%} 	& \textbf{86.00\%}	& 		\\ \cline{2-4}
						& RemoteTestAgent					& 100.00\% 					&	100.00\% 					& 		\\ \cline{2-4}
						& ServerUtilities					&  91.00\% 					&  91.00\%					& 		\\ \cline{2-4}
						& SettingsGroup						& \textbf{39.00\%}	& \textbf{92.00\%}	& 		\\ \cline{2-4}
						& TestAgency 							&  86.00\%					&  86.00\%					& 		\\ \cline{2-4}
\hline
\hline
DSA 				& \multicolumn{3}{|c|}{} 																					& 1\% \\ \hline
						& Algorithms							& \textbf{93.00\%}	&  \textbf{94.00\%}	& 		\\ \cline{2-4}
						& DataStructures					& \textbf{99.00\%}	& \textbf{100.00\%}	&			\\ \cline{2-4}
						& Properties							& 96.00\%						&  96.00\%					& 		\\ \cline{2-4}
						& Utility 								& 78.00\% 					&  78.00\%					&			\\ \cline{2-4}
\hline
\hline
Quick				& \multicolumn{3}{|c|}{} 														  						&			\\ 
Graph				& \multicolumn{3}{|c|}{} 																					&	1\%	\\ \hline
						& Default									& 87.00\%						&  87.00\%					& 		\\ \cline{2-4}
						& Algorithms							& \textbf{90.00\%}	&  \textbf{93.00\%}	&			\\ \cline{2-4}
						& Collections							& 97.00\%						&  97.00\%					& 		\\ \cline{2-4}
						& Concepts 								& 72.00\% 					&  70.00\%					&			\\ \cline{2-4}
						& Exceptions 							&100.00\% 					& 100.00\%					&			\\ \cline{2-4}
						& Predicates 							& 83.00\% 					&  83.00\%					&			\\ \cline{2-4}
						& Representations					& \textbf{82.00\%}	&  \textbf{84.00\%} &			\\ \cline{2-4}
\hline
\hline
\end{tabular}
\caption{Coverage of the existing CUTs and the unit tests generated by Pex using the generalized PUTs} \vspace*{-2ex}
\label{tab:coverage}
\end{table}

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
01: public void RemoveSetting( string settingName) \{
02: \hspace*{0.05in}int dot = settingName.IndexOf( '.' );
03: \hspace*{0.15in}if ( dot < 0 )
04: \hspace*{0.2in}storageKey.DeleteValue( settingName, false );
05: \hspace*{0.15in}else \{
06: \hspace*{0.2in}using(RegistryKey subKey=storageKey.OpenSubKey(
\hspace*{0.8in}settingName.Substring(0,dot),true))\{
07: \hspace*{0.3in}if ( subKey != null )
08: \hspace*{0.5in}subKey.DeleteValue(
\hspace*{1.0in}settingName.Substring(dot + 1)); \} \}
09: \hspace*{0.02in}\} 
\end{alltt}
\end{CodeOut} \vspace*{-3ex}
\caption{\CodeIn{RemoveSetting} method whose coverage is increased by $60\%$ due to test generalization.} %\vspace*{-2ex}
\label{fig:excoverage}
\end{figure}

Table~\ref{tab:coverage} shows the branch coverage achieved by executing the existing CUTs and the unit tests generated by Pex using the generalized PUTs. Column ``Coverage Increase'' shows the overall increase in the branch coverage from using the existing CUTs and the generalized PUTs. We use NCover for measuring these reported coverages. For the subjects DSA and QuickGraph, since we generalized all unit tests in the existing test suite, we report the coverage values for each namespace. For NUnit, we generalized nine test classes and therefore, we report coverage values individually for these nine classes under test. For NUnit, we excluded coverage values for the classes that were covered by the unit tests but were not directly a part of our target code under test. However, the coverage values for those classes (excluded from the table) were the same for both CUTs and PUTs.  

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
01: public void CUT() \{
02: \hspace*{0.07in}storage.SaveSetting("X",5);
03: \hspace*{0.07in}storage.SaveSetting("NAME","Charlie");
04: \hspace*{0.07in}storage.RemoveSetting("X");
05: \hspace*{0.07in}Assert.IsNull(storage.GetSetting("X"),
\hspace*{1.0in}"X not removed");
06: \hspace*{0.07in}Assert.AreEqual("Charlie", 
\hspace{1.0in}storage.GetSetting( "NAME" ) );
07: \hspace*{0.07in}storage.RemoveSetting("NAME");
08: \hspace*{0.07in}Assert.IsNull( storage.GetSetting("NAME"), 
\hspace*{1.8in}"NAME not removed" ); 
09: \hspace*{0.02in}\}
\end{alltt}
\end{CodeOut}  \vspace*{-3ex}
\caption{Existing CUT to test the \CodeIn{RemoveSetting} method.} \vspace*{-2ex}
\label{fig:excoveragetest}%
\end{figure}

Since generalized tests often help cover more paths in the code under test, we found that test generalization helped to have an effective increase in the branch coverage. For example, for the \CodeIn{RegistrySettingsStorage} class, Table~\ref{tab:coverage} shows an increase in the coverage by $38.00\%$. We next present an illustrative example to show how test generalization helps increase the coverage of the code under test. Figure~\ref{fig:excoverage} shows the \CodeIn{RemoveSetting} method and Figure~\ref{fig:excoveragetest} shows the corresponding unit test in the existing conventional test suite. On executing the test and analyzing the code portions that are not covered in the \CodeIn{RegistrySettingsStorage} class, we observed that the code inside the \CodeIn{else} block (statements $5$-$8$) was not covered by the unit test, i.e., the \CodeIn{false} branch was not covered. Figure~\ref{fig:excoveragePUT} shows the PUT that was generalized from the existing unit test. On executing Pex with this PUT, we observed that the code portions not covered by the CUT, i.e., statements $5$-$8$ of the \CodeIn{RemoveSetting} method were covered by the new generated unit tests. This example shows that Pex was able to generate unit tests that covered both the \CodeIn{true} and \CodeIn{false} branches of the branching condition shown in statement $3$. This means that using the generalized PUT, two types of test inputs for the ``settingName'' parameter were generated, those that contained `.' and those that did not contain `.'. Therefore, in contrast to the $20\%$ coverage achieved by executing the CUT, $80\%$ coverage was achieved by executing the unit tests generated by Pex using the PUT. 

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
01: public void PUT([PAUT]String[] name, 
\hspace*{1.7in}[PAUT]Object[] value) \{
02: \hspace*{0.07in}............
03: \hspace*{0.07in}for (int i = 0; i < name.Length; i++) \{
04: \hspace*{0.22in}storage.SaveSetting(name[i], value[i]); \}
05: \hspace*{0.07in}for (int i = 0; i < name.Length; i++) \{
06: \hspace*{0.17in}if (storage.GetSetting(name[i]) != null) \{
07: \hspace*{0.3in}storage.RemoveSetting(name[i]);
08: \hspace*{0.3in}PexAssert.IsNull(storage.GetSetting(name[i]), 
\hspace*{1.5in}name[i] + " not removed"); 
08: \hspace*{0.1in}\}\}\}
\end{alltt}
\end{CodeOut} \vspace*{-2ex}
\caption{PUT written by generalizing the existing CUT shown in Figure~\ref{fig:excoveragetest}} \vspace*{-2ex}
\label{fig:excoveragePUT}%
\end{figure}

For NUnit, the coverage of two classes is increase by $38\%$ and $53\%$ each. For DSA and QuickGraph, two namespaces each showed increase in the coverage by $1\%$ and $2\%$, respectively. One major reason for not achieving a significant increase in the coverage for DSA and QuickGraph is that the existing CUTs already achieved a high coverage. In summary, for the three subjects, generalizing the existing unit tests resulted in an overall average increase in coverage by $10\%$, $1\%$, and $1\%$ respectively. 

%-----------------------------------------------------------------------------------------------------------------------------------------
%\begin{table}%
%\begin{center}
%\begin{tabular}{|l|r|r|r|r|r|}
%\multicolumn{6}{c}{\textbf{A. DSA}}\\
%\hline
%&Overall 	& Algorithms & DataStructures &	Properties	& Utility\\
%\hline
%Existing &	93.25\% &	99.00\%	& 96.00\% &	78.00\%	& 100.00\% \\			
%\hline
%PexGenerated &	93.50\%	& 100.00\% &	96.00\% &	78.00\%	& 100.00\% \\
%\hline
%\hline
%\end{tabular}
%\vspace{2ex}
%\begin{tabular}{|l|r|r|r|r|r|r|r|r|}
%
%\multicolumn{9}{c}{\textbf{B. QuickGraph}} \\
%\hline							
%&Overall	& Default &	Algorithms	& Collections	& Concepts &	Exceptions & Predicates &	Representations \\
%\hline
%Existing	& 87.29\% &	87.00\% &	90.00\% &	97.00\% &	72.00\% &	100.00\% &	83.00\% &	82.00\% \\
%\hline
%PexGenerated &	87.71\% &	87.00\%	& 93.00\% &	97.00\% &	70.00\% &	100.00\% &	83.00\%	& 84.00\% \\
%\hline
%\hline
%\end{tabular}
%
%\vspace{2ex}
%
%\begin{tabular}{|l|r|r|r|r|r|r|r|r|r|r|}
%\multicolumn{11}{c}{\textbf{C. NUnit}} \\
%\hline	
%&	Overall &	MSS &	Project &	Registry & PU &	RSS &	RTA	& SU &	SG	& TA \\
%\hline
%Existing &	78.22\%	& 100.00\% &	76.00\%	& 85.00\% &	79.00\% &	48.00\% &	100.00\% & 91.00\% & 39.00\%	& 86.00\% \\
%\hline
%PexGenerated	 & 88.33\% &	100.00\% &	76.00\%	& 85.00\% &	79.00\%	& 86.00\%	& 100.00\% &	91.00\%	& 92.00\%	& 86.00\% \\
%\hline
%\hline
%\end{tabular}
%
%\end{center}
%\caption{Coverage of the existing CUTs and the unit tests generated by Pex for the given PUTs.}
%\label{tab:coverage}
%\end{table}