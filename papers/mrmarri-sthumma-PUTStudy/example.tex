\section{Example}
\label{sec:example}

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
//st is of type MemorySettingsStorage and 
//instantiated in the init() method of the test class
01:public void SaveAndLoadSettings() \{
02:\hspace*{0.1in}Assert.IsNull(st.GetSetting("X"));
03:\hspace*{0.1in}Assert.IsNull(st.GetSetting("NAME"));
04:\hspace*{0.1in}st.SaveSetting("X", 5);
05:\hspace*{0.1in}st.SaveSetting("NAME", "Charlie");
06:\hspace*{0.1in}Assert.AreEqual(5, st.GetSetting("X"));
07:\hspace*{0.1in}Assert.AreEqual("Charlie", st.GetSetting("NAME"));
08:\}
\end{alltt}
\end{CodeOut}
\Caption{\label{fig:connuit} A conventional unit test from the \CodeIn{Util}
project of the NUnit framework.}
\end{figure}

We next explain the systematic procedure of retrofitting for PUTs to carry out unit testing in our empirical study with an example. We use the NUnit test case \CodeIn{SaveAndLoadSettings}
shown in Figure~\ref{fig:connuit} as an illustrative example for explaining our procedure. 
The objective of the unit test in our example is to verify the behavior of the
class \CodeIn{MemorySettingsStorage}, which
is primarily used for storage and retrieval of global
values. To generalize this unit test, we first identify
the concrete values used in the test case. For example, the unit test includes a concrete \CodeIn{string} value ``\CodeIn{X}''. We replace these concrete values with symbolic values by making them as arguments. The advantage 
of replacing these concrete values with symbolic values is that
Pex can generate concrete values based on the constraints
encountered in different paths of the method under test (MUT). Consequently, a single PUT can achieve the same test effectiveness (of high block coverage of the MUT) as multiple conventional unit tests with different concrete values testing the same method. In addition to generalizing the concrete values, we also generalize receiver objects. 

We then analyze the conventional unit test to identify a PUT
pattern~\cite{PEXDOC} that the test belongs to. Identifying a pattern can help in
easy generalization of the conventional unit test.
For example, in the example conventional
unit test, a setting is stored in the storage using the \CodeIn{SaveSetting}
method and is verified with the \CodeIn{GetSetting} method.
Such a conventional unit test belongs to the round-trip pattern suggested in the
Pex documentation~\cite{PEXDOC, halleux08:putpatterns}. If the conventional unit test does not 
fall into any of the pre-defined patterns, we define new patterns as shown in Section~\ref{sec:newpatterns}.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
00:[PexMethod]
01:public void SaveAndLoadSettingsTest1(
02:\hspace*{0.1in}MemorySettingsStorage st, String sn, Object sv) \{
03:\hspace*{0.2in}//Define Pex Assumptions
04:\hspace*{0.2in}st.SaveSetting(sn, sv);
05:\hspace*{0.2in}PexAssert.AreEqual(sv, st.GetSetting(sn));
06:\}
\end{alltt}
\end{CodeOut}
\Caption{\label{fig:putskel} A sample PUT for the conventional unit test shown in Figure~\ref{fig:connuit}.}
\end{figure}

Figure~\ref{fig:putskel} shows the skeleton of the PUT after generalizing concrete values and the receiver object.
Our PUT accepts three parameters: the instance of \CodeIn{MemorySettingsStorage}, 
name of the setting, and its value. The \CodeIn{SaveSetting} method can be used to save either an \CodeIn{integer} value or a \CodeIn{string} value (the method accepts both types for its arguments). Therefore, the test requires two method calls
shown in Statements 4 and 5 (Figure~\ref{fig:connuit}) to test that the method under test works as expected for both the input value types. However, we need only one method
call of \CodeIn{SaveSetting} in the PUT because we accept the value type as \CodeIn{Object},
which can cover both \CodeIn{integer} and \CodeIn{String}. 
Indeed, the \CodeIn{SaveSetting} method also accepts \CodeIn{bool}
and \CodeIn{enum} types. The generalization can automatically handle
these additional types too, serving as a 
primary advantage of PUT as it helps reduce the test code significantly
without reducing the behavior tested by the conventional unit test.
We transform the assertions in the conventional unit test into
\CodeIn{PexAssert} assertions to assert the same behavior. If the existing
set of assertions are not sufficient, we add additional assertions to the PUT. Figure~\ref{fig:putcompl} shows
the transformed PUT that replaces the conventional unit test.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
00:[PexFactoryMethod(typeof(MSS))]
\hspace*{0.3in}//MSS: MemorySettingsStorage (class)
\hspace*{0.3in}//PAUT: PexAssumeUnderTest	(Pex attribute)
01:public static MSS Create([PAUT]String[] 
02:\hspace*{0.3in}sn, [PexAssumeNotNull]Object[] sv) \{
03:\hspace*{0.2in}PexAssume.IsTrue(sn.Length == sv.Length);
04:\hspace*{0.2in}PexAssume.IsTrue(sn.Length > 0);
05:\hspace*{0.2in}MSS mss = new MSS();
06:\hspace*{0.2in}for (int count = 0; count < sn.Length; count++) \{
07:\hspace*{0.3in}PexAssume.IsTrue(sv[count] is string ||
08:\hspace*{0.4in}sv[count] is int || sv[count] is bool || 
09:\hspace*{0.4in}sv[count] is Enum);
10:\hspace*{0.3in}mss.SaveSetting(sn[count], sv[count]);
11:\hspace*{0.2in}\}
12:\hspace*{0.2in}return mss;            
13:\}
\end{alltt}
\end{CodeOut}
\Caption{\label{fig:factorymethd} A factory method to assist Pex.}
\end{figure}

For test generation, Pex can effectively handle primitive-type parameters such
as \CodeIn{String} or \CodeIn{integer}. However, like any other test generation tool, Pex faces challenges 
in generating values for non-primitive arguments such as \CodeIn{st} in our PUT.
These non-primitive arguments often require desirable states to
verify different behaviors. For example, an intention in our conventional
unit test to have two \CodeIn{SaveSetting} method calls is to verify
adding a new setting when there is already an existing setting in the
storage. For example, consider that there is a defect in the 
implementation of \CodeIn{SaveSetting} that can be exposed \emph{only}
when there are five elements in the storage, then the desirable
state for such a non-primitive argument is to have five elements
already present in the storage. Therefore, to test the method under test in various scenarios, generalizing the receiver object helps in this case. However, the primary challenge in constructing 
desirable states for non-primitive arguments is to 
construct a sequence of method calls that create
and mutate objects. We use a factory method supported by Pex to assist Pex in generating effective method-call
sequences that can help achieve desirable object states. 
Figure~\ref{fig:factorymethd} shows our factory method to assist
Pex in generating effective method-call sequences.
Our factory method accepts two arrays of setting names and values,
and adds those entries to the storage. This factory method helps Pex
to generate method-call sequences that can create desirable object states.
For example, Pex can generate five names and five values as arguments
to our factory method for creating a desirable object state with
five elements in the storage.

Another important aspect of writing generalized PUTs is to 
define assumptions. For example, without any assumptions provided, Pex by default
generates \CodeIn{null} values for the PUT arguments. To address the issue, we annotate a PUT method argument with a tag \CodeIn{PexAssumeUnderTest}\footnote{\CodeIn{PexAssumeUnderTest} is a custom attribute provided by Pex.}, which describes that the argument should not be \CodeIn{null}. We add further assumptions
based on the behavior verified by the unit test. For example,
the conventional unit test requires a assumption that the setting
to be added should not already exist in the storage.
We use \CodeIn{PexAssume} to add these additional assumption to the PUT such as Statement 4 (in Figure~\ref{fig:putcompl}) in \CodeIn{SaveAndLoadSettingsPUT1}.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
00:[PexMethod]
\hspace*{0.3in}//MSS: MemorySettingsStorage (class)
\hspace*{0.3in}//PAUT: PexAssumeUnderTest	(Pex attribute)
01:public void SaveAndLoadSettingsPUT1([PAUT]
02:\hspace*{0.1in}MSS st, [PAUT]String sn, [PAUT]Object sv) \{
03:\hspace*{0.2in}PexAssume.IsFalse(sn.Equals(""));
04:\hspace*{0.2in}PexAssume.IsTrue(st.GetSetting(sn) == null);
05:\hspace*{0.2in}storage1.SaveSetting(sn, sv);
06:\hspace*{0.2in}PexAssert.AreEqual(sv, st.GetSetting(sn));
07:\}
\end{alltt}
\end{CodeOut}
\Caption{\label{fig:putcompl} Complete PUT for the conventional unit test.}
\end{figure}

In a few cases, we identify that direct generalization of conventional unit tests might not
achieve 100\% block coverage. There could be several reasons such as the portions of 
the code are not covered by the behavior tested by conventional unit tests. In those cases, we identify
the un-covered portions of the code and write new PUTs or modify the transformed PUTs to cover these code portions. Consider a sample code example shown in Figure~\ref{fig:handleexample}. We highlight 
the un-covered portion of the code in \textbf{bold}. The reason for the un-covered code portion in this code example is that the code portion requires a delegate handler to be defined in the class. A delegate
handler can be treated as a pointer to a function. These delegates can be used
to encapsulate a method with a specific signature and return type. To achieve
100\% coverage of the \CodeIn{RemoveSetting} method in the preceding code example,
we created a trivial delegate handler and set the value to \CodeIn{Changed}.
We present details on the usage of supporting techniques in our study in Section~\ref{sec:helper}.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
00:[PexMethod]
//MSS: MemorySettingsStorage (class)
//PAUT: PexAssumeUnderTest	(Pex attribute)
//Changed is of type Delegate
01:public void RemoveSetting(MSS st,
\hspace*{0.3in}[PAUT]string settingName) \{
02:\hspace*{0.1in}st.RemoveSetting( settingName );
03:\hspace*{0.1in}if (Changed != null)
04:\hspace*{0.2in}\textbf{Changed(this, new SettingsEventArgs(settingName))};
05:\}
\end{alltt}
\end{CodeOut}
\Caption{\label{fig:handleexample} A code sample with an un-covered portion (shown in bold) with PUTs written by transforming conventional unit tests.}
\end{figure}

