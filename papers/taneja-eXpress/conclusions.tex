
\section{Discussion}

\label{sec:discussion}
In this section, we discuss some of the limitations of the current implementation of our approach and
how they can be addressed.
\textbf{Added/Deleted and Refactored Methods.} If a method $M$ (or a field $F$) is added or deleted from the original program version, \CodeIn{eXpress} does not detect $M$ (or $F$) as a changed region. The change is detected if a method call site (or reference to $F$) is added or deleted from the original program version. If the added or deleted method (or field) is never invoked, the behavior of the two versions is the same unless $M$  is an overriding method. We plan to incorporate support for such overriding methods that are added or deleted. Similarly, if a method $M$ is refactored between the two versions, \CodeIn{eXpress} does not detect $M$ as a changed region. However, when a method is refactored, its call sites are changed accordingly (unless the method undergoes \CodeIn{Pull Up} or \CodeIn{Push Down} refactoring). Hence, \CodeIn{eXpress} detects the method containing call sites of $M$ as changed. In our experiments, we considered versions of \CodeIn{replace} in which method signature was changed, and versions of \CodeIn{structorian} in which a method was renamed.
\\ \textbf{Granularity of Changed Region.} In our current approach, a changed region is the list of continuous instructions that include all the changed instructions in a method. One method can have only a single changed region. Hence, a changed region can be as big as a method and as small as a single instruction. The granularity of a changed region can be increased to a single method or reduced to single instruction. Changing the granularity to single method $M$ can affect the efficiency of our approach in reducing DSE runs since some of the branches in $M$ that should be considered irrelevant would not be considered irrelevant. In contrast, reducing the granularity to a single instruction makes our approach more efficient in reducing DSE runs. However, the overhead cost of our approach is increased due to state checking at multiple points in the program. In future work, we plan to enhance \CodeIn{eXpress} to allow users to choosse from different levels of granularity. 
\\ \textbf{Original/Modified Program Version.} In our current approach, we perform DSE on the new version of a program. We then execute the test (generated after each run) on the new version. We can also perform DSE on the original version instead of the new version. One approach may be efficient than the other depending on the types of changes made to the program. In future work, we plan to conduct experiments to compare the efficiency of the two approaches with respect to the types of changes. 
\\ \textbf{Branch Prioritization.} \CodeIn{eXpress} currently prunes branches that cannot help in detecting behavioral differences between the two versions. However, some branches in the program code can be more promising in detecting behavioral differences than others. Branching nodes can be prioritized based on the distance of the branching node to a changed region in the CFG. The distance $d(n1, n2)$ between any two nodes $n1$ and $n2$  in a CFG $g$ is the number of nodes with degree > 1 between $n1$ and $n2$ in the shortest path between $n1$ and $n2$. Hence, the distance between a node $b$ and a changed region $\Delta$ is the number of nodes with degree of more than one between $b$ and the node representing the first instruction in $\Delta$. The intuition behind this prioritization is that shorter the distance between the branching node and $\delta$, it is likely to be easier to generate inputs to cause the execution of the changed region $\delta$. This kind of branch prioritization is used by Burnim and Sen~\cite{burnim}. We can also prioritize branching nodes based on the probability to cause infection and to propagate the infection to an observable output. Moreover, we can prioritize branches based on data dependence from a changed region.
\\ \textbf{Pruning of Branches for Propagation.} Currently, \CodeIn{eXpress} prunes branches that cannot help satisfy E or I of the PIE model for change propagation. In future work, we plan to prune more categories of branches that cannot help in Propagation (P). Consider that a changed region is executed and the program state is infected after the execution of the changed region; however, the infection is not propagated to any observable output. Let $\chi$ be the last location in the execution path such that the program state is infected before the execution of $\chi$ but not infected after its execution. $\chi$ can be determined by comparing the value spectra~\cite{xie05:spectra, xie05:checking} obtained by executing the test on both versions of the program. This category contains all the branching nodes after the execution of $\chi$. These branches can be obtained by inspecting the path $P$ followed in the previous DSE run. Let $P = <b_1, b_2,.., b_\chi...b_n>$, where $b_i$ are the branching nodes in the Path $P$, while $b_\chi$ is the last instance of branching node containing $\chi$. We do not flip the branching nodes from $b_\chi$ to $b_n$ in $P$ until if the program state is not propagated after the execution of $\chi$.
\Comment{
\\ \textbf{Changes in Fields.} Currently, \CodeIn{eXpress} does not detect changes in program code that is outside method bodies. For example, if the declaration of a field $f$ is modified, \CodeIn{eXpress} cannot help in reducing DSE runs to detect behavioral differences that may be introduced in the program due to the change. In such situations, the source code can be searched to find the references of $f$. The corresponding instructions for all these statements referring to $f$ can be considered as changed. If a field is added or deleted, \CodeIn{eXpress} can still be helpful in reducing DSE runs as in the case of added or deleted methods as discussed earlier in this section.
}

\section{Conclusion}
\label{sec:conclusion}
Regression testing aims at generating tests that detect behavioral differences between two versions of a software program. Dynamic symbolic execution (DSE) can be used to generate such difference exposing tests. DSE explores paths in the program to achieve high structural coverage, and exploration of all these paths can often be expensive. However, many of these paths in the program cannot help in detecting behavioral differences in any way. In this paper, we presented an approach and its implementation called \CodeIn{eXpress} for regression test generation using DSE. \CodeIn{eXpress} prunes paths or branches that cannot help in detecting behavioral differences such that behavioral differences are more likely to be detected earlier in path exploration. In addition, our approach can exploit the existing test suite for the original version to efficiently cover the changed regions (if not already covered by the test suite). 
Experimental results on various versions of programs showed that our approach can efficiently detect behavioral differences than without using our approach. 
\Comment{
\section*{Acknowledgments}
This work is supported in part by NSF grant CCF-0725190 and ARO grant W911NF-08-1-0443.
}