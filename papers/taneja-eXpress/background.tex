\section{Dynamic Symbolic Execution}
In our approach, we use Pex~\cite{Pex} as a DSE-based tool. Pex starts program exploration with some default inputs. Pex then collects constraints on program inputs from the predicates at the branching statements executed in the program. We refer to these constraints at branching statements as branch conditions. 
The conjunction of all branch conditions in the path followed during execution of an input is referred to as a path constraint. Pex keeps track of the previous executions to build a dynamic execution tree. Pex, in the next run, chooses one of the unexplored branch in the execution tree (dynamically discovered thus far). Pex flips the chosen branching node in the dynamic execution tree to generate a new input that follows a new execution path. Pex uses various heuristics~\cite{fitnex} for choosing a branching node (to flip next) in the execution tree using various search strategies with an objective of achieving high code coverage fast.
 
