\section{Dynamic Symbolic Execution}
In our approach, we use Pex~\cite{Pex} as an engine for Dynamic Symbolic Execution (DSE). Pex starts program exploration with some default inputs. Pex then collects constraints on program inputs from the predicates at the branching statements executed in the program. We refer to these constraints at branching statements as branch conditions. 
The conjunction of all branch conditions in the path followed during execution of an input is referred to as a path constraint. Pex keeps track of the previous executions to build a dynamic execution tree. Pex, in the next run\footnote{A run is an exploration iteration.}, chooses one of the unexplored branch in the execution tree (dynamically built thus far). Pex flips the chosen branching node in the dynamic execution tree to generate a new input that follows a new execution path. 
Pex uses various heuristics~\cite{fitnex} for choosing a branching node (to flip next) in the execution tree using various search strategies with an objective of achieving high code coverage fast. We next present definitions of some of the terms that we use in the rest of this paper.
\\ \textbf{Discovered node. }We refer to all the branching nodes that are executed in the current DSE run but were not executed in previous runs as discovered branching nodes (in short as discovered nodes).
\\ \textbf{Instance of a branching node. }A branching node $c_i$ in a Control Flow Graph (CFG) of a program can be present multiple times in the dynamic execution tree (of the program) due to loops in the program. We refer to these multiple branching nodes in the tree as instances of $c_i$.
 
