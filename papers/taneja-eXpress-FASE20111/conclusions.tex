
\section{Discussion}

\label{sec:discussion}
In this section, we discuss some of issues of the current implementation of our approach and
how they can be addressed.
\\ \textbf{Added/Deleted and Refactored Methods.} If a method $M$ (or a field $F$) is added or deleted from the original program version, \CodeIn{eXpress} does not detect $M$ (or $F$) as a changed region. The change is detected if a method call site (or reference to $F$) is added or deleted from the original program version. If the added or deleted method (or field) is never invoked, the behavior of the two versions is the same unless $M$  is an overriding method. We plan to incorporate support for handling such overriding methods that are added or deleted. Similarly, if a method $M$ is refactored between the two versions, \CodeIn{eXpress} does not detect $M$ as a changed region. However, when a method is refactored, its call sites are changed accordingly (unless the method undergoes \CodeIn{Pull Up} or \CodeIn{Push Down} refactoring). Hence, \CodeIn{eXpress} detects the method containing call sites of $M$ as changed. In our experiments, we considered versions of \CodeIn{replace} in which a method signature was changed, and versions of \CodeIn{structorian} in which a method was renamed.
\\ \textbf{Granularity of Changed Region.} In our current implementation, a changed region is the list of continuous instructions that include all the changed instructions in a method. One method can have only a single changed region. Hence, a changed region can be as big as a method and as small as a single instruction. The granularity of a changed region can be increased to a single method or reduced to single instruction. Changing the granularity to single method $M$ can affect the efficiency of our approach in reducing DSE runs since some of the branches in $M$ that should be considered irrelevant would not be considered irrelevant. In contrast, reducing the granularity to a single instruction makes our approach more efficient in reducing DSE runs. However, the overhead cost of our approach is increased due to state checking at multiple points in the program. In future work, we plan to enhance \CodeIn{eXpress} to allow users to choose from different levels of granularity. 
\\ \textbf{Original/New Program Version.} In our current implementation, we perform DSE on the new version of a program. We then execute a test (generated after each run) on the original version. We can also perform DSE on the original version instead of the new version. One approach may be efficient than the other depending on the types of changes made to the program. In future work, we plan to conduct experiments to compare the efficiency of the two approaches with respect to the types of changes. 
%\\ \textbf{Branch Prioritization.} \CodeIn{eXpress} currently prunes branches that cannot help in achieving E or I conditions in the PIE model. However, some branches in the program code can be more promising in achieving these conditions than others. Branching nodes can be prioritized based on the distance of a branching node to a changed region in the CFG. The distance $d(n1, n2)$ between any two nodes $n1$ and $n2$  in a CFG $g$ is the number of nodes with degree > 1 between $n1$ and $n2$ in the shortest path between $n1$ and $n2$. Hence, the distance between a node $b$ and a changed region $\Delta$ is the number of nodes with degree of more than one between $b$ and the node $\delta$ representing the first instruction in $\Delta$. The intuition behind this prioritization is that shorter the distance between the branching node and $\delta$ the easier it is to generate inputs to cause the execution of the changed region $\delta$. This kind of branch prioritization is used by Burnim and Sen~\cite{burnim} for achieving high structural coverage. We can also prioritize branching nodes based on the probability to cause infection and to propagate the infection to an observable output. Moreover, we can prioritize branches based on data dependence from a changed region.
\\ \textbf{Pruning of Branches for Propagation.} In future work, we plan to prune more categories of branches that cannot help in Propagation (P). Consider that a changed region is executed and the program state is infected after the execution of the changed region; however, the infection is not propagated to any observable output. Let $\chi$ be the last location in the execution path such that the program state is infected before the execution of $\chi$ but not infected after its execution. $\chi$ can be determined by comparing the value spectra~\cite{xie05:checking} obtained by executing the test on both versions of the program. This category contains all the branching nodes after the execution of $\chi$. These branches can be obtained by inspecting the path $P$ followed in the previous DSE run. Let $P = <b_1, b_2,.., b_\chi...b_n>$, where $bi$ is the a  branching node in Path $P$, while $b_\chi$ is the last branching node containing $\chi$. We flip the branching nodes starting from $b_\chi$ to $b_n$ in $P$ until a branching node where the infected program state is propagated.
\Comment{
\\ \textbf{Changes in Fields.} Currently, \CodeIn{eXpress} does not detect changes in program code that is outside method bodies. For example, if the declaration of a field $f$ is modified, \CodeIn{eXpress} cannot help in reducing DSE runs to detect behavioral differences that may be introduced in the program due to the change. In such situations, the source code can be searched to find the references of $f$. The corresponding instructions for all these statements referring to $f$ can be considered as changed. If a field is added or deleted, \CodeIn{eXpress} can still be helpful in reducing DSE runs as in the case of added or deleted methods as discussed earlier in this section.
}

\section{Conclusion}
\label{sec:conclusion}
Regression testing aims at generating tests that detect behavioral differences between two versions of a program. To expose behavioral differences, a test execution needs to satisfy the conditions: Execution (E), Infection (I), and Propagation (P), as stated in the PIE model~\cite{voas}. Dynamic symbolic execution (DSE) can be used to generate tests for satisfying these conditions. DSE explores paths in the program to achieve high structural coverage, and exploration of all these paths can often be expensive. However, many of these paths in the program cannot help in satisfying the three conditions in any way. In this paper, we presented an approach and its implementation called \CodeIn{eXpress} for regression test generation using DSE. \CodeIn{eXpress} prunes paths or branches that cannot help in detecting the E, I, or P condition such that these conditions are more likely to be satisfied earlier in path exploration. In addition, our approach can exploit the existing test suite for the original version to efficiently execute the changed regions (if not already covered by the test suite). 
Experimental results on various versions of programs showed that our approach can efficiently satisfy E, I, or P conditions than without using our approach. 
\Comment{
\section*{Acknowledgments}
This work is supported in part by NSF grant CCF-0725190 and ARO grant W911NF-08-1-0443.
}