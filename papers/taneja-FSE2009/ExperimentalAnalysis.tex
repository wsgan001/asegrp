\section{Experimental Analysis}
\label{Experimental}

\subsection{Initial analysis}

The HTML file, ``examples.htm'',  presents experimental results of testing different versions of validators for zip code, email, and phone. The first two columns of each table list names of compared methods. The third column lists the relation between compared methods. Number 0 stands for that JUnitFactory does not generate test data that induces different behavior of tested validators. Number 2 stands for that JUnitFactory generates test data that passes the second validator but rejected by the first validator. Number 3 stands for the opposite situation of number 2, i.e.,  JUnitFactory generates test data that was passed the first validator but ok by the second validator. The forth and fifth columns list test data, which are generated by JUnitFactory.

To identify whether two validators have different behaviors, we write test driver for each pair of validators. The following code is an example of our test driver. In this example, \verb|Validator1| and \verb|Validator2| are two versions of the same type of validators. We first invoke the constructors of \verb|Validator1| and \verb|Validator2| to create these objects. Next we invoke validation methods of \verb|Validator1| and \verb|Validator2|, i.e., \verb|isValid(String s)|, and compare the returned value of validation methods. If a string \verb|s| makes \verb|Validator1| return true, while  \verb|Validator2| returns false, that means there exists input data that can be accepted by \verb|Validator1| but rejected by \verb|Validator2|, i.e., the relation between \verb|Validator1| and \verb|Validator2| is number 3. Otherwise, we determine whether the relation is number 2 by checking whether the string \verb|s| makes \verb|Validator1| return false, while  \verb|Validator2| returns true. We use JUnitFactory to generate test data for our test driver. JUnitFactory generates test data for a tested method in such a way that the test data help to cover as many branches as possible in the tested method. So if JUnitFactory can generate test data that cover the branches in \verb|compare (String s)|, that means there exists relation 2 or 3 between \verb|Validator1| and \verb|Validator2|.

\begin{verbatim}
public String compare (String s){		
    String relation = ``neither V1 nor V2'';
    Validator1 v1 = new Validator1();
    Validator2 v2 = new Validator2();

		if (v1.isValid(s) && !v2.isValid(s)) {
			relation = ``V1 but not V2'';
		} 
		if (!v1.isValid(s)	&& v2.isValid(s)) {
		  relation = ``V2 but not V1'';
		}
		if (v1.isValid(s) && v2.isValid(s))
		{
		  relation = ``V1 and V2'';
		}
		return relation;
	}
}
\end{verbatim}

We tested 7 validators of zip code, 6 validators of email, and 5 validators of phone number. Each validator is compared with all the other validators in the same type. Based on the experimental results shown in ``examples.htm'', we can observe the following facts:

{\bfseries Zip-code validators}

\verb|com.arcmind.jsfquickstart.validation.ZipCodeValidator| 
can accept more formats of zip code than the others. 

\verb|com.arcmind.jsfquickstart.validation.ZipCodeValidator| 
allows that a zip code consists of 9 digits, and the first 5 digits are separated from the last 4 digits by ``-'', ``|'', and `` ''.  

The constraint of 
\verb|simple.ZipCodeValidator| 
is the tightest. It cannot accept nine-digits zip code. 

{\bfseries  Email validators}

\verb|com.dreams.united.client.EmailValidator| 
cannot detect the absence of ``@'', which should be mandatory in an email address.

\verb|com.niftybox.valid.EmailValidator| 
checks the existence of ``@'', but it checks only whether there is ``@'' in an email address. 

\verb|com.ecyrd.jspwiki.ui.InputValidator| 
can accept blank string. 

\verb|com.axiomos.util.EmailValidator| 
uses a regular expression to validate email addresses, but it uses a wrong format of a regular expression that makes an invalid email address passes its validation.

{\bfseries  Phone validators}

\verb|edu.sdsc.utility.services.validation.FormInputValidator|  
checks whether input data are digits, but it does not check the length of the digits. 

\verb|org.tigris.atlas.validate.PhoneNumberValidator|
does not check whether input data is empty, and 

\verb|net.sf.hippopotam.presentation.field.validator.|

\verb|PhoneValidator| 
does not check whether input data is a blank string. 




%\begin{figure*}
%\centering
%\includegraphics[scale=0.38,clip]{zipcode_v}
%\caption{Test data for validators of zip code}  
%\label{fig:zipcode}
%\end{figure*}

%\begin{figure*}
%\centering
%\includegraphics[scale=0.42,clip]{email_v}
%\caption{Test data for validators of email}  
%\label{fig:email}
%\end{figure*}

%\begin{figure*}
%\centering
%\includegraphics[scale=0.38,clip]{phone_v}
%\caption{Test data for validators of phone number}  
%\label{fig:phone}
%\end{figure*}

\subsection{Analysis of the seven types}

Figure~\ref{fig:id-ssn} presents the input-domain relationship of five SSN validators.
The ``com'' and ``simple'' have no intersection, because ``com'' requires a SSN must be separated by ``-'' for the first digits and the second two digits, such as 123-45-6789, but ``simple'' requires a SSN must consist of digits without any other characters. Furthermore, ``simple'' multiply each even digit by two. If the result is a two-digits number, ``simple'' only keep the second digit. Then, ``simple'' add the results of multiplication (one-digit numbers), and checks whether the sum is dividable by 10. The ``org'' can accept SSN with or without separators, and the separators can be ``-'' or `` ''. The ``webwork'' also can accept SSN with or without separators, but it can accept `` ''. The ``edu'' does not allow there is any separator in a SSN, and it fails in making sure that a SSN has nine digits.

\begin{figure}
\centering
\includegraphics[scale=0.38,clip]{id-ssn}
\caption{Input-domain relationship of SSN validators}  
\label{fig:id-ssn}
\end{figure}

Figure~\ref{fig:id-phone} presents the input-domain relationship of seven phone-number validators.
The ``Valjaxfax'' has the tightest constraint, because it accepts only two formats of phone numbers: one consists of 10 numbers, and the other has two ``-'' as separators after the first and second three digits, such as 123-456-7890. All of the other phone-number validators can accept some special input data. The ``hippopotam'' does not check whether the input data is `` ''. The ``tigris'' allows more kinds of separators. Specially, the ``tigris'' allows the first three digits are surrounded by parenthesis, i.e. a phone-number that looks like (123)456-7890 can pass the validation of the ``tigris''. The ``Sdsc'' also allows the first three digits are surrounded by parenthesis, but it fails in checking the digit of a phone number. For example, it accepts ``1'' as a phone number. The ``valjax'' allows an extension number after a 10-digits phone number, such as 123-456-7890x12345. The ``jr'' and ``jrinternational'' are equivalent. They can accept normal phone numbers, but they do not filter invalid characters.

\begin{figure}
\centering
\includegraphics[scale=0.3,clip]{id-phone}
\caption{Input-domain relationship of phone-number validators}  
\label{fig:id-phone}
\end{figure}

Figure~\ref{fig:id-zip} presents the input-domain relationship of eight zip-code validators.
The ``developerworks'' and ``simple'' are equivalent, and they have the tightest constraint. They can accept only five-digits zip code.  The ``tigris'', ``inversoft'', and ``valjax'' are equivalent, and they can accept both five-digits and nine-digits zip code. The ``arcmind'' can accept more formats of zip code than the preceding ones, because it allows that, if a zip code consists of nine digits, and the first five digits can be separated from the last four digits by ``-'', ``|'', or `` ''. The ``default'' and ``org'' are equivalent, and they allow more types of seperators for nine-digits zip code, such as ``\$''.

\begin{figure}
\centering
\includegraphics[scale=0.3,clip]{id-zip}
\caption{Input-domain relationship of zip-code validators}  
\label{fig:id-zip}
\end{figure}

Figure~\ref{fig:id-url} presents the input-domain relationship of six URL validators.
The ``tapestry'', ``de'', and ``commons'' have imply relationship one by one. The ``commons'' requires that a URL starts with ``http'', ``https'', or ``ftp''. The ``de'' allows more kinds of beginning of a URL than ``commons'', and it requires that there must be at least one ``.'' in a URL. The ``tapestry'' has no such constraint. The ``simple1'' allows ``,'' in a URL, which is not allowed in the other URL validators. The ``com'' requires that a ULR stars with ``http://'', and consists of letters, numbers, ``?'', and ``=''. The ``simple2'' does not require special beginning of a URL. Compared with the ``tapestry'', the ``simple2'' is tighter, because the ``tapestry'' allows more special characters than the ``simple2'', such as ``!'' and ``\_''.

\begin{figure}
\centering
\includegraphics[scale=0.3,clip]{id-url}
\caption{Input-domain relationship of URL validators}  
\label{fig:id-url}
\end{figure}

Figure~\ref{fig:id-date} presents the input-domain relationship of date validators.
We divide the date validators into four groups, that are two month validators, four year validators, four date validators (containing month, day, and year), and two date validators whose input should be three ``int'' value. 
For the month validators, the ``com'' fails in filetrating ``0''.
For the year validators, the ``nl'' requires a year after 1900; the ``net'' requires a four-digits number; the ``hrdx'' requires that the year should be a leap year, but it fails in filetrating ``0''; the ``com'' requres a year between 1950 to 2099, but it can accept two-digits number. 
For the date validators, the ``edu'' requires that a date conforms to  the format of ``mm/dd/yyyy'', and the month and day must have two-digits; the ``net'' does not require two-digits month and day; the ``gr'' does not require two-digits month and day, and allows two-digits year; the ``org'' requires  two-digits month and day, and four-digits year. Further more, except ``org'', the other date validators check whether the month is between 1 to 12, and day is between 1 to 31. 
For the two special date validators taking int values as input, the ``hrdx'' fails in filetrating minus value, while the ``mo'' requires a Julian day.

\begin{figure}
\centering
\includegraphics[scale=0.3,clip]{id-date}
\caption{Input-domain relationship of date validators}  
\label{fig:id-date}
\end{figure}

Figure~\ref{fig:id-credit} presents the input-domain relationship of 11 credit-card-number validators.
The situation for credit-card-number validators is more complex than the preceding validators. All of the credit-card-number validators can accept normal 16-digits credit-card number. However, almost each of them can accept  some special string. The ``Niftybox'' has the smallest input domain, and it accepts only 16-digits credit-card number without seperators; the ``Jwarp'' allows that there are separators among 16-digits credit-card numbers. The ``Niftybox'' and ``Jwarp'' implies ``Strecks'', because the ``Strecks'' fails in filter empty string. The ``jr'' succeeds in filtering empty string, and allows more types of credit-card number, such as 13-digits number or 15-digits number, but it fails in checking the length of the number. For example, the ``jr'' can accept two-digits number. The ``Luhn'' and ``Mo'' are equivalent, and fail in checking the length of a credit-card number either. The ``Wicket'' intersects with the ``Luhn'', ``Mo'', and ``Jr'', because its LUHN algorithm is a different with that implemented by ``Luhn'' and ``Mo''. The ``Baycloud'', ``Commons'', and ``Myface'' are equivalent, and intersect with  the ``Sum'', since the three equivalent validators require that the length of a credit-card number should be between 14 to 18 digits, and the ``sum'' requires that the length of a credit-card number is longer than 14 digits.


\begin{figure}
\centering
\includegraphics[scale=0.3,clip]{id-credit}
\caption{Input-domain relationship of credit-card-number validators}  
\label{fig:id-credit}
\end{figure}

Figure~\ref{fig:id-email} presents the input-domain relationship of 12 Email-address validators. These Email-address validators are in a similar situation as the credit-card-number validators. Among the ``Niftybox'', ``Axiomos'',  ``Duguo'', and ``Sdsc'', there are imply relations, and their input domains are shrinking one by one.  The ``Niftybox'' requires that there is at least one ``@'' in an Email address. In addition to a ``@'', the ``Axiomos'' requires that there is at least one ``.'' in an Email address. The ``Duguo'' requires that an Email address contains one ``@'', at least one dot, and ending with two to four letters or digits after the last dot. Furthermore, the ``Sdsc'' does not allow an Email address starting with dot. Among the ``Ecyrd'',  ``Hippopotam'', ``Nl'', and ``Sdsc'', there are imply relations, and their input domains are shrinking one by one. The ``Ecyrd'' allows characters besides letters, numbers, and ``-'' in an Email address, e.g. ``+''. The ``Nl'' implies the ``Hippopotam'', because the ``Hippopotam'' does not restrict that the characters after the last dot should be letters or digits, which is required by the ``Nl''. The ``Sdsc'' implies the ``Nl'', because the ``Nl'' reuses the same validation function as what ``Sdsc'' uses, but the ``Nl'' can allows empty string. The ``Sun'' has an intersection with the ``Duguo'', because the ``Sun'' allows characters besides letters, numbers, and ``-'' in an Email address,  and it requires that both the name part (the substring before ``@'') and the domain part (the substring after ``@'') in an Email address cannot start or end with a dot. The input domain of the ``Edu'' is smaller than the ``Sun'''s, because the ``Edu'' filters the characters that are not letter, number, or ``-''. The ``Citep'' and ``Talnet'' have the smallest input domains among our tested Email-address validators, because they explicitly define that the number of chareacters after the last dot should be two to four, and for the ``Talnet'', one to three characters are also acceptable. The ``Dreams'' accepts a string without ``@'', but it filtering empty string and special characters, such as ``+''. Therefor, the ``Dreams'' has intersections with most other validators. 

\begin{figure}
\centering
\includegraphics[scale=0.38,clip]{id-email}
\caption{Input-domain relationship of Email-address validators}  
\label{fig:id-email}
\end{figure}