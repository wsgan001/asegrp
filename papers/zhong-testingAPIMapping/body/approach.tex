\section{Approach}
\label{sec:approach}
\begin{figure}[t]
\centering
\includegraphics[scale=1,clip]{figure/approach.eps}\vspace*{-3ex}
 \caption{Overview of TeMAPI}\vspace*{-4ex}
 \label{fig:approach}
\end{figure}
Given a translation tool between Java and C\#, TeMAPI generates various test cases to reveal behavior differences of the tool's API mapping relations.
Figure~\ref{fig:approach} shows the overview of TeMAPI. It is able to test not only mapping relations of a single API class but also mapping relations of multiple API classes.


%-------------------------------------------------------------------
\subsection{Synthesizing Wrappers for Translation}
\label{sec:approach:generating}
Given a translation tool, TeMAPI first extracts its API mapping relations. To deal with different styles of translation tools as described in Section~\ref{sec:introduction}, TeMAPI does not extract API mapping relations directly from translation tools, but chooses to analyze translated code of translation tools.  Translating existing applications address the problem partially for two major reasons. (1) Many API mapping relations cannot be covered, since applications typically use a small portion of API elements. (2) In existing applications, a single method often invokes multiple API methods. When an API method is translated into multiple methods,  it is difficult to extract mapping relations. For the preceding reasons, TeMAPI relies on the reflection technique~\cite{maes1987concepts} provided by both Java and C\# to synthesize wrapper methods for translation. Each wrapper method uses only one field or method, so TeMAPI can extract translatable API elements in the finest level. In particular, TeMAPI synthesizes wrapper methods for static fields and methods as follows:

\textbf{Static fields.} Given a public static field \CodeIn{f} of a class \CodeIn{C} whose type is \CodeIn{T}, TeMAPI synthesizes a getter as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
 public T TestGet|f.name||no|()\{ return C.f; \}
\end{alltt}
\end{CodeOut}\vspace*{-1ex}

If \CodeIn{f} is not a constant, TeMAPI synthesizes a setter as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
 public void TestSet|f.name||no|(T v)\{ C.f = v; \}
\end{alltt}
\end{CodeOut}\vspace*{-1ex}

\textbf{Static methods.} Given a public static method \CodeIn{m(T1\ p1,\ldots,Tn\ pn)} of a class \CodeIn{C} whose return type is \CodeIn{Tm}, TeMAPI synthesizes a wrapper method as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
 public Tm Test|m.name||no|(T1\ m1,\ldots, Tn\ mn)\{
   return C.m(m1,\ldots, mn); \}
\end{alltt}
\end{CodeOut}\vspace*{-1ex}

When TeMAPI synthesizes wrapper methods for non-static fields or methods, it takes constructor into considerations:

\textbf{Non-static fields.} Given a public non-static field \CodeIn{f} of a class \CodeIn{C} whose type is \CodeIn{T}, TeMAPI synthesizes a getter for each constructor \CodeIn{C(T1\ p1,\ldots, Tn\ pn)} of \CodeIn{C} as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
 public T TestGet|f.name||no|(T1\ c1,\ldots, Tn\ cn)\{
    C obj = new C(c1,\ldots, cn);
    return obj.f; \}
\end{alltt}
\end{CodeOut}\vspace*{-1ex}

If \CodeIn{f} is not a constant, TeMAPI synthesizes a setter as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
 public void TestSet|f.name||no|(T1\ c1,\ldots, Tn\ cn)\{
   C obj = new C(c1,\ldots, cn);
   obj.f = v; \}
\end{alltt}
\end{CodeOut}\vspace*{-1ex}

Here, ``\CodeIn{|f.name|}'' denotes the name of \CodeIn{f}, and ``\CodeIn{|no|}'' denotes the corresponding number of synthesized wrapper method.

\textbf{Non-static methods.} Given a public non-static method \CodeIn{m(T1\ p1,\ldots,Tn\ pn)} of a class \CodeIn{C} whose return type is \CodeIn{Tm}, TeMAPI synthesizes a wrapper method for each constructor \CodeIn{C(Tv\ pv,\ldots, Tt\ pt)} of \CodeIn{C} as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
 public Tm Test|m.name||no|(T1\ m1,\ldots, Tn\ mn,
                            Tv cv, \ldots, Tt ct)\{
   C obj = new C(cv,\ldots, ct);
   return obj.m(m1,\ldots, mn); \}
\end{alltt}
\end{CodeOut}\vspace*{-1ex}

Here, ``\CodeIn{|m.name|}'' denotes the name of \CodeIn{m(T1\ p1,\ldots,Tn\ pn)}.

TeMAPI put all synthesized wrapper methods for one API class $C$ into one synthesized class. For a Java-to-C\# tools, TeMAPI synthesizes wrapper methods in Java as shown by the solid line in Figure~\ref{fig:approach}, and for a C\#-to-Java tools, TeMAPI synthesizes wrapper methods in C\# as shown by the dotted line in Figure~\ref{fig:approach}. When synthesizing, TeMAPI ignores generic methods for simplicity. Besides, for C\#, it ignores \CodeIn{unsafe} and \CodeIn{delegate} methods and methods whose parameters are marked as \CodeIn{out} or \CodeIn{ref}. Java does not have corresponding keywords, so existing tools typically do not translate them. After wrappers are synthesized, we translate them using a translation tool under analysis.

After synthesized code is translated, TeMAPI parses translated code and removes translated wrapper methods with compilation errors. For Java code, TeMAPI extends Eclipse's Java compiler for the list of compilation errors. For C\# code, TeMAPI extracts the list of compilation errors through the automation and extensibility interfaces of Visual Studio. For Java-to-C\# tools, we refer to the remaining C\# wrapper methods as safe wrappers. For C\#-to-Java tools, we refer to the synthesized C\# wrapper methods that can be translated without compilation errors as safe wrappers. As wrappers reveal behaviors of a given class at the finest level and expose interfaces for inputs and outputs, TeMAPI further uses safe wrappers to test behavior differences for single API classes (Section~\ref{sec:approach:single}). Comparing safe wrappers with synthesized wrappers, TeMAPI can extracts the list of translatable API elements for a given translation tool. Using the list, TeMAPI further tests behavior difference for multiple API classes (Section~\ref{sec:approach:sequence}).


%for validate API mapping relations of the translation tool. To achieve this, TeMAPI first remove all translated methods with compilation errors. For translated methods in Java, TeMAPI implements a Eclipse plug-in that uses on Eclipse JDT compiler\footnote{\url{http://www.eclipse.org/jdt/}} for the list of compilation errors. For translated methods in C\#, TeMAPI implements a Visual Studio.Net add-in to retrieve the list of compilation errors from the error-list view of Visual Studio.Net. Both Eclipse JDT compiler and Visual Studio.Net cannot list all methods with compilation errors in a single build. After each iteration of removing methods, TeMAPI re-build these methods until it removes all methods with compilation errors.
%
%After methods with compilation errors are removed, TeMAPI compares synthesized code with translated code for the validate API mapping relations of a translation tool. Based on translated code and validate API mapping, TeMAPI removes synthesized methods whose corresponding translated methods have compilation errors. We refer to those removing wrapper methods as safe methods.


%-----------------------------------------------------------------
\subsection{Testing Single API Classes}
\label{sec:approach:single}

Pex~\cite{tillmann2008pex} is a white-box test generation tool for .Net based on dynamic symbolic execution. Basically, Pex repeatedly executes a method under test, so that it explores all feasible paths of the method. To reduce the efforts to explore paths, Pex leverage various search strategies. For example, Xie \emph{et al.}~\cite{xie09:fitness} propose a search strategy called Fitnex that uses state-dependent fitness values to guide path exploration of Pex.

TeMAPI extends Pex, so that it generates test cases for detecting behavior differences of single classes. In particular, for each API class, TeMAPI leverages Pex to search paths of each its safe wrapper, and records the inputs and the corresponding output when Pex searches each path. Based on recorded inputs and outputs, TeMAPI generates Java test cases to ensure each mapped API elements produce the same output give the same inputs. To check outputs, TeMAPI checks whether their values are equal for primitive types and arrays, and checks whether each mapped fields are equal for objects. For example, TeMAPI records that given an empty object, the \CodeIn{testappend175nm} wrapper method in C\# return a \CodeIn{StringBuilder} object whose \CodeIn{Capacity} field is 16 and \CodeIn{Length} field is 13, so TeMAPI generates a test case for the corresponding Java wrapper method as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
public void testappend175nm122()\{
  sketch.Test_java_lang_StringBuffer obj =
      new sketch.Test_java_lang_StringBuffer();
  Object m0 = new Object();
  StringBuffer out = obj.testappend175nm(m0);
  Assert.assertEquals(16, out.capacity());	
  Assert.assertEquals(13, out.length());
\}
\end{alltt}
\end{CodeOut}\vspace*{-2ex}

This test case fails, since here the \CodeIn{capacity()} method returns 34 and the \CodeIn{length()} method returns 24. Thus, TeMAPI detects two behavior differences between the \CodeIn{java.lang.StringBuffer} class in Java and the \CodeIn{System.Text.StringBuilder} class in C\#.


We find that when Pex searches a path with some specific inputs, the method under test throws exceptions.
For example, TeMAPI records that if the input of the \CodeIn{TestvalueOf61sm} wrapper method in C\# is null, the method throws \CodeIn{NullReferenceException}, so it generates a Java test case to ensure the corresponding Java wrapper method also throws a mapped exception. To generate the Java test case, TeMAPI first finds the corresponding exceptions in Java by analyzing translated wrapper methods with synthesized code. For example, TeMAPI finds that the \CodeIn{NullReferenceException} class in C\# is mapped to the \CodeIn{NullPointerException} class in Java with respect to the API mapping relations of Java2CSharp, so it generates a Java test case as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
 public void testvalueOf61sm3()\{
   try\{
     sketch.Test_java_lang_String obj =
           new sketch.Test_java_lang_String();
     java.lang.Object m0 = null;
     obj.testvalueOf61sm(m0);
   \}catch(java.lang.NullPointerException e)\{
     Assert.assertTrue(true);
     return;
   \}
   Assert.assertTrue(false); \}
\end{alltt}
\end{CodeOut}\vspace*{-1ex}

This Java test case fails since the \CodeIn{testvalueOf61sm} method does not throw any exceptions given a null input.
From this failed Java test case, TeMAPI detects the behavior difference between the \CodeIn{java.lang.String.valueOf(Object)} method in Java and the \CodeIn{System.Object.ToString()} method in C\#, since the preceding two wrapper methods are for the two API methods only.

%-----------------------------------------------------------
\subsection{Testing Multiple Classes}
\label{sec:approach:sequence}
As each wrapper method uses only one field or one method of a given API class, it may lose some behavior differences that involve multiple classes. To test multiple classes, TeMAPI first extracts translatable API elements by comparing safe wrappers with synthesized wrappers. For example, as shown in Section~\ref{sec:example}, the C\# \CodeIn{testskip24nm} method is a safe wrapper, so all API methods wrapped in the corresponding Java wrapper are translatable. TeMAPI  then adds its wrapped \CodeIn{BufferedInputStream(Input- Stream)} constructor and the \CodeIn{BufferedInputStream.skip(long)} method into the list of translatable API methods.

Randoop~\cite{pacheco2007feedback} is a test generation tool for Java. It randomly generates test cases based on already generated test cases in a feedback-directed manner. TeMAPI extends Randoop to test behavior differences that involve multiple classes. In particular, TeMAPI restricts the search scope of Randoop, so that its generated test cases use translatable API elements only. After that, TeMAPI runs generated test cases and removes those failed test cases. We translate the remaining test case into C\# using the translation tool under analysis. If such translation does not change behaviors, translated C\# test cases should also get passed. Thus, TeMAPI is able to detect behavior differences that involve multiple classes, and Section~\ref{sec:example} shows a detected one.


%In the final step, TeMAPI generates test cases to detect behavior differences of API mapping relations. An alternative approach is to use existing test cases in two languages. For example, lucene\footnote{\url{http://lucene.apache.org}} has both a Java version and a C\# version. It is feasible to use these test cases to reveal some behavior differences, but such test cases typically cover only a small set of APIs. Some test suites such as Java Compatibility Kit (JCK)\footnote{\url{http://jck.dev.java.net}} cover most APIs of a language. However, translating such a test suite from one language into another language may introduce many compilation errors and defects. A test method may use many APIs, so even if the API under test can be translated correctly, the test method cannot be translated correctly since other APIs are not mapped. As a result, we choose to translating


%\subsubsection{Translating Existing Test Cases}
%\label{sec:approach:behavior:jck}
%
%Each generated wrapper method uses only one fields or methods provided by API libraries, and may lose some complicated behaviors even if test cases satisfy the round-trip criterion. To test those complicated behaviors, we introduce JCK that covers many complicated behaviors of Java APIs. JCK is a test suite provided by Sun to ensure compatibility of Java platforms, and it covers most standard APIs of J2SE. However, JCK implements many internal classes to collect the results of executed test cases. If a translation tool cannot correctly translate one of these classes, all translated test cases may have compilation errors or defects. In addition, JCK is released under read-only source license\footnote{\url{http://tinyurl.com/33x9fo6}}, so many such internal classes are not shipped and it has many compilation errors. To increase the chance of migrating JCK, TeMAPI first replaces those internal classes with the classes of Java. For example, one test method for \CodeIn{java.io.File.delete()} in JCK is as follows:
%
%\begin{CodeOut}%\vspace*{-2ex}
%\begin{alltt}
%  public Status File0037()\{
%    String testCaseID = "File0037";
%    ...
%    FileRT method = new FileRT(testCaseID) \{
%     public Status run() \{
%       File f = null;
%       f = new File(workdir, testCaseID);
%       ...
%       if (f.delete()) \{ // Try to delete
%         if (!f.exists()) \{ // Does it exist?
%           return Status.passed("OKAY");
%         \}else\{
%            return Status.failed(...);
%         \}
%       else\{
%           return Status.failed(...);
%       \}
%    \}
%     return AllPermissionSM.testRun(...);
%  \}
%\end{alltt}
%\end{CodeOut}
%
%After the preceding three steps, TeMAPI further replaces the statement starts with \CodeIn{FileRT} with the body of the \CodeIn{run} method, and removes the last statement. The translated code is as follows:
%
%\begin{CodeOut}%\vspace*{-2ex}
%\begin{alltt}
%  public void File0037()\{
%    String testCaseID = "File0037";
%    ...
%    File f = null;
%    f = new File(workdir, testCaseID);
%    ...
%    if (f.delete()) \{ // Try to delete
%      if (!f.exists()) \{ // Does it exist?
%        Assert.assertTrue(true);
%        return;
%     \}else\{
%        Assert.fail();
%        return;
%     \}
%   else\{
%       Assert.fail();
%       return;
%   \}
%  \}
%\end{alltt}
%\end{CodeOut}
%
%Compared with the original test method in JCK, the translated method does not use the three internal classes: \CodeIn{Status}, \CodeIn{FileRT}, and \CodeIn{AllPermissionSM}.
%
%After the preceding process, for a translation tool, TeMAPI further removes methods that use any APIs outside its defined mapping relations. The remaining methods can be translated from Java to other languages since it does not use any APIs outside of the translation tool.


