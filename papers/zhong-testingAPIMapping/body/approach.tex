\section{Approach}
\label{sec:approach}
\begin{figure}[t]
\centering
\includegraphics[scale=1,clip]{figure/approach.eps}\vspace*{-3ex}
 \caption{Overview of TeMaAPI}\vspace*{-4ex}
 \label{fig:approach}
\end{figure}
Given a migration tool between Java and C\#, TeMaAPI generates various test cases to reveal different behaviors of the tool's API mapping relations.
Figure~\ref{fig:approach} shows the overview of TeMaAPI. It is able to test mapping relations of a single API invocation and also mapping relations of multiple API invocations.


%-------------------------------------------------------------------
\subsection{Translating Generated client code}
\label{sec:approach:generating}
Given a migration tool, TeMaAPI first extracts its validate mapping relations of APIs. It is challenging to extract such mapping relations directly from a migration tool for two factors: (1) different migration tools may follow different styles to describe API mapping relations. For example, as shown in Section~\ref{sec:introduction}, the API mapping relations of Java2CSharp are described in its mapping files, but the API mapping relations of sharpen are hard-coded in its source files. (2) commercial migration tools typically hide their API mapping relations in binary files. Due to the two factors, TeMaAPI does not extract API mapping relations directly from a migration tool, but chooses to analyze translated code of a migration tool. We choose to use migration tools to translate simple client code instead of existing projects for two considerations: (1) Existing projects typically use quite a small set of APIs, so many API mapping relations may be not covered; (2) a single method of an existing project may use multiple APIs, so it may be difficult to analyze which APIs are not mapped. For the preceding consideration, TeMaAPI chooses to generate client code instead of using existing client code.

TeMaAPI relies on the reflection technique~\cite{maes1987concepts} provided by both Java and C\# to generate client code for translation.

\textbf{Static fields.} Given a public static field \CodeIn{f} of a class \CodeIn{C} whose type is \CodeIn{T}, TeMaAPI generates a getter as follows:
\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
 public T TestGet|f.name||no|()\{ return C.f; \}
\end{alltt}
\end{CodeOut}

If \CodeIn{f} is not a constant, TeMaAPI generates a setter as follows:
\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
 public void TestSet|f.name||no|(T v)\{ C.f = v; \}
\end{alltt}
\end{CodeOut}

\textbf{Non-static fields.} Given a public non-static field \CodeIn{f} of a class \CodeIn{C} whose type is \CodeIn{T}, TeMaAPI generates a getter for each constructor \CodeIn{C(T1\ p1,\ldots, Tn\ pn)} of \CodeIn{C} as follows:
\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
 public T TestGet|f.name||no|(T1\ c1,\ldots, Tn\ cn)\{
    C obj = new C(c1,\ldots, cn);
    return obj.f; \}
\end{alltt}
\end{CodeOut}

If \CodeIn{f} is not a constant, TeMaAPI generates a setter as follows:
\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
 public void TestSet|f.name||no|(T1\ c1,\ldots, Tn\ cn)\{
   C obj = new C(c1,\ldots, cn);
   obj.f = v; \}
\end{alltt}
\end{CodeOut}

In the preceding code, ``\CodeIn{|f.name|}'' denotes the name of \CodeIn{f}, and ``\CodeIn{|no|}'' denotes the corresponding number of generated client-code method.

\textbf{Static methods.} Given a public static method \CodeIn{m(T1\ p1,\ldots,Tn\ pn)} of a class \CodeIn{C} whose return type is \CodeIn{Tm}, TeMaAPI generates a client-code method as follows:
\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
 public Tm Test|m.name||no|(T1\ m1,\ldots, Tn\ mn)\{
   return C.m(m1,\ldots, mn); \}
\end{alltt}
\end{CodeOut}

\textbf{Non-static methods.} Given a public non-static method \CodeIn{m(T1\ p1,\ldots,Tn\ pn)} of a class \CodeIn{C} whose return type is \CodeIn{Tm}, TeMaAPI generates a client-code method for each constructor \CodeIn{C(Tv\ pv,\ldots, Tt\ pt)} of \CodeIn{C} as follows:
\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
 public Tm Test|m.name||no|(T1\ m1,\ldots, Tn\ mn,
                            Tv cv, \ldots, Tt ct)\{
   C obj = new C(cv,\ldots, ct);
   return obj.m(m1,\ldots, mn); \}
\end{alltt}
\end{CodeOut}

In the preceding code, ``\CodeIn{|m.name|}'' denotes the name of \CodeIn{m(T1\ p1,\ldots,Tn\ pn)}.

TeMaAPI ignores generic methods for simplicity, and organizes all generated client code methods by the corresponding class $C$. For a migration tool that translates from Java to C\#, TeMaAPI generates client code in Java as shown by the solid line of Figure~\ref{fig:approach}, and for a migration tool that translates from C\# to Java, TeMaAPI generates client code in C\# as shown by the dotted line of Figure~\ref{fig:approach}. When TeMaAPI generates client code in C\#, it ignores \CodeIn{unsafe} and \CodeIn{delegate} methods and methods whose parameters are marked as \CodeIn{out} or \CodeIn{ref}. These methods may produce more than one output, and our generated client code has only one output. In addition, Java does not have corresponding keywords, so there are typically no mapped methods in Java for these C\# methods. After TeMaAPI generate client-code methods, we translate them using a migration tool under experiments.

After generated code is translated, TeMaAPI parses translated code and removes translated methods with compilation errors. We refer to the remaining methods as safe client code. Safe client code is testable since it has no compilation errors. Based on these methods, TeMaAPI tests single API invocations (Section~\ref{sec:approach:single}). From remaining methods, TeMaAPI analyzes which API invocations can be translated without introducing compilation errors. Thus, TeMaAPI generates a list of translatable API invocations for a given migration tool. Based on the list, TeMaAPI further tests API invocation sequences (Section~\ref{sec:approach:sequence}).


%for validate API mapping relations of the migration tool. To achieve this, TeMaAPI first remove all translated methods with compilation errors. For translated methods in Java, TeMaAPI implements a Eclipse plug-in that uses on Eclipse JDT compiler\footnote{\url{http://www.eclipse.org/jdt/}} for the list of compilation errors. For translated methods in C\#, TeMaAPI implements a Visual Studio.Net add-in to retrieve the list of compilation errors from the error-list view of Visual Studio.Net. Both Eclipse JDT compiler and Visual Studio.Net cannot list all methods with compilation errors in a single build. After each iteration of removing methods, TeMaAPI re-build these methods until it removes all methods with compilation errors.
%
%After methods with compilation errors are removed, TeMaAPI compares generated code with translated code for the validate API mapping relations of a migration tool. Based on translated code and validate API mapping, TeMaAPI removes generated methods whose corresponding translated methods have compilation errors. We refer to those removing client-code methods as safe methods.


%-----------------------------------------------------------------
\subsection{Testing Single API Invocations}
\label{sec:approach:single}

Pex~\cite{tillmann2008pex} is a white-box test generation tool for .Net based on dynamic symbolic execution. Basically, Pex repeatedly executes a method under test, so that it explores all feasible paths of the method. To reduce the efforts to explore paths, Pex leverage various search strategies. For example, Xie \emph{et al.}~\cite{xie09:fitness} propose a search strategy called Fitnex that uses state-dependent fitness values to guide path exploration of Pex. TeMaAPI extends Pex, so that it is able to generate test cases that satisfy the path criterion defined in Section~\ref{sec:mapping}. In particular, for each translated C\# client code method, TeMaAPI records the inputs and the corresponding out of each searched path of Pex to local files. Based on recorded inputs and outputs, TeMaAPI generates JUnit test cases to ensure each mapped API invocations produce the same output give the same inputs.
For example, TeMaAPI records that given a integer whose value is 0, the output of the \CodeIn{TestvalueOf57sm} method in C\# is ``0''. Based on the preceding input and output, TeMaAPI generates a JUnit test case for the \CodeIn{testvalueOf57sm} method in Java as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
@Test
public void testvalueOf57sm7()\{
  sketch.Test_java_lang_String obj =
      new sketch.Test_java_lang_String();
  int m0 = 0;
  Assert.assertEquals("0", obj.testvalueOf57sm7(m0));
\}
\end{alltt}
\end{CodeOut}

This JUnit test case runs successfully, and the result ensures that the \CodeIn{testvalueOf57sm} method in Java has the same output with the \CodeIn{TestvalueOf57sm} method in C\# given the same input.


We find that when Pex searches a path with some specific inputs, the method under test throws exceptions.
For example, TeMaAPI records that if the input of the \CodeIn{TestvalueOf61sm} method in C\# is null, the method throws \CodeIn{NullReferenceException}. TeMaAPI also generates a JUnit test case to ensure the \CodeIn{testvalueOf61sm} method in Java also throws a mapped exception. To generate the JUnit test case, TeMaAPI first finds the corresponding exceptions in Java by analyzing translated client code with generated code. For example, TeMaAPI finds that the \CodeIn{NullReferenceException} class in C\# is mapped to the \CodeIn{NullPointerException} class in Java with respect to the API mapping relations of Java2CSharp, so it generates a JUnit test case as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
 @Test
 public void testvalueOf61sm3()\{
   try\{
     sketch.Test_java_lang_String obj =
           new sketch.Test_java_lang_String();
     java.lang.Object m0 = null;
     obj.testvalueOf61sm(m0);
   \}catch(java.lang.NullPointerException e)\{
     Assert.assertTrue(true);
     return;
   \}
   Assert.assertTrue(false);
 \}
\end{alltt}
\end{CodeOut}

This JUnit test case fails since the \CodeIn{testvalueOf61sm} method does not throw any exceptions given a null input.
From this failed JUnit test case, TeMaAPI detects the different behavior between the \CodeIn{testvalueOf61sm} method in Java and the \CodeIn{TestvalueOf61sm} method in C\#. Since the two methods call only one API method, TeMaAPI thus detects the different behavior between the \CodeIn{valueOf (Object)} in Java and its mapped C\# method.

%-----------------------------------------------------------
\subsection{Testing Invocation Sequences}
\label{sec:approach:sequence}

For each safe method in Java, we use Randoop~\cite{pacheco2007feedback} to generate its test cases.

In the final step, TeMaAPI generates test cases to detect different behaviors of API mapping relations. An alternative approach is to use existing test cases in two languages. For example, lucene\footnote{\url{http://lucene.apache.org}} has both a Java version and a C\# version. It is feasible to use these test cases to reveal some different behaviors, but such test cases typically cover only a small set of APIs. Some test suites such as Java Compatibility Kit (JCK)\footnote{\url{http://jck.dev.java.net}} cover most APIs of a language. However, translating such a test suite from one language into another language may introduce many compilation errors and defects. A test method may use many APIs, so even if the API under test can be translated correctly, the test method cannot be translated correctly since other APIs are not mapped. As a result, we choose to translating


%\subsubsection{Translating Existing Test Cases}
%\label{sec:approach:behavior:jck}
%
%Each generated client-code method uses only one fields or methods provided by API libraries, and may lose some complicated behaviors even if test cases satisfy the round-trip criterion. To test those complicated behaviors, we introduce JCK that covers many complicated behaviors of Java APIs. JCK is a test suite provided by Sun to ensure compatibility of Java platforms, and it covers most standard APIs of J2SE. However, JCK implements many internal classes to collect the results of executed test cases. If a migration tool cannot correctly translate one of these classes, all translated test cases may have compilation errors or defects. In addition, JCK is released under read-only source license\footnote{\url{http://tinyurl.com/33x9fo6}}, so many such internal classes are not shipped and it has many compilation errors. To increase the chance of migrating JCK, TeMaAPI first replaces those internal classes with the classes of JUnit. For example, one test method for \CodeIn{java.io.File.delete()} in JCK is as follows:
%
%\begin{CodeOut}%\vspace*{-2ex}
%\begin{alltt}
%  public Status File0037()\{
%    String testCaseID = "File0037";
%    ...
%    FileRT method = new FileRT(testCaseID) \{
%     public Status run() \{
%       File f = null;
%       f = new File(workdir, testCaseID);
%       ...
%       if (f.delete()) \{ // Try to delete
%         if (!f.exists()) \{ // Does it exist?
%           return Status.passed("OKAY");
%         \}else\{
%            return Status.failed(...);
%         \}
%       else\{
%           return Status.failed(...);
%       \}
%    \}
%     return AllPermissionSM.testRun(...);
%  \}
%\end{alltt}
%\end{CodeOut}
%
%After the preceding three steps, TeMaAPI further replaces the statement starts with \CodeIn{FileRT} with the body of the \CodeIn{run} method, and removes the last statement. The translated code is as follows:
%
%\begin{CodeOut}%\vspace*{-2ex}
%\begin{alltt}
%  public void File0037()\{
%    String testCaseID = "File0037";
%    ...
%    File f = null;
%    f = new File(workdir, testCaseID);
%    ...
%    if (f.delete()) \{ // Try to delete
%      if (!f.exists()) \{ // Does it exist?
%        Assert.assertTrue(true);
%        return;
%     \}else\{
%        Assert.fail();
%        return;
%     \}
%   else\{
%       Assert.fail();
%       return;
%   \}
%  \}
%\end{alltt}
%\end{CodeOut}
%
%Compared with the original test method in JCK, the translated method does not use the three internal classes: \CodeIn{Status}, \CodeIn{FileRT}, and \CodeIn{AllPermissionSM}.
%
%After the preceding process, for a migration tool, TeMaAPI further removes methods that use any APIs outside its defined mapping relations. The remaining methods can be translated from Java to other languages since it does not use any APIs outside of the migration tool.


