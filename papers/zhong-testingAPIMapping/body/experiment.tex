\section{Evaluations}
\label{sec:evaluation}

We implemented a tool for TeMAPI and
conducted evaluations using our tool to address the following
research questions:

%\vspace*{-1.5ex}
\begin{enumerate}
\item How effectively can existing translation tool translate API invocations (Section~\ref{sec:evaluation:invocation})? \vspace*{-1.8ex}
\item How effectively can our approach detect behavior differences of single API invocations (Section~\ref{sec:evaluation:single})?\vspace*{-1.8ex}
\item How effectively can our approach detect behavior differences of multiple API invocations (Section~\ref{sec:evaluation:sequence})?\vspace*{-1.8ex}
\item Can the our combination strategy helps achieve better coverage (Section~\ref{sec:evaluation:coverage})?
\end{enumerate}%\vspace*{-1.5ex}

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|l|c|c|c|c|c|c|}
 \hline
\textbf{Name}& \textbf{Version}& \textbf{Provider} &\textbf{Description}\\
\hline
Java2CSharp  &  1.3.4 & IBM (ILOG) & Java to C\# \\
\hline
JLCA         &  3.0   & Microsoft  & Java to C\# \\
\hline
sharpen      &  1.4.6 & db4o       & Java to C\# \\
\hline
Net2Java     &  1.0   & NetBean    &  C\# to Java\\
\hline
VB \& C\# to Java converter    &  1.6   & Tangible   &  C\# to Java\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Subject tools} \label{table:subjects}
\end{SmallOut}\vspace*{-2ex}
\end{table}

Table~\ref{table:subjects} shows the subject tools in our evaluation. Column ``Name'' lists the names of subject tools. In the rest of the paper, we call ``VB \& C\# to Java converter'' as converter for short. Column ``Provider'' lists their companies. Although all these tools are developed by commercial companies, Java2CSharp, sharpen, and Net2Java are all open source. Column ``Description'' lists the main functionalities of subject tools. We choose these tools as subjects since we find that many programmer recommend these tools in various forums.

All evaluations were conducted on a PC with Intel Qual CPU @
2.83GHz and 1.98M memory running Windows XP.

\subsection{Translating Generated Wrapper Methods}
\label{sec:evaluation:invocation}
For Java to C\# tools, we use TeMAPI to generate wrapper methods for J2SE 6.0\footnote{\url{http://java.sun.com/javase/6/docs/api/}}. As described in Section~\ref{sec:approach:generating}, TeMAPI ignores all generic API methods. Table~\ref{table:java2csharp} shows the translation results. Column ``Type'' lists the types of generated methods. In particular, ``sfg'' denotes getters of static fields; ``sfs'' denotes setters of static fields; ``nfg'' denotes getters of non-static fields; ``nfs'' denotes setters of non-static fields; ``sm'' denotes static methods; ``nm'' denotes non-static methods; and ``Total'' denotes the sums of all methods. Column ``Number'' lists numbers of corresponding types of methods. Columns ``Java2CSharp'', ``JLCA'', and ``sharpen'' list the translation results of corresponding translation tools. For these columns, sub-column ``M'' lists the number of translated methods without compilation errors, and sub-column ``\%'' lists the percentage from translated method without compilation errors to corresponding generated methods.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Type}}&
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{No}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{3-8} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}&  \textbf{M}& {\%}\\
\hline
sfg  &  16962 & 237 & 1.4\% & 3744 & 22.1\% & 47 & 0.3\%\\
\hline
sfs  &  0    & 0    & n/a   & 0    & n/a    & 0  & n/a  \\
\hline
nfg  &  832  & 0    & 0.0\% & 121  & 14.5\% & 26 & 2.2\%\\
\hline
nfs  &  823  & 0    & 0.0\% & 79   & 9.6\%  & 0   & 0.0\%\\
\hline
sm   &1175   & 97   & 8.3\% & 198  & 16.9\% & 26  & 2.2\%\\
\hline
nm   &175400 & 3589 & 2.0\% & 39536& 22.5\% & 1112& 0.6\%  \\
\hline
Total &195192& 3923 &  2.0\% & 43678 & 22.4\% & 1185 & 0.6\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of Java to C\# tools} \label{table:java2csharp}
\end{SmallOut}\vspace*{-2ex}
\end{table}

From the results of Table~\ref{table:java2csharp}, we find that it is quite challenging for a translation tool to cover all API invocations. One challenge lies in that API invocations are quite large in size. Although JLCA can translate 43678 generated methods, it covers only 22.4\% of total generated methods. The other challenge lies in that many API invocations of different languages cannot be accurately mapped. For example, as pointed out by our previous work~\cite{zhong2010mining}, one API method in one language may be mapped to several API methods in another language. We find that all the three translation tools have techniques to deal with many-to-many mapping relations. In particular, Java2CSharp and sharpen develop their own assemblies and map some API invocations to their implemented assemblies instead of standard C\# API invocations. For example, Java2CSharp maps the \CodeIn{java.lang.Class.forName(String)} method in Java to the \CodeIn{ILOG.J2CsMapping.Reflect.Helper.GetNativeType(String)} method in C\#, and the latter method is provided by Java2CSharp. JLCA does not implement additional assemblies, but generate additional source code to hide behavior differences. Although all the three translation tools take the behavior differences of mapped API invocations seriously, they do not cover all differences of API mapping relations. For example, when JLCA translates generated code, it generates a report with 1265 warning messages for behavior differences of API mapping relations. One warning message is ``Method 'java.lang.String.indexOf' was converted to 'System.String.IndexOf' which may throw an exception''. Still, JLCA leaves these differences to programmers, and the report does not tell programmers when such an exceptions is thrown.


\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Type}}&
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{No}}}
& \multicolumn{2}{|c|}{\textbf{Net2Java}} & \multicolumn{2}{|c|}{\textbf{converter}}\\\cline{3-6} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}\\
\hline
sfg  &  3223 & 1    & 0.0\% & 3    & 0.1\% \\
\hline
sfs  &  8    & 0    & 0.0\% & 0    & 0.0\%   \\
\hline
nfg  &  117  & 0    & 0.0\% & 0    & 0.0\%\\
\hline
nfs  &  115  & 0    & 0.0\% & 0    & 0.0\%\\
\hline
sm   &996    & 22   & 2.2\% & 387  & 38.9\% \\
\hline
nm   &190376 & 4    & 0.0\% & 6    & 0.0\% \\
\hline
Total &194835& 27   &  0.0\% & 396 & 0.2\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of C\# to Java tools} \label{table:csharp2java}
\end{SmallOut}\vspace*{-2ex}
\end{table}

For C\# to Java translation tools, we use TeMAPI to generate wrapper methods for the .Net framework client profile\footnote{\url{http://tinyurl.com/252t2ax}}. As described in Section~\ref{sec:approach:generating}, besides generic methods, TeMAPI also ignores methods whose parameters are marked with \CodeIn{out} or \CodeIn{ref}. Table~\ref{table:csharp2java} shows the translation results. Columns of Table~\ref{table:csharp2java} are of the same meanings with the columns of Table~\ref{table:java2csharp}. TeMAPI generates almost the same size of methods as it generates for J2SE 6.0. From the results of Table~\ref{table:java2csharp}, we find that both the two tool translate only quite a small portion of API invocations. As described in the wikipedia\footnote{\url{http://tinyurl.com/yj4v2m2}}, C\# provides many features that Java does not have (\emph{e.g.}, partial class, reference parameters, output parameters, and named arguments). We suspect that a C\# to Java translation tool needs take more effects on these issues, so many mapping relations of API invocations are not addressed yet.


Comparing the translation results between Java-to-C\# tools and C\#-to-Java tools, we find that Java-to-C\# tools cover much more API invocations. To fully explore the translation results of Java-to-C\# tools, we present the results of the package level in Table~\ref{table:package}. Column ``Name'' lists the names of Java packages. To save space, we omit the prefixes such as ``java.'', ``javax.'', and ``org.'' if it does not introduce ambiguity. We also use short names for some packages. In particular, we use ``acc.'' to denote the \CodeIn{javax.accessibility} package, ``man.'' to denote the \CodeIn{javax.management} package, ``java. sec.'' to denote the \CodeIn{java.security} package, and ``javax.sec.'' to denote the \CodeIn{javax.security} package. We also omits 12 packages that are not covered by all the three tools (\emph{e.g.}, the \CodeIn{javax.rmi} package). Other columns of Table~\ref{table:package} are of the same meanings with the columns of Table~\ref{table:java2csharp}. From the results of Table~\ref{table:package}, we find that all the three translation tools cover the \CodeIn{java.io} package, the \CodeIn{java.lang} package, the \CodeIn{java.util} package, and the \CodeIn{java.net} package. The four packages may be quite important for most Java programs. Almost for all packages, JLCA covers more API invocations. In particular, JLCA covers GUI-related packages such as the \CodeIn{java.awt} package and the \CodeIn{javax.swing} package. As a result, JLCA can translate some Java programs with GUI interfaces whereas the other two tools cannot.

\subsection{Testing Single Invocations}
\label{sec:evaluation:single}


To test behavior differences of single invocations, TeMAPI leverages Pex to search internal paths for C\# wrapper methods. These methods include the translated C\# methods without compilation errors as shown in Table~\ref{table:java2csharp} and the generated C\# methods that can be translated into Java without compilation errors as shown in Table~\ref{table:csharp2java}. When Pex searches those paths, TeMAPI records the inputs and output of each iteration. Based on these inputs and outputs, TeMAPI generates Java test cases to ensure that the generated methods and the translated methods produce the same outputs given the same inputs. As it requires human interactions to test GUI related API invocations, we filter out GUI related API invocations under the \CodeIn{awt} package and the \CodeIn{swing} package although JLCA is able to translate some GUI related API invocations. In addition, when Pex searches methods without return values, we ignore those paths that do not throw any exceptions since we cannot generate Java test cases for them. We discuss this issue in Section~\ref{sec:discuss}.


We run the generated Java test cases, and Table~\ref{table:singleinvoc} shows the results. Column ``Name'' lists the name of translation tools. Column ``Java'' lists numbers of generated Java test cases. Columns ``Error'' and ``Failure'' list number of test cases that end with errors and failures, respectively. Sub-column ``M'' lists numbers of test cases. Sub-column ``\%'' lists percentages from the numbers of corresponding test cases to the numbers of total generated test cases. From the results of Table~\ref{table:singleinvoc}, we find that totally only about half the generated Java test cases get passed. It turns out that TeMAPI is quite effective to detect behavior differences of mapped API invocations since it searches every paths of methods under test. The results also reflect that the API mapping relations defined in JLCA and sharpen are more reliable than other tools since more test cases of the two tools get passed than other four tools.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|p{3.6em}|r|r|r|r|r|c|c|}
 \hline
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{Name}}}&
\multicolumn{1}{|c|}{\multirow{2}*[-2pt]{\textbf{No}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{3-8} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}&  \textbf{M}& {\%}\\
\hline
awt  &  29199  & 0     &  0.0\%  &  8637  &  29.6\%  &  0   & 0.0\%\\
\hline
bean &  \hfill 1768   & 20    &  1.1\%  &  14    &  0.8\%   &  0   & 0.0\% \\
\hline
io   &  \hfill 3109   & 592   &  19.0\% & 1642   &  52.8\%  & 43   & 1.4\%\\
\hline
lang &  \hfill 5221   & 1494  &  28.6\% & 2377   &  45.5\%  & 791  & 15.2\%\\
\hline
math &  \hfill 1584   & 101   &  6.4\%  & 232    &  14.6\%  & 0    & 0.0\%\\
\hline
java.net  &  \hfill 1990   & 52    &  2.6\%  & 482    &  24.2\%  & 10   & 0.5\%  \\
\hline
nio  &  \hfill 536    & 30    &  5.6\%  & 0      &  0.0\%  &  0    & 0.0\%  \\
\hline
java.rmi  &  \hfill 1252   & 0     &  0.0\%  &  707   &  56.5\%  &  0   & 0.0\%\\
\hline
java.sec. &  \hfill 2797   & 50    &  1.8\%  &  702    &  25.1\%   &  0   & 0.0\% \\
\hline
java.sql   &  \hfill 3495   & 20   &  0.6\% & 183   &  5.2\%  & 0   & 0.0\%\\
\hline
text  &  \hfill 1068   & 96   &  9.0\% & 321   &  30.1\%  & 0  & 0.0\%\\
\hline
util  &  \hfill 9586   & 1372   &  14.3\%  & 1879    &  19.6\%  & 341    & 3.6\%\\
\hline
acc.  &  \hfill 237   & 1    &  0.4\%  & 25    &  10.5\%  & 0   & 0.0\%  \\
\hline
activation     &  \hfill 538   & 0    &  0.0\%  & 165   &  30.7\%  & 0   & 0.0\%  \\
\hline
crypto        &  \hfill 625   &  0    &  0.0\%  &  263  &  42.1\%  &  0    & 0.0\%\\
\hline
man.   &  \hfill 5380   & 2    &   0.0\%  & 0     &  0.0\%  & 0    & 0.0\%  \\
\hline
naming       &  \hfill 3565   & 0    &   0.0\%  & 1365   &  38.3\%  &  0    & 0.0\%  \\
\hline
javax.sec.       &  \hfill 1435  & 0     &  0.0\%  & 619     &  43.1\%  & 0    & 0.0\%\\
\hline
sound          &  \hfill 515   & 0    &  0.0\%  & 56    &  10.9\%  & 0   & 0.0\%  \\
\hline
swing          &  102389& 10   &  0.0\%  &  21364 &  20.9\%   &  0   & 0.0\%\\
\hline
javax.xml            &  \hfill 4188  &  34   &  0.8\% &  580   &  13.8\%  & 0  & 0.0\%\\
\hline
org.omg              &  \hfill 8937   & 0    &  0.0\%  & 1578  &  17.7\%  & 0   & 0.0\%  \\
\hline
w3c.dom          &  \hfill 83     & 0    &  0.0\%  & 14     &  16.9\%   & 0   & 0.0\%  \\
\hline
org.xml             &   \hfill 897    & 49   &  5.5\%  & 473    & 52.7\%    & 0   & 0.0\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of package level} \label{table:package}
\end{SmallOut}\vspace*{-2ex}
\end{table}


For tools such as Java2CSharp, JLCA, and sharpen, we further present their testing results of the package level in Table~\ref{table:packagetest}. Column ``Name'' lists names of J2SE packages. For columns ``Java2CSharp'', ``JLCA'', and ``sharpen'', sub-column ``R'' lists numbers of generated Java test cases, and sub-column ``\%'' lists percentages from the test cases end with errors or failures to the total test cases. From the results of Table~\ref{table:packagetest}, we find that for the \CodeIn{java.sql} package and the \CodeIn{java.util} package, all the tools suffer relatively high error/failure percentages, and for the \CodeIn{java.lang} package and the \CodeIn{java.math} package, all the tools achieve relatively low error/failure percentages. The results may reflect that some packages between Java and C\# are more similar than others, so that they can more easily mapped. We also find that for package the \CodeIn{java.text} package, the \CodeIn{javax.xml} package, and the \CodeIn{org.xml} package, JLCA achieve lower error/failure percentages than other tools. The results indicate that a translation tool can achieve better translation results if they carefully prepare the mapping relations of API invocations.


Table~\ref{table:singleinvoc} and Table~\ref{table:packagetest} show that many generated Java tests do not get passed. To better understand behavior differences of mapped API invocations, we manually inspected 3759 Java test cases that end with errors or failures. In particular, for tools such as Java2CSharp, JLCA, and sharpen, we investigate the test cases for the \CodeIn{java.lang} package since TeMAPI generates many test cases for the package as shown in Table~\ref{table:package}. For tools such as Net2Java and converter, we inspect all their test cases since TeMAPI test cases in small sizes for them. Our findings are as follows:

\textbf{Finding 1:} 36.8\% test cases show the behavior differences caused by null inputs.

We find that Java API invocations and their mapped C\# API invocations can have behavior differences when inputs are null values. In some cases, a Java API method can accept null values, but its mapped C\# API method will throw exceptions given a null value. One such example is shown in Section~\ref{sec:introduction}. In other cases, a Java API method will throw exceptions given a null value, but its mapped C\# API method can accept null values. For example, JLCA maps the \CodeIn{java.lang.Integer.parseInt(String,int)} method in Java to the \CodeIn{System.Convert.ToInt32(string,int)} in C\#. TeMAPI detects that when the inputs of the C\# method are null and 10, its output is 0. Given the same inputs, the Java method throws a \CodeIn{NumberFormatException}.

\Comment{We also find that given the same inputs, a method may produce null outputs, whereas its mapped method will not. For example, converter maps the \CodeIn{Sys- tem.Collections.Queue.ToArray()} in C\# to the \CodeIn{java.util. LinkedList.toArray()} method in Java. Given an empty list, the C\# method produce a null value, whereas the Java method produce an empty array.}


\textbf{Implication 1:} Although programmers may come to agreements on functionalities of API invocations, the behaviors for null values are typically controversial. Programmers or translation tool should deal with null values carefully across Java and C\#.

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Name}}
& \multirow{2}*[-2pt]{\textbf{Java}} & \multicolumn{2}{|c|}{\textbf{Error}}& \multicolumn{2}{|c|}{\textbf{Failure}} \\\cline{3-6}  &  & \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}\\
\hline
Java2CSharp  &   15458 & 5248 & 34.0\% & 3261 & 21.1\% \\
\hline
JLCA         &   33034 & 8901 & 26.9\% & 6944 & 21.0\% \\
\hline
sharpen      &  2730 & 662  & 24.2\% & 451  & 16.5\%\\
\hline
net2java     &   352 & 40   & 11.4\%  & 261   & 74.1\%\\
\hline
converter    &  762 & 302  & 39.6\% & 182   & 23.9\%\\
\hline
Total        &  52336  &  15153 & 29.0\% &11099 & 21.2\%  \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing single invocations} \label{table:singleinvoc}
\end{SmallOut}\vspace*{-2ex}
\end{table}


\textbf{Finding 2:} 22.3\% test cases show the behavior differences caused by stored string values.

We find that string values between Java API invocations and their mapped C\# API invocations are typically different. For example, each Java class has a \CodeIn{toString()} method inherited from the \CodeIn{java.lang.Object} class, and each C\# class also has a \CodeIn{ToString()} method inherited from the \CodeIn{System.Object} class. Many translation tools map the two API methods, but the return values of the two methods are quite different in many cases. As another example, many API classes declare methods like \CodeIn{getName} or \CodeIn{getMessage}. These methods also return string values that can be quite different. In particular, we find that the \CodeIn{Message} fields of exceptions in C\# often return informative messages. One such message is ``Index was outside the bounds of the array'' provided by the \CodeIn{System.Index- OutOfRangeException.Message} field. On the other hand, exceptions in Java often provide only null messages.

\textbf{Implication 2:} String values including names are typically different between Java API invocations and their mapped C\# API invocations. Programmers should not rely on these string values unless translation tools can hide the differences.

\textbf{Finding 3:} 11.5\% test cases show the behavior differences caused by illegal inputs or inputs out of ranges.

We find that Java methods often do not check whether their inputs are legal or out of range, whereas C\# methods typically do. For example, Java2CSharp maps the \CodeIn{java.lang.Boolean.parseBoo- lean(String)} method in Java to the \CodeIn{System.Boolean.Parse( String)} method in C\#. Given a string whose value is ``test'', the Java method return false without checking its format, whereas the C\# method throws \CodeIn{FormatException} since it considers ``test'' as illegal inputs. As another example, the \CodeIn{java.lang.Double. shortValue()} method in Java accepts values that are larger than \CodeIn{Short.MAX\_VALUE} (32767). JLCA maps the Java method to the \CodeIn{Convert.ToInt16(double)} method in C\#, but the C\# method throw \CodeIn{OverflowException} when values are larger than 32767.

\textbf{Implication 3:} Programmers should be aware of the different input ranges of API methods between Java and C\#. As C\# API methods typically check ranges of input, C\# programmers may not check ranges of inputs themselves, and thus introduce potential defects in translated Java code.

\textbf{Finding 4:} 10.7\% test cases show the behavior differences caused by different understanding or implementation.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|p{3.4em}|r|r|r|r|r|r|r|r|r|r|}
 \hline
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{Name}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{2-7} &  \textbf{R}&  \textbf{\%} &   \textbf{R}& \textbf{\%} & \textbf{R}&   \textbf{\%}\\
\hline
bean &  \hfill 17     &    82.4\%  &  18        &  33.3\%   &  0      & n/a \\
\hline
io   &  \hfill 4155   &  67.8\%  &  6981       &  58.0\%   &   33    & 1.4\%\\
\hline
lang &  \hfill 3480   &   37.5\%  &  4431      &  26.1\%   &   1753 & 29.3\%\\
\hline
math &  \hfill 561    &   4.3\%  &   1629     &   1.5\%   &  0      & n/a\\
\hline
java.net  &   438     &   25.1\% &   3941     &   47.8\%  & 9       & 44.4\%  \\
\hline
nio  &  \hfill 27     &  48.1\% &    0        &   n/a     &  0     &  n/a \\
\hline
java.rmi  &  \hfill 0   &   n/a   &   884     &   32.6\%  &  0     & n/a\\
\hline
java.sec. &  \hfill 45  &   55.6\%  &  828    &  35.6\%   &  0    & n/a \\
\hline
java.sql   &  \hfill 260&   88.1\%  & 1465    &  91.0\%   &   0     & n/a\\
\hline
text  &  \hfill 566   &   61.5\%  & 374      &  18.2\%   & 0      & n/a\\
\hline
util  &  \hfill 5519  &   60.8\%  & 6177     & 70.2\%  & 935      & 62.4\%\\
\hline
acc.  &  \hfill 1    &   0.0\%   & 0         & n/a    & 0          & n/a \\
\hline
activation  &  0     &    n/a    & 694      & 53.9\% & 0           & n/a  \\
\hline
crypto      &  0     &     n/a    & 298     & 24.2\% &  0        & n/a\\
\hline
man.        &  2     &    0.0\%  & 0        & n/a    &  0          & n/a  \\
\hline
naming      &  0     &    n/a     & 1569    & 40.6\%  &  0         & n/a  \\
\hline
javax.sec.  &  0     &   n/a     & 683     & 45.9\%  &  0        & n/a\\
\hline
sound       &  0     &   n/a     & 66       & 36.4\%  &   0        &n/a  \\
\hline
javax.xml   &  110   &    71.8\%  &  628    & 45.9\%  &   0         & n/a\\
\hline
org.omg     &  0     &   n/a     & 1842    & 45.9\%  & 0           & n/a  \\
\hline
w3c.dom     &  0     &   n/a     & 18      & 33.3\%  &  0         & n/a  \\
\hline
org.xml     &   277  &   70.0\%  & 483     & 27.3\%  & 0         & n/a\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Testing results of package level } \label{table:packagetest}
\end{SmallOut}\vspace*{-2ex}
\end{table}

We find that Java developers and C\# developers may have different understanding or implementation for mapped API methods. For example, according to their documents, the \CodeIn{java.lang.String- Buffer.capacity()} method in Java returns ``the current capacity of the String buffer'', and the \CodeIn{System.Text.StringBuilder. Capacity} field in C\# can return ``the maximum number of characters that can be contained in the memory allocated by the current instance''. JLCA maps the method in Java to the field in C\#, and we find that in many cases they are of different values. For sample, given a string whose value is ``0'', the \CodeIn{capacity()} in Java returns 0, but the \CodeIn{Capacity} field in C\# is 16. We notice that some such differences may indicate defects in mapped methods. For example, Java2CSharp maps the \CodeIn{java.lang.Integer.toHexString(int)} method in Java to the \CodeIn{ILOG.J2CsMapping.Util.IlNumber.To- String(int,16)} method in C\#. Given a integer whose value is -2147483648, the Java method returns ``80000000'', but the C\# method returns ``\textbackslash080000000''. As the result of the Java method seems to be right, we suspect that the mapped C\# method may have some defects to deal with the value.

\textbf{Implication 4:} Although programmers can come to agreement on functionalities of many API methods, they may have different understanding on functionalities of specific methods. Such differences may indicate defects in mapped API methods.


\textbf{Finding 5:} 7.9\% test cases show the behavior differences caused by exception handling.

We find that two mapped API methods can throw exceptions that are not mapped. For example, when indexes are out of bounds, the \CodeIn{java.lang.StringBuffer.insert(int,char)} method in Java throws \CodeIn{ArrayIndexOutofBoundsException}. Java2CSharp maps the methods to the \CodeIn{StringBuilder.Insert(int,char)} method in C\# that throws \CodeIn{ArgumentOutOfRangeException} when indexes are out of bounds. As Java2CSharp maps \CodeIn{ArrayIndexOut- ofBoundsException} in Java to \CodeIn{IndexOutOfRangeException} in C\#, the mapped C\# method may fail to catch exceptions when indexes are out of bounds.

\textbf{Implication 5:} Even if two methods are of the same functionality, they may produce exceptions that are not mapped. Programmers should be careful to deal with exception handling, unless migrations tools can hide the differences.



\textbf{Finding 6:} 2.8\% test cases show the behavior differences caused by static values.

We find that mapped static fields may have different values. For example, the \CodeIn{java.lang.reflect.Modifier} class has many static fields to represent modifiers (\emph{e.g.}, FINAL, PRIVATE and PROTECTED). Java2CSharp maps these fields to the fields of the \CodeIn{ILOG. J2CsMapping.Reflect} class. Although most mapped fields of the two class are of the same values, we find that fields such as VOLATILE and TRANSIENT are of different values. In addition, we find that different values sometimes reveal different ranges of data types. For example, \CodeIn{java.lang.Double.MAX\_VALUE} in Java is 1.7976931348623157E+308, and \CodeIn{System.Double.MaxValue} in C\# is 1.79769313486232E+308. Although the difference is not quite large, it can cause serious defects if a program needs highly accurate calculation results.

\textbf{Implication 6:} Programmers should be aware of that static fields may have different values even if they has the same names. As these differences reveal that Java and C\# may define different bounds for data types, programmers should also be aware of these different bounds if they need highly accurate results of extremely large or small calculation results.

The rest 7.9\% test cases fail since API methods can produce random values. For example, the \CodeIn{java.util.Random.nextDouble()} method in Java generates random double values. As another example, each Java class has a \CodeIn{hashCode()} method inherited from the \CodeIn{java.lang.Object} class, and each C\# class has a \CodeIn{GetHashCode()} inherited from the \CodeIn{System.Object} class. Both the two methods return a hash code for the current object, so translation tools such as JLCA map the two methods. For these methods, TeMAPI can find their behavior differences of inputs. For example, converter maps the \CodeIn{System.Random. Next(int)} method in C\# to the \CodeIn{java.util.Random.nextInt(int)} method in Java. Given a integer whose value is 0, the C\# method return 0, but the Java method throws \CodeIn{IllegalArgumentException} with a message: ``n must be positive''. However, as these methods generate outputs randomly, we cannot conclude they have behavior differences even if corresponding Java test cases all fail, and we discuss this issue in Section~\ref{sec:discuss}.

\subsection{Testing Multiple Invocations}
\label{sec:evaluation:sequence}
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Name}}& \multirow{2}*[-2pt]{\textbf{API}} & \multirow{2}*[-2pt]{\textbf{Java}}
& \multirow{2}*[-2pt]{\textbf{C\#}} & \multicolumn{2}{|c|}{\textbf{Failure}} \\\cline{5-6} & &  & & \textbf{M}& \textbf{\%} \\
\hline
Java2CSharp  &  1996 & 15385&  2971 & 2151 & 72.4\%\\
\hline
JLCA         &  7060 & 16630& 1067 & 295  & 27.6\%  \\
\hline
sharpen      &  586  & 13532& 936  & 456  & 48.7\% \\
\hline
Total        &  9642 & 45547& 4504  &  2813 & 62.5\% \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing multiple invocations} \label{table:invocsequence}
\end{SmallOut}\vspace*{-2ex}
\end{table}

To test behavior differences of API invocation sequences, TeMAPI leverage Randoop to generate test cases that involve multiple API invocations. For each Java-to-C\# tools, TeMAPI first analyzes the translation results as shown in Table~\ref{table:java2csharp} for the list of translatable API invocations in Java. When generating test cases, TeMAPI extends Randoop, so that each generated test case use only translatable API invocations. Randomly generated invocation sequences may not reflect API usages in true practice. We discuss this issue in Section~\ref{sec:discuss}. We find that Randoop can generate failure test cases or even test cases with compilation errors. TeMAPI removes those test cases, so that the remaining test cases all get passed. After that, we use the corresponding translation tool to translate the remaining test cases from Java to C\#. As the remaining Java test cases all get passed, translated C\# test cases should also get passed.

Table~\ref{table:invocsequence} shows the results. Column ``API'' lists sizes of translatable API invocations. Column ``Java'' lists numbers of Java test cases that run successfully. Column ``C\#'' lists numbers of C\# test cases. We notice that many Java test cases are not successfully translated into C\# test cases. We find that two factors that are not general or not related with API migration: (1) some generated Java test cases use classes defined by Randoop; (2) some code structures are complicated to translate, and we further discuss this issue in Section~\ref{sec:discuss}. Besides the two factors, we find one general factors for API translation.

\textbf{Finding 7:} Many translated test cases have compilation errors since Java classes and their mapped C\# classes have different inheritance relations.

We find that Java API classes can have quite different inheritance relations with their mapped C\# API classes, and thus introduce compilation errors in cast statements. For example, a Java test case is as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
public void test87() throws Throwable\{
  ...
  StringBufferInputStream var4=...;
  InputStreamReader var10=
    new InputStreamReader((InputStream)var4, var8);
\}
\end{alltt}
\end{CodeOut}

JLCA translates the Java test case into a C\# test case as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
public void test87() throws Throwable\{
  ...
  StringReader var4=...;
  StreamReader var10=
    new StreamReader((Stream)var4, var8);
\}
\end{alltt}
\end{CodeOut}

As the two Java classes are subclass and parent class, the Java test case runs successfully, whereas the two C\# class have no such relations so translated C\# method has compilation errors.

\textbf{Implication 7:} Programmers should use cast statements carefully since classes of two languages typically have different inheritance relations.

Column ``Failure'' lists failed C\# test cases. We do not list numbers of test cases with errors since C\# does not separate errors from failures as Java does. Sub-column ``M'' lists numbers of test cases, and sub-column ``\%'' lists percentages from failed test cases to total test cases.

From the results of Table~\ref{table:invocsequence}, we find that JLCA achieves better results than other tools since its percentage is the lowest. For each tool, we further investigate the first 100 failed test cases, and we find that 93.3\% failed test cases are accumulated by the found factors as shown in Section~\ref{sec:evaluation:single}: 45.0\% for ranges of parameters, 34.0\% for string values, 5.3\% for different understanding, 4.0\% for exception handling, 3.0\% for null values, 2.0\% for values of static fields, and 0.3\% for random values. We find that random strategy affect the distribution. For example, as invocation sequences are random, inputs of many methods are out of range or illegal. Java API methods typically do not check inputs, so generated Java run successfully, but translated C\# test cases fail with various exceptions since C\# API methods typically check inputs. Besides those found factors, we find additional two factors as follows:

\textbf{Finding 8:} 3.3\% test cases fail because of invocation sequences.

We find that random invocation sequences can violate specifications of API libraries. One type of such specification is described in our previous work~\cite{zhong09:inferring}: closed resources should not be manipulated. Java sometimes allow programmers to violate such specifications although the return values can be meaningless. One such example is shown in Section~\ref{sec:example}. Besides invocation sequences that are related to specifications, we find that field accessibility also leads to failures of test cases. For example, a generated Java test case is as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
public void test423() throws Throwable\{
  ...
  DateFormatSymbols var0=new DateFormatSymbols();
  String[] var16=new String[]{...};
  var0.setShortMonths(var16);
\}
\end{alltt}
\end{CodeOut}

JLCA translates the Java test case into a C\# test case as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
public void test423() throws Throwable\{
  ...
  DateTimeFormatInfo var0 =
  System.Globalization.DateTimeFormatInfo.CurrentInfo;
  String[] var16=new String[]{...};
  var0.AbbreviatedMonthNames = var16;
\}
\end{alltt}
\end{CodeOut}

The \CodeIn{var0.AbbreviatedMonthNames = var16} statement fails with \CodeIn{InvalidOperationException} since a constant value is assigned to \CodeIn{var0}.

\textbf{Implication 8:} When translating, programmers should check carefully whether they violate speculations of libraries and whether invocation sequences affect accessibility of fields.

The rest 3.0\% test cases fail since mapped methods are not implemented. In particular, Java2CSharp maps API invocations in Java to C\# API invocations that are not implemented yet. For example, Java2CSharp maps the \CodeIn{java.io.ObjectOutputStream} class in Java to the \CodeIn{ILOG.J2CsMapping.IO.IlObjectOutput- Stream} class in C\# that is not implemented yet, and such mapping relations lead to \CodeIn{NotImplementException}. As this difference introduces no compilation errors, programmers should test translated projects carefully to ensure each API method is called.
\subsection{Coverage}
\label{sec:evaluation:coverage}

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\textbf{Class}& \textbf{Pex} & \textbf{Randoop}
& \textbf{TeMAPI} \\
\hline
ManagerNotRecognizedException  &  100\% & 100\% &  100\%\\
\hline
ManagerNotSupportedException   &  100\% & 100\% &  100\%  \\
\hline
SaxAttributesSupport           &  78\%  & 74\%  &  80\%\\
\hline
XmlSaxDefaultHandler           &  100\% & 94\%  &  100\%\\
\hline
XmlSAXDocumentManager          &  29\%  & 17\%  &  29\%\\
\hline
XmlSaxLocatorImpl              &  83\%  & 100\%  &  100\%\\
\hline
XmlSaxParserAdapter            &  100\%  & 100\%  &  100\%\\
\hline
XmlSourceSupport               &  100\%  & 56 \%  &  100\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing coverage} \label{table:coverageJLCA}
\end{SmallOut}\vspace*{-2ex}
\end{table}

Test coverage is a common criterion to measure the adequacy of test cases~\cite{zhu1997software}. To investigate whether our combination strategy helps achieve better coverage from Java to C\#, we conduct an experiment on JLCA, and Table~\ref{table:coverageJLCA} shows the results. Is trick to extract coverage of API methods, especially in our context where most mapping relations are between J2SE and .NetFramework. For example, we find that coverage tools such as PartCover\footnote{\url{http://partcover.blogspot.com/ }} rely on the \CodeIn{JITCompilationStarted} method\footnote{\url{http://tinyurl.com/2gy2nqk}} for notifications of called methods, and thus fail to extract coverage for many methods in .NetFramework since usually no notifications are received when these method are called. As a result, we choose the \CodeIn{org.xml} package in Java as the subject. JLCA generates eight classes as shown in Table~\ref{table:coverageJLCA}, and translates some classes of the \CodeIn{org.xml} package in Java to the eight C\# classes. Column ``Class'' shows the names of the eight classes. Column ``Pex'' lists achieved coverage if leveraging only Pex. Column ``Randoop'' lists  achieved coverage if leveraging only Randoop. We limit the search scope of Randoop to the \CodeIn{org.xml} package, and translate generated Java test cases into C\# using JLCA As Pex searches feasible paths and Randoop relies on random strategy, Pex achieves better coverage than Randoop except the \CodeIn{XmlSaxLocatorImpl} class. We find that Pex can fail to generate non-null values for some interfaces. For example, the parameter of the \CodeIn{XmlSaxLocatorImpl(XmlSaxLocator)} constructor is an interface. Pex generates only null inputs for the constructor, but Randoop casts a value to the interface. As a result, Randoop achieves better coverage on this class than Pex. Still, both Pex and Randoop do not achieve high coverage for some classes such as the \CodeIn{XmlSAXDocumentManager} class. We find that some methods of the class cannot be covered unless it reads a file. As both Pex and Randoop generates filenames randomly, these methods are not covered by either tool. Column ``TeMAPI'' lists  achieved coverage if combining Pex and  Randoop. We find that the combination achieves the best results for all classes.

To investigate whether our combination strategy helps achieve better coverage from C\# to Java, we conduct an experiment on converter, and Table~\ref{table:coverageconverter} shows the results.  For similar consideration, we select several classes (\emph{i.e.}, the \CodeIn{System.Collections.Array- List} class, the \CodeIn{System.Collections.Hashtable} class, the \CodeIn{Sys- tem.Collections.Queue} class, and the \CodeIn{System.Collections. Stack} class). Table~\ref{table:coverageconverter} shows coverage of their translated classes in Java. The four Java classes are decompiled by JAD\footnote{\url{http://www.varaneckas.com/jad}}. To compile the four Java classes, we fix defects introduced during decompiling, and change their package names. Column ``Class'' shows the names of the four Java classes. Column ``Pex'' lists achieved coverage if leveraging only Pex. We use TeMAPI to generates Java test cases when Pex searches feasible paths. Column ``Randoop'' lists  achieved coverage if leveraging only Randoop. From the perspective of the four Java classes, Pex also generates test cases randomly since it does not search their feasible paths. As a result, the achieved coverage shown in Table~\ref{table:coverageconverter} are also half to half. Column ``TeMAPI'' lists  achieved coverage if combining Pex and  Randoop. We also find that the combination achieves the best results.

In summary, by combing Pex and Randoop, TeMAPI achieve higher coverage than with single tools.
\subsection{Summary}
\label{sec:evaluation:summary}
In summary, we find that API invocations are quite large in size, and translation tools typically cover only a small set of API invocations. Although existing translation tools already notice behavior differences of mapped API invocations, many differences are left unsolved. In particular, TeMAPI detects that various factors such as null values, string values, ranges of inputs, different understanding, exception handling, and static values can lead to behavior differences for single API invocations. The preceding factors can accumulate to behavior differences of multiple API invocations. Besides, TeMAPI detects that other factors such as cast statements and invocation sequences can also lead to behavior differences of multiple API invocations.
\subsection{Threats to Validity}
\label{sec:evaluation:threat}
The threats to external validity include the representativeness of the subject tools. Although we applied
our approach on 5 widely used translation tools, our approach is evaluated only on these limited tools. This threat could be reduced by introducing more subject tools in future work. The threats to internal validity include human factors for inspecting behavior differences from failed test cases. To reduce these threats, we inspected those test cases carefully. The threat could be further
reduced by introducing more researchers to inspect detected differences.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\textbf{Class}& \textbf{Pex} & \textbf{Randoop}
& \textbf{TeMAPI} \\
\hline
HashTable                      &  23\%  & 15\%  &  26\%\\
\hline
LinkedList                     &  32\%  & 26\%  & 37\%\\
\hline
ArrayList                      &  18\%  & 25\%  &  31\%\\
\hline
Stack                          &  21\%   & 55\%  &  55\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing coverage} \label{table:coverageconverter}
\end{SmallOut}\vspace*{-2ex}
\end{table} 