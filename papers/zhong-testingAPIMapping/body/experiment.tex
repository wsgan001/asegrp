\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|l|c|c|c|c|c|c|}
 \hline
\textbf{Name}& \textbf{Version}& \textbf{Provider} &\textbf{Description}\\
\hline
Java2CSharp  &  1.3.4 & IBM (ILOG) & Java to C\# \\
\hline
JLCA         &  3.0   & Microsoft  & Java to C\# \\
\hline
sharpen      &  1.4.6 & db4o       & Java to C\# \\
\hline
Net2Java     &  1.0   & NetBean    &  C\# to Java\\
\hline
VB \& C\# to Java converter    &  1.6   & Tangible   &  C\# to Java\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Subject tools} \label{table:subjects}
\end{SmallOut}\vspace*{-2ex}
\end{table}
\section{Evaluations}
\label{sec:evaluation}

We implemented a tool for TeMAPI and
conducted evaluations using our tool to address the following
research questions:

\vspace*{-1.5ex}
\begin{enumerate}
\item How effectively can existing translation tool translate API invocations (Section~\ref{sec:evaluation:invocation})? \vspace*{-1.8ex}
\item How effectively can our approach detect behavior differences of single API classes (Section~\ref{sec:evaluation:single})?\vspace*{-1.8ex}
\item How effectively can our approach detect behavior differences of multiple API classes (Section~\ref{sec:evaluation:sequence})?\vspace*{-1.8ex}
\item Can the our combination strategy helps achieve better coverage (Section~\ref{sec:evaluation:coverage})?
\end{enumerate}\vspace*{-1.5ex}



Table~\ref{table:subjects} shows the subject tools used in our evaluation. Column ``Name'' lists names of subject tools. In the rest of the paper, we refer to ``VB \& C\# to Java converter'' as converter for short. Column ``Version'' lists versions of subject tools. Column ``Provider'' lists companies of subject tools. Although all these tools are from commercial companies, Java2CSharp, sharpen, and Net2Java are all open source. Column ``Description'' lists main functionalities of subject tools. We choose these tools as subjects since we find that many programmer recommend these tools in various forums.

All evaluations were conducted on a PC with Intel Qual CPU @
2.83GHz and 1.98M memory running Windows XP.

\subsection{Translating Synthesized Wrappers}
\label{sec:evaluation:invocation}
For Java-to-C\# tools, we used TeMAPI to synthesize wrapper methods for all classes of J2SE 6.0\footnote{\url{http://java.sun.com/javase/6/docs/api/}}. As described in Section~\ref{sec:approach:generating}, when synthesizing, TeMAPI ignored all generic API methods. Table~\ref{table:java2csharp} shows the translation results. Column ``Type'' lists types of synthesized methods. In particular, ``sfg'' denotes getters of static fields; ``sfs'' denotes setters of static fields; ``nfg'' denotes getters of non-static fields; ``nfs'' denotes setters of non-static fields; ``sm'' denotes static methods; ``nm'' denotes non-static methods; and ``Total'' denotes the sums of all methods. Column ``No'' lists numbers of corresponding types of methods. Columns ``Java2CSharp'', ``JLCA'', and ``sharpen'' list the translation results of corresponding translation tools. For these columns, sub-column ``M'' lists number of translated wrapper methods without compilation errors, and sub-column ``\%'' lists percentages from translated wrapper methods without compilation errors to total synthesized ones.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Type}}&
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{No}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{3-8} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}&  \textbf{M}& {\%}\\
\hline
sfg  &  16962 & 237 & 1.4\% & 3744 & 22.1\% & 47 & 0.3\%\\
\hline
sfs  &  0    & 0    & n/a   & 0    & n/a    & 0  & n/a  \\
\hline
nfg  &  832  & 0    & 0.0\% & 121  & 14.5\% & 26 & 2.2\%\\
\hline
nfs  &  823  & 0    & 0.0\% & 79   & 9.6\%  & 0   & 0.0\%\\
\hline
sm   &1175   & 97   & 8.3\% & 198  & 16.9\% & 26  & 2.2\%\\
\hline
nm   &175400 & 3589 & 2.0\% & 39536& 22.5\% & 1112& 0.6\%  \\
\hline
Total &195192& 3923 &  2.0\% & 43678 & 22.4\% & 1185 & 0.6\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of Java-to-C\# tools} \label{table:java2csharp}
\end{SmallOut}\vspace*{-2ex}
\end{table}

From the results of Table~\ref{table:java2csharp}, we find that it is quite challenging for a translation tool to cover all API invocations, since API invocations are quite large in size. Although JLCA can translate 43678 wrapper methods, it covers only 22.4\% of total wrapper methods since it fails to translate other API invocations in the rest of wrapper methods. Even if an API invocation is translated, it can be translated to an API invocation with behavior differences. We find that developers of translation tools may already notice the problem of differences. For example, after JLCA translated synthesized code, it generated a report with many warning messages for behavior differences of translated API invocations. One warning message is ``Method 'java.lang.String.indexOf' was converted to 'System.String.IndexOf' which may throw an exception'', but the report does not tell programmers when such an exceptions is thrown or how to deal with such exceptions. JLCA leaves these behavior differences to programmers.


\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Type}}&
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{No}}}
& \multicolumn{2}{|c|}{\textbf{Net2Java}} & \multicolumn{2}{|c|}{\textbf{converter}}\\\cline{3-6} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}\\
\hline
sfg  &  3223 & 1    & 0.0\% & 3    & 0.1\% \\
\hline
sfs  &  8    & 0    & 0.0\% & 0    & 0.0\%   \\
\hline
nfg  &  117  & 0    & 0.0\% & 0    & 0.0\%\\
\hline
nfs  &  115  & 0    & 0.0\% & 0    & 0.0\%\\
\hline
sm   &996    & 22   & 2.2\% & 387  & 38.9\% \\
\hline
nm   &190376 & 4    & 0.0\% & 6    & 0.0\% \\
\hline
Total &194835& 27   &  0.0\% & 396 & 0.2\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of C\#-to-Java tools} \label{table:csharp2java}
\end{SmallOut}\vspace*{-3ex}
\end{table}

For C\#-to-Java translation tools, we used TeMAPI to synthesize wrapper methods for all classes of the .Net framework client profile\footnote{\url{http://tinyurl.com/252t2ax}}. As described in Section~\ref{sec:approach:generating}, besides generic methods, TeMAPI also ignored methods whose parameters are marked with \CodeIn{out} or \CodeIn{ref}. Table~\ref{table:csharp2java} shows the translation results. Columns of Table~\ref{table:csharp2java} are of the same meanings with the columns of Table~\ref{table:java2csharp}, but generated wrapper methods are in C\#. TeMAPI synthesized almost the same size of wrapper methods as it synthesized for J2SE 6.0. From the results of Table~\ref{table:java2csharp}, we find that both the two tool translate only quite a small portion of API invocations. As described in the wikipedia\footnote{\url{http://tinyurl.com/yj4v2m2}}, C\# provides many features that Java does not have (\emph{e.g.}, partial class, reference parameters, output parameters, and named arguments). We suspect that a C\#-to-Java translation tool needs take more effects on these issues, so many mapping relations of API invocations are not addressed yet.


Comparing the translation results between Java-to-C\# tools and C\#-to-Java tools, we find that Java-to-C\# tools cover much more API invocations. To fully explore the translation results of Java-to-C\# tools, we present the results at the package level in Table~\ref{table:package}. Column ``Name'' lists names of Java packages. To save space, we omit the prefixes such as ``java.'', ``javax.'', and ``org.'' if it does not introduce ambiguity. We also use short names for some packages. In particular, we use ``acc.'' to denote the \CodeIn{javax.accessibility} package, ``man.'' to denote the \CodeIn{javax.management} package, ``java. sec.'' to denote the \CodeIn{java.security} package, and ``javax.sec.'' to denote the \CodeIn{javax.security} package. We also omit 12 packages that are not covered by all the three tools (\emph{e.g.}, the \CodeIn{javax.rmi} package). Other columns of Table~\ref{table:package} are of the same meanings with the columns of Table~\ref{table:java2csharp}. From the results of Table~\ref{table:package}, we find that all the three translation tools cover the \CodeIn{java.io} package, the \CodeIn{java.lang} package, the \CodeIn{java.util} package, and the \CodeIn{java.net} package. The four packages seem to be quite important for most Java programs. Almost for all the packages, JLCA covers more API invocations than the other two tools. In particular, JLCA covers GUI-related packages such as the \CodeIn{java.awt} package and the \CodeIn{javax.swing} package. As a result, JLCA can translate some Java programs with GUI interfaces whereas the other two tools cannot.

\subsection{Testing Single Classes}
\label{sec:evaluation:single}

To test behavior differences of single classes, TeMAPI leverages Pex to search internal paths for safe wrapper methods. These methods include the translated C\# wrapper methods without compilation errors as shown in Table~\ref{table:java2csharp}, and the synthesized C\# wrapper methods that can be translated into Java without compilation errors as shown in Table~\ref{table:csharp2java}. When Pex searches each wapper method, TeMAPI records the inputs and output for each path. Based on these inputs and outputs, TeMAPI generates Java test cases to ensure that synthesized wrapper methods and translated wrapper methods produce the same outputs given the same inputs. As it requires human interactions to test GUI related API invocations, we filter out GUI related API invocations (\emph{i.e.}, the \CodeIn{awt} package and the \CodeIn{swing} package) although JLCA is able to translate some classes of the two packages. In addition, when Pex searches methods without return values, we ignore those paths that do not throw any exceptions since we cannot generate Java test cases for them. We discuss this issue in Section~\ref{sec:discuss}.

We run generated Java test cases, and Table~\ref{table:singleinvoc} shows the results. Column ``Name'' lists names of translation tools. Column ``Java'' lists numbers of generated Java test cases. Columns ``Error'' lists numbers of test cases that throw un-handled exceptions. Columns ``Failure'' lists numbers of test cases that fail in assertion. For the two columns, sub-column ``M'' lists numbers of corresponding test cases, and sub-column ``\%'' lists percentages from numbers of corresponding test cases to numbers of total generated test cases. From the results of Table~\ref{table:singleinvoc}, we find that totally only about half the generated Java test cases get passed. Among the five tools, sharpen achieves the lowest error and failure percentage. It seems that developers of sharpen put great efforts to hide behavior differences. The percentage of JLCA is also relatively low. The results is commendable since it translates much more API invocations than the other tools. Totaly, about 50\% test cases does not get passed. The results show the effectiveness of TeMAPI since these test cases indicate behavior differences.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|p{3.6em}|r|r|r|r|r|c|c|}
 \hline
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{Name}}}&
\multicolumn{1}{|c|}{\multirow{2}*[-2pt]{\textbf{No}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{3-8} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}&  \textbf{M}& {\%}\\
\hline
awt  &  29199  & 0     &  0.0\%  &  8637  &  29.6\%  &  0   & 0.0\%\\
\hline
bean &  \hfill 1768   & 20    &  1.1\%  &  14    &  0.8\%   &  0   & 0.0\% \\
\hline
io   &  \hfill 3109   & 592   &  19.0\% & 1642   &  52.8\%  & 43   & 1.4\%\\
\hline
lang &  \hfill 5221   & 1494  &  28.6\% & 2377   &  45.5\%  & 791  & 15.2\%\\
\hline
math &  \hfill 1584   & 101   &  6.4\%  & 232    &  14.6\%  & 0    & 0.0\%\\
\hline
java.net  &  \hfill 1990   & 52    &  2.6\%  & 482    &  24.2\%  & 10   & 0.5\%  \\
\hline
nio  &  \hfill 536    & 30    &  5.6\%  & 0      &  0.0\%  &  0    & 0.0\%  \\
\hline
java.rmi  &  \hfill 1252   & 0     &  0.0\%  &  707   &  56.5\%  &  0   & 0.0\%\\
\hline
java.sec. &  \hfill 2797   & 50    &  1.8\%  &  702    &  25.1\%   &  0   & 0.0\% \\
\hline
java.sql   &  \hfill 3495   & 20   &  0.6\% & 183   &  5.2\%  & 0   & 0.0\%\\
\hline
text  &  \hfill 1068   & 96   &  9.0\% & 321   &  30.1\%  & 0  & 0.0\%\\
\hline
util  &  \hfill 9586   & 1372   &  14.3\%  & 1879    &  19.6\%  & 341    & 3.6\%\\
\hline
acc.  &  \hfill 237   & 1    &  0.4\%  & 25    &  10.5\%  & 0   & 0.0\%  \\
\hline
activation     &  \hfill 538   & 0    &  0.0\%  & 165   &  30.7\%  & 0   & 0.0\%  \\
\hline
crypto        &  \hfill 625   &  0    &  0.0\%  &  263  &  42.1\%  &  0    & 0.0\%\\
\hline
man.   &  \hfill 5380   & 2    &   0.0\%  & 0     &  0.0\%  & 0    & 0.0\%  \\
\hline
naming       &  \hfill 3565   & 0    &   0.0\%  & 1365   &  38.3\%  &  0    & 0.0\%  \\
\hline
javax.sec.       &  \hfill 1435  & 0     &  0.0\%  & 619     &  43.1\%  & 0    & 0.0\%\\
\hline
sound          &  \hfill 515   & 0    &  0.0\%  & 56    &  10.9\%  & 0   & 0.0\%  \\
\hline
swing          &  102389& 10   &  0.0\%  &  21364 &  20.9\%   &  0   & 0.0\%\\
\hline
javax.xml            &  \hfill 4188  &  34   &  0.8\% &  580   &  13.8\%  & 0  & 0.0\%\\
\hline
org.omg              &  \hfill 8937   & 0    &  0.0\%  & 1578  &  17.7\%  & 0   & 0.0\%  \\
\hline
w3c.dom          &  \hfill 83     & 0    &  0.0\%  & 14     &  16.9\%   & 0   & 0.0\%  \\
\hline
org.xml             &   \hfill 897    & 49   &  5.5\%  & 473    & 52.7\%    & 0   & 0.0\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of package level} \label{table:package}
\end{SmallOut}\vspace*{-4ex}
\end{table}

For Java2CSharp, JLCA, and sharpen, we further present their testing results at the package level in Table~\ref{table:packagetest}. Column ``Name'' lists names of J2SE packages. For columns ``Java2CSharp'', ``JLCA'', and ``sharpen'', sub-column ``R'' lists numbers of generated Java test cases, and sub-column ``\%'' lists percentages from test cases end with errors or failures to total test cases. From the results of Table~\ref{table:packagetest}, we find that for the \CodeIn{java.sql} package and the \CodeIn{java.util} package, all the tools suffer relatively high error/failure percentages, and for the \CodeIn{java.lang} package and the \CodeIn{java.math} package, all the tools achieve relatively low error/failure percentages. The results may reflect that some packages between Java and C\# are more similar than others, so they can more easily mapped. We also find that for package the \CodeIn{java.text} package, the \CodeIn{javax.xml} package, and the \CodeIn{org.xml} package, JLCA achieves the lowest error/failure percentages among the five tools. The results may indicate that a translation tool can achieve better translation results if they carefully prepare mapping relations of API invocations.


From the results of Table~\ref{table:singleinvoc} and Table~\ref{table:packagetest}, we find that many generated Java tests do not get passed. To better understand behavior differences of mapped API invocations, we manually inspected 3759 Java test cases that do not get passed. For Java2CSharp, JLCA, and sharpen, we investigate their test cases for the \CodeIn{java.lang} package. For tools such as Net2Java and converter, we inspect all their test cases since TeMAPI does not generate too many test cases for them. Our findings are as follows:

\textbf{Finding 1:} 36.8\% test cases show the behavior differences caused by null inputs.

We find that Java API methods and their translated C\# API methods can have behavior differences when inputs are null values. In some cases, a Java API method can accept null values, but its translated C\# API method throws exceptions given a null value. One such example is shown in Section~\ref{sec:example} (\emph{i.e}, the \CodeIn{skip(long)} method in Java and its mapped C\# methods). In some other cases, a Java API method throws exceptions given a null value, but its translated C\# API method can accept null values. For example, JLCA translates the \CodeIn{java.lang.Integer.parseInt(String,int)} method in Java to the \CodeIn{System.Convert.ToInt32(string,int)} in C\#. When the inputs of the Java method are null and 10, it throws \CodeIn{NumberFormatException}, but given the same inputs, the output of the C\# method is 0. We notice that some translation tools can hide some differences caused by null inputs. For example, to hide the behavior difference of null inputs for the \CodeIn{valueOf(Object)} method as shown in Section~\ref{sec:approach:single}, sharpen translates the method to its self-developed C\# method, and thus hide the difference.



\Comment{We also find that given the same inputs, a method may produce null outputs, whereas its mapped method will not. For example, converter maps the \CodeIn{Sys- tem.Collections.Queue.ToArray()} in C\# to the \CodeIn{java.util. LinkedList.toArray()} method in Java. Given an empty list, the C\# method produce a null value, whereas the Java method produce an empty array.}


\textbf{Implication 1:} Although implementers of API libraries in different languages can come to agreements on functionalities of many API methods, behaviors for null inputs are typically controversial. Some translation tools try to hide the difference, but many such differences are still left to programmers as shown in our results. Therefor, programmers should be careful when inputs are null.

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Name}}
& \multirow{2}*[-2pt]{\textbf{Java}} & \multicolumn{2}{|c|}{\textbf{Error}}& \multicolumn{2}{|c|}{\textbf{Failure}} \\\cline{3-6}  &  & \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}\\
\hline
Java2CSharp  &   15458 & 5248 & 34.0\% & 3261 & 21.1\% \\
\hline
JLCA         &   33034 & 8901 & 26.9\% & 6944 & 21.0\% \\
\hline
sharpen      &  2730 & 662  & 24.2\% & 451  & 16.5\%\\
\hline
net2java     &   352 & 40   & 11.4\%  & 261   & 74.1\%\\
\hline
converter    &  762 & 302  & 39.6\% & 182   & 23.9\%\\
\hline
Total        &  52336  &  15153 & 29.0\% &11099 & 21.2\%  \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing single invocations} \label{table:singleinvoc}
\end{SmallOut}\vspace*{-4ex}
\end{table}


\textbf{Finding 2:} 22.3\% test cases show the behavior differences caused by stored string values.

We find that string values stored in fields of Java classes and C\# classes are typically different. The difference ranks as the second because each Java class has a \CodeIn{toString()} method and each C\# class also has a \CodeIn{ToString()} method. Many translation tools map the two API methods, but the return values of the two methods are quite different in many cases. As another example, many API classes declare methods like \CodeIn{getName} or \CodeIn{getMessage}. These methods also return string values that can be quite different. In particular, we find that the \CodeIn{Message} fields of exceptions in C\# often return informative messages. One such message is ``Index was outside the bounds of the array'' provided by the \CodeIn{System.Index- OutOfRangeException.Message} field. On the other hand, exceptions in Java often provide only null messages. Overall, we find that all the five tools do not hide the difference.

\textbf{Implication 2:} String fields of mapped classes in different languages typically store different values, but existing translation tool do not hide difference. Programmers should not rely on these values since they are typically different across languages.

\textbf{Finding 3:} 11.5\% test cases show the behavior differences caused by illegal inputs or inputs out of ranges.

We find that API methods in Java seldom check whether their inputs are legal or out of range, whereas API methods in C\# often do. For example, the \CodeIn{java.lang.Boolean.parseBoolean(String)} method in Java does not check illegal inputs, so it returns false given an input whose value is ``test''. Java2CSharp translates the Java method to the \CodeIn{System.Boolean.Parse(String)} method in C\#. The C\# method throws \CodeIn{FormatException} given the same input since it checks illegal inputs. As another example, the \CodeIn{java. lang.Double.shortValue()} method in Java accepts values that are larger than \CodeIn{Short.MAX\_VALUE} (32767). JLCA maps the Java method to the \CodeIn{Convert.ToInt16(double)} method in C\#. The C\# method throws \CodeIn{OverflowException} when values are larger than 32767 since it checks whether inputs are too large.

\textbf{Implication 3:} API methods across languages may follow different standard to check their inputs for different considerations. If a tool translates code from a loose standard to a strict standard (\emph{e.g.}, Java to C\#), it can add extra code to strengthen the standard. If a tool translates code from a strict standard to a loose standard (\emph{e.g.}, C\# to Java), it will be difficult to hide the difference. When programmers migrate from one language to another, they should check whether a new language follow a strict standard or not.

\textbf{Finding 4:} 10.7\% test cases show the behavior differences caused by different understanding.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|p{3.4em}|r|r|r|r|r|r|r|r|r|r|}
 \hline
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{Name}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{2-7} &  \textbf{R}&  \textbf{\%} &   \textbf{R}& \textbf{\%} & \textbf{R}&   \textbf{\%}\\
\hline
bean &  \hfill 17     &    82.4\%  &  18        &  33.3\%   &  0      & n/a \\
\hline
io   &  \hfill 4155   &  67.8\%  &  6981       &  58.0\%   &   33    & 1.4\%\\
\hline
lang &  \hfill 3480   &   37.5\%  &  4431      &  26.1\%   &   1753 & 29.3\%\\
\hline
math &  \hfill 561    &   4.3\%  &   1629     &   1.5\%   &  0      & n/a\\
\hline
java.net  &   438     &   25.1\% &   3941     &   47.8\%  & 9       & 44.4\%  \\
\hline
nio  &  \hfill 27     &  48.1\% &    0        &   n/a     &  0     &  n/a \\
\hline
java.rmi  &  \hfill 0   &   n/a   &   884     &   32.6\%  &  0     & n/a\\
\hline
java.sec. &  \hfill 45  &   55.6\%  &  828    &  35.6\%   &  0    & n/a \\
\hline
java.sql   &  \hfill 260&   88.1\%  & 1465    &  91.0\%   &   0     & n/a\\
\hline
text  &  \hfill 566   &   61.5\%  & 374      &  18.2\%   & 0      & n/a\\
\hline
util  &  \hfill 5519  &   60.8\%  & 6177     & 70.2\%  & 935      & 62.4\%\\
\hline
acc.  &  \hfill 1    &   0.0\%   & 0         & n/a    & 0          & n/a \\
\hline
activation  &  0     &    n/a    & 694      & 53.9\% & 0           & n/a  \\
\hline
crypto      &  0     &     n/a    & 298     & 24.2\% &  0        & n/a\\
\hline
man.        &  2     &    0.0\%  & 0        & n/a    &  0          & n/a  \\
\hline
naming      &  0     &    n/a     & 1569    & 40.6\%  &  0         & n/a  \\
\hline
javax.sec.  &  0     &   n/a     & 683     & 45.9\%  &  0        & n/a\\
\hline
sound       &  0     &   n/a     & 66       & 36.4\%  &   0        &n/a  \\
\hline
javax.xml   &  110   &    71.8\%  &  628    & 45.9\%  &   0         & n/a\\
\hline
org.omg     &  0     &   n/a     & 1842    & 45.9\%  & 0           & n/a  \\
\hline
w3c.dom     &  0     &   n/a     & 18      & 33.3\%  &  0         & n/a  \\
\hline
org.xml     &   277  &   70.0\%  & 483     & 27.3\%  & 0         & n/a\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Testing results of package level } \label{table:packagetest}
\end{SmallOut}\vspace*{-4ex}
\end{table}

We find that Java developers and C\# developers may have different understanding for mapped API methods. For example, the \CodeIn{java.lang.StringBuffer.capacity()} method in Java returns ``the current capacity of the String buffer'', and the \CodeIn{System.Text. StringBuilder.Capacity} field in C\# returns ``the maximum number of characters that can be contained in the memory allocated by the current instance''. JLCA maps the method in Java to the field in C\#, and we find that in many cases they are of different values. For sample, given a string whose value is ``0'', the \CodeIn{capacity()} in Java returns 0, but the \CodeIn{Capacity} field in C\# is 16. We notice that some differences of this type may indicate defects in translation tools. For example, Java2CSharp maps the \CodeIn{java.lang.Integer. toHexString(int)} method in Java to the
\CodeIn{ILOG.J2CsMapping. Util.IlNumber.ToString(int,16)} method in C\#. Given a integer whose value is -2147483648, the Java method returns ``80000- 000'', but the C\# method returns ``\textbackslash080000000''. As another example, Java2CSharp maps the \CodeIn{Character.isJavaIdentifierPart (char)} method in Java to the \CodeIn{ILOG.J2CsMapping.Util.Charac- ter.IsCSharpIdentifierPart(char)} method in C\#. Given a input whose value is '\textbackslash0', the Java method returns true, but the C\# method return false. The two behavior differences were confirmed as bugs by developers of Java2CSharp.

\textbf{Implication 4:} Although implementers can come to agreement on functionalities of many API methods, they may have different understanding on functionalities of specific methods. Some differences of this type are confirmed as defects in translation tools. Programmers should test their translated code carefully since this type of differences are difficult to figure out.


\textbf{Finding 5:} 7.9\% test cases show the behavior differences caused by exception handling.

We find that two mapped API methods can throw exceptions that are not mapped. For example, when indexes are out of bounds, the \CodeIn{java.lang.StringBuffer.insert(int,char)} method in Java throws \CodeIn{ArrayIndexOutofBoundsException}. Java2CSharp maps the methods to the \CodeIn{StringBuilder.Insert(int,char)} method in C\# that throws \CodeIn{ArgumentOutOfRangeException} when indexes are out of bounds. As Java2CSharp maps \CodeIn{ArrayIndexOut- ofBoundsException} in Java to \CodeIn{IndexOutOfRangeException} in C\#, the mapped C\# method may fail to catch exceptions when indexes are out of bounds.

\textbf{Implication 5:} Implementer of API libraries may design quite different exception handling mechanism. This type of differences are quite challenge to hide for translation tools. Even if two methods are of the same functionality, programmers should notice that they may produce exceptions that are not mapped. 

\textbf{Finding 6:} 2.8\% test cases show the behavior differences caused by static values.

We find that mapped static fields may have different values. For example, the \CodeIn{java.lang.reflect.Modifier} class has many static fields to represent modifiers (\emph{e.g.}, FINAL, PRIVATE and PROTECTED). Java2CSharp translates these fields to the fields of the \CodeIn{ILOG.J2CsMapping.Reflect} class. Although most mapped fields of the two class are of the same values, we find that fields such as VOLATILE and TRANSIENT are of different values. In addition, we find that different values sometimes reveal different ranges of data types. For example, \CodeIn{java.lang.Double.MAX\_VALUE} in Java is 1.7976931348623157E+308, and \CodeIn{System.Double.MaxValue} in C\# is 1.79769313486232E+308. It seems infeasible for a translation tool to hide such difference. Although the difference is not quite large, it can cause serious defects if a program needs highly accurate calculation results.

\textbf{Implication 6:} Implementer of API libraries may assign different values to static fields. Even if two static fields have the same names, programmers should be aware of that they can have different values. The results also reveal that data types between Java and C\# can have different bounds define different boundaries for data types. Programmers should be aware of this if they need highly accurate results of extremely large or small computation results. 

The rest 7.9\% test cases do not get passed since API methods can produce random values or values that depend on time. For example, the \CodeIn{java.util.Random.nextDouble()} method in Java returns random values, and the \CodeIn{java.util.Date.getTime()} method returns the number of milliseconds since Jan. 1st, 1970, 00:00:00 GMT. As another example, each Java class has a \CodeIn{hashCode()} method inherited from the \CodeIn{java.lang.Object} class, and each C\# class has a \CodeIn{GetHashCode()} inherited from the \CodeIn{System.Object} class. Both the two methods return a hash code for the current object, so translation tools such as JLCA map the two methods. For these methods, TeMAPI can find their behavior differences of inputs. For example, converter maps the \CodeIn{System.Random.Next(int)} method in C\# to the \CodeIn{java.util.Random.nextInt(int)} method in Java. Given a integer whose value is 0, the C\# method return 0, but the Java method throws \CodeIn{IllegalArgumentException} with a message: ``n must be positive''. However, as these methods generate outputs randomly, we cannot conclude they have behavior differences even if corresponding Java test cases all fail, and we discuss this issue in Section~\ref{sec:discuss}.

\subsection{Testing Multiple Classes}
\label{sec:evaluation:sequence}
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Name}}& \multirow{2}*[-2pt]{\textbf{API}} & \multirow{2}*[-2pt]{\textbf{Java}}
& \multirow{2}*[-2pt]{\textbf{C\#}} & \multicolumn{2}{|c|}{\textbf{Failure}} \\\cline{5-6} & &  & & \textbf{M}& \textbf{\%} \\
\hline
Java2CSharp  &  1996 & 15385&  2971 & 2151 & 72.4\%\\
\hline
JLCA         &  7060 & 16630& 1067 & 295  & 27.6\%  \\
\hline
sharpen      &  586  & 13532& 936  & 456  & 48.7\% \\
\hline
Total        &  9642 & 45547& 4504  &  2813 & 62.5\% \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing multiple invocations} \label{table:invocsequence}
\end{SmallOut}\vspace*{-4ex}
\end{table}

To test behavior differences of API invocation sequences, TeMAPI leverage Randoop to generate test cases that involve multiple API invocations. For each Java-to-C\# tools, TeMAPI first analyzes the translation results as shown in Table~\ref{table:java2csharp} for the list of translatable API invocations in Java. When generating test cases, TeMAPI extends Randoop, so that each generated test case use only translatable API invocations. Randomly generated invocation sequences may not reflect API usages in true practice. We discuss this issue in Section~\ref{sec:discuss}. We find that Randoop can generate failure test cases or even test cases with compilation errors. TeMAPI removes those test cases, so that the remaining test cases all get passed. After that, we use the corresponding translation tool to translate the remaining test cases from Java to C\#. As the remaining Java test cases all get passed, translated C\# test cases should also get passed.

Table~\ref{table:invocsequence} shows the results. Column ``API'' lists sizes of translatable API invocations. Column ``Java'' lists numbers of Java test cases that run successfully. Column ``C\#'' lists numbers of C\# test cases. We notice that many Java test cases are not successfully translated into C\# test cases. We find that two factors that are not general or not related with API migration: (1) some generated Java test cases use classes defined by Randoop; (2) some code structures are complicated to translate, and we further discuss this issue in Section~\ref{sec:discuss}. Besides the two factors, we find one general factors for API translation.

\textbf{Finding 7:} Many translated test cases have compilation errors since Java classes and their mapped C\# classes have different inheritance relations.

We find that Java API classes can have quite different inheritance relations with their mapped C\# API classes, and thus introduce compilation errors in cast statements. For example, a Java test case is as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
public void test87() throws Throwable\{
  ...
  StringBufferInputStream var4=...;
  InputStreamReader var10=
    new InputStreamReader((InputStream)var4, var8);
\}
\end{alltt}
\end{CodeOut}

JLCA translates the Java test case into a C\# test case as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
public void test87() throws Throwable\{
  ...
  StringReader var4=...;
  StreamReader var10=
    new StreamReader((Stream)var4, var8);
\}
\end{alltt}
\end{CodeOut}

As the two Java classes are subclass and parent class, the Java test case runs successfully, whereas the two C\# class have no such relations so translated C\# method has compilation errors.

\textbf{Implication 7:} Programmers should use cast statements carefully since classes of two languages typically have different inheritance relations.

Column ``Failure'' lists failed C\# test cases. We do not list numbers of test cases with errors since C\# does not separate errors from failures as Java does. Sub-column ``M'' lists numbers of test cases, and sub-column ``\%'' lists percentages from failed test cases to total test cases.

From the results of Table~\ref{table:invocsequence}, we find that JLCA achieves better results than other tools since its percentage is the lowest. For each tool, we further investigate the first 100 failed test cases, and we find that 93.3\% failed test cases are accumulated by the found factors as shown in Section~\ref{sec:evaluation:single}: 45.0\% for ranges of parameters, 34.0\% for string values, 5.3\% for different understanding, 4.0\% for exception handling, 3.0\% for null values, 2.0\% for values of static fields, and 0.3\% for random values. We find that random strategy affect the distribution. For example, as invocation sequences are random, inputs of many methods are out of range or illegal. Java API methods typically do not check inputs, so generated Java test cases run successfully, but translated C\# test cases fail with various exceptions since C\# API methods typically check inputs. Besides those found factors, we find additional two factors as follows:

\textbf{Finding 8:} 3.3\% test cases fail because of invocation sequences.

We find that random invocation sequences can violate specifications of API libraries. One type of such specification is described in our previous work~\cite{zhong09:inferring}: closed resources should not be manipulated. Java sometimes allow programmers to violate such specifications although the return values can be meaningless. One such example is shown in Section~\ref{sec:example}. Besides invocation sequences that are related to specifications, we find that field accessibility also leads to failures of test cases. For example, a generated Java test case is as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
public void test423() throws Throwable\{
  ...
  DateFormatSymbols var0=new DateFormatSymbols();
  String[] var16=new String[]{...};
  var0.setShortMonths(var16);
\}
\end{alltt}
\end{CodeOut}

JLCA translates the Java test case into a C\# test case as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
public void test423() throws Throwable\{
  ...
  DateTimeFormatInfo var0 =
  System.Globalization.DateTimeFormatInfo.CurrentInfo;
  String[] var16=new String[]{...};
  var0.AbbreviatedMonthNames = var16;
\}
\end{alltt}
\end{CodeOut}

The \CodeIn{var0.AbbreviatedMonthNames = var16} statement fails with \CodeIn{InvalidOperationException} since a constant value is assigned to \CodeIn{var0}.

\textbf{Implication 8:} When translating, programmers should check carefully whether they violate speculations of libraries and whether invocation sequences affect accessibility of fields.

The rest 3.0\% test cases fail since mapped methods are not implemented. In particular, Java2CSharp maps API invocations in Java to C\# API invocations that are not implemented yet. For example, Java2CSharp maps the \CodeIn{java.io.ObjectOutputStream} class in Java to the \CodeIn{ILOG.J2CsMapping.IO.IlObjectOutput- Stream} class in C\# that is not implemented yet, and such mapping relations lead to \CodeIn{NotImplementException}. As this difference introduces no compilation errors, programmers should test translated projects carefully to ensure each API method is called.
\subsection{Coverage}
\label{sec:evaluation:coverage}

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\textbf{Class}& \textbf{Pex} & \textbf{Randoop}
& \textbf{TeMAPI} \\
\hline
ManagerNotRecognizedException  &  100\% & 100\% &  100\%\\
\hline
ManagerNotSupportedException   &  100\% & 100\% &  100\%  \\
\hline
SaxAttributesSupport           &  78\%  & 74\%  &  80\%\\
\hline
XmlSaxDefaultHandler           &  100\% & 94\%  &  100\%\\
\hline
XmlSAXDocumentManager          &  29\%  & 17\%  &  29\%\\
\hline
XmlSaxLocatorImpl              &  83\%  & 100\%  &  100\%\\
\hline
XmlSaxParserAdapter            &  100\%  & 100\%  &  100\%\\
\hline
XmlSourceSupport               &  100\%  & 56 \%  &  100\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing coverage} \label{table:coverageJLCA}
\end{SmallOut}\vspace*{-4ex}
\end{table}

Test coverage is a common criterion to measure the adequacy of test cases~\cite{zhu1997software}. To investigate whether our combination strategy helps achieve better coverage from Java to C\#, we conduct an experiment on JLCA, and Table~\ref{table:coverageJLCA} shows the results. Is trick to extract coverage of API methods, especially in our context where most mapping relations are between J2SE and .NetFramework. For example, we find that coverage tools such as PartCover\footnote{\url{http://partcover.blogspot.com/ }} rely on the \CodeIn{JITCompilationStarted} method\footnote{\url{http://tinyurl.com/2gy2nqk}} for notifications of called methods, and thus fail to extract coverage for many methods in .NetFramework since usually no notifications are received when these method are called. As a result, we choose the \CodeIn{org.xml} package in Java as the subject. JLCA generates eight classes as shown in Table~\ref{table:coverageJLCA}, and translates some classes of the \CodeIn{org.xml} package in Java to the eight C\# classes. Column ``Class'' shows the names of the eight classes. Column ``Pex'' lists achieved coverage if leveraging only Pex. Column ``Randoop'' lists  achieved coverage if leveraging only Randoop. We limit the search scope of Randoop to the \CodeIn{org.xml} package, and translate generated Java test cases into C\# using JLCA As Pex searches feasible paths and Randoop relies on random strategy, Pex achieves better coverage than Randoop except the \CodeIn{XmlSaxLocatorImpl} class. We find that Pex can fail to generate non-null values for some interfaces. For example, the parameter of the \CodeIn{XmlSaxLocatorImpl(XmlSaxLocator)} constructor is an interface. Pex generates only null inputs for the constructor, but Randoop casts a value to the interface. As a result, Randoop achieves better coverage on this class than Pex. Still, both Pex and Randoop do not achieve high coverage for some classes such as the \CodeIn{XmlSAXDocumentManager} class. We find that some methods of the class cannot be covered unless it reads a file. As both Pex and Randoop generates filenames randomly, these methods are not covered by either tool. Column ``TeMAPI'' lists  achieved coverage if combining Pex and  Randoop. We find that the combination achieves the best results for all classes.

To investigate whether our combination strategy helps achieve better coverage from C\# to Java, we conduct an experiment on converter, and Table~\ref{table:coverageconverter} shows the results.  For similar consideration, we select several classes (\emph{i.e.}, the \CodeIn{System.Collections.Array- List} class, the \CodeIn{System.Collections.Hashtable} class, the \CodeIn{Sys- tem.Collections.Queue} class, and the \CodeIn{System.Collections. Stack} class). Table~\ref{table:coverageconverter} shows coverage of their translated classes in Java. The four Java classes are decompiled by JAD\footnote{\url{http://www.varaneckas.com/jad}}. To compile the four Java classes, we fix defects introduced during decompiling, and change their package names. Column ``Class'' shows the names of the four Java classes. Column ``Pex'' lists achieved coverage if leveraging only Pex. We use TeMAPI to generates Java test cases when Pex searches feasible paths. Column ``Randoop'' lists  achieved coverage if leveraging only Randoop. From the perspective of the four Java classes, Pex also generates test cases randomly since it does not search their feasible paths. As a result, the achieved coverage shown in Table~\ref{table:coverageconverter} are also half to half. Column ``TeMAPI'' lists  achieved coverage if combining Pex and  Randoop. We also find that the combination achieves the best results.

In summary, by combing Pex and Randoop, TeMAPI achieve higher coverage than with single tools.
\subsection{Summary}
\label{sec:evaluation:summary}
In summary, we find that API invocations are quite large in size, and translation tools typically cover only a small set of API invocations. Although existing translation tools already notice behavior differences of mapped API invocations, many differences are left unsolved. In particular, TeMAPI detects that various factors such as null values, string values, ranges of inputs, different understanding, exception handling, and static values can lead to behavior differences for single API invocations. The preceding factors can accumulate to behavior differences of multiple API invocations. Besides, TeMAPI detects that other factors such as cast statements and invocation sequences can also lead to behavior differences of multiple API invocations.
\subsection{Threats to Validity}
\label{sec:evaluation:threat}
The threats to external validity include the representativeness of the subject tools. Although we applied
our approach on 5 widely used translation tools, our approach is evaluated only on these limited tools. This threat could be reduced by introducing more subject tools in future work. The threats to internal validity include human factors for inspecting behavior differences from failed test cases. To reduce these threats, we inspected those test cases carefully. The threat could be further
reduced by introducing more researchers to inspect detected differences.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\textbf{Class}& \textbf{Pex} & \textbf{Randoop}
& \textbf{TeMAPI} \\
\hline
HashTable                      &  23\%  & 15\%  &  26\%\\
\hline
LinkedList                     &  32\%  & 26\%  & 37\%\\
\hline
ArrayList                      &  18\%  & 25\%  &  31\%\\
\hline
Stack                          &  21\%   & 55\%  &  55\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing coverage} \label{table:coverageconverter}
\end{SmallOut}\vspace*{-4ex}
\end{table} 