\section{Evaluations}
\label{sec:evaluation}

We implemented a tool for TeMaAPI and
conducted evaluations using our tool to address the following
research questions:

%\vspace*{-1.5ex}
\begin{enumerate}
\item How effectively can existing migration tool translate API invocations (Section~\ref{sec:evaluation:invocation})? \vspace*{-1.8ex}
\item How effectively can our approach detect different behaviors of single API invocations (Section~\ref{sec:evaluation:single})? \vspace*{-1.8ex}
\item How effectively can our approach detect different behaviors of API invocation sequences (Section~\ref{sec:evaluation:sequence})?
\end{enumerate}%\vspace*{-1.5ex}

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|l|c|c|c|c|c|c|}
 \hline
\textbf{Name}& \textbf{Version}& \textbf{Source} &\textbf{Description}\\
\hline
Java2CSharp  &  1.3.4 & IBM (ILOG) & Java to C\# \\
\hline
JLCA         &  3.0   & Microsoft  & Java to C\# \\
\hline
sharpen      &  1.4.6 & db4o       & Java to C\# \\
\hline
Net2Java     &  1.0   & NetBean    &  C\# to Java\\
\hline
VB \& C\# to Java converter    &  1.6   & Tangible   &  C\# to Java\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Subject tools} \label{table:subjects}
\end{SmallOut}\vspace*{-2ex}
\end{table}

Table~\ref{table:subjects} shows the subject tools in our evaluation. Column ``Name'' lists the names of subject tools. In the rest of the paper, we call ``VB \& C\# to Java converter'' as converter for short. Column ``Source'' lists their companies. Although all these tools are developed by commercial companies, Java2CSharp, sharpen, and Net2Java are all open source. Column ``Description'' lists the main functionalities of subject tools. We choose these tools as subjects since we find that many programmer recommend these tools in various forums.

All evaluations were conducted on a PC with Intel Qual CPU @
2.83GHz and 1.98M memory running Windows XP.

\subsection{Translating Generated Client Code}
\label{sec:evaluation:invocation}
For Java to C\# tools, we use TeMaAPI to generate client-code methods for J2SE 6.0\footnote{\url{http://java.sun.com/javase/6/docs/api/}}. As described in Section~\ref{sec:approach:generating}, TeMaAPI ignores all generic API methods. Table~\ref{table:java2csharp} shows the translation results. Column ``Type'' lists the types of generated methods. In particular, ``sfg'' denotes getters of static fields; ``sfs'' denotes setters of static fields; ``nfg'' denotes getters of non-static fields; ``nfs'' denotes setters of non-static fields; ``sm'' denotes static methods; ``nm'' denotes non-static methods; and ``Total'' denotes the sums of all methods. Column ``Number'' lists numbers of corresponding types of methods. Columns ``Java2CSharp'', ``JLCA'', and ``sharpen'' list the translation results of corresponding migration tools. For these columns, sub-column ``M'' lists the number of translated methods without compilation errors, and sub-column ``\%'' lists the percentage from translated method without compilation errors to corresponding generated methods.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Type}}&
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{No}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{3-8} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}&  \textbf{M}& {\%}\\
\hline
sfg  &  16962 & 237 & 1.4\% & 3744 & 22.1\% & 47 & 0.3\%\\
\hline
sfs  &  0    & 0    & n/a   & 0    & n/a    & 0  & n/a  \\
\hline
nfg  &  832  & 0    & 0.0\% & 121  & 14.5\% & 26 & 2.2\%\\
\hline
nfs  &  823  & 0    & 0.0\% & 79   & 9.6\%  & 0   & 0.0\%\\
\hline
sm   &1175   & 97   & 8.3\% & 198  & 16.9\% & 26  & 2.2\%\\
\hline
nm   &175400 & 3589 & 2.0\% & 39536& 22.5\% & 1112& 0.6\%  \\
\hline
Total &195192& 3923 &  2.0\% & 43678 & 22.4\% & 1185 & 0.6\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of Java to C\# tools} \label{table:java2csharp}
\end{SmallOut}\vspace*{-2ex}
\end{table}

From the results of Table~\ref{table:java2csharp}, we find that it is quite challenging for a migration tool to cover all API invocations. One challenge lies in that APIs are quite large in size. Although JLCA can translate 43678 generated methods, it covers only 22.4\% of total generated methods. The other challenge lies in that many API invocations of different languages cannot be accurately mapped. For example, as pointed out by our previous work~\cite{zhong2010mining}, one API method in one language may be mapped to several API methods in another language. We find that all the three migration tools have techniques to deal with the differences. In particular, Java2CSharp and sharpen develop their own assemblies and map some API invocations to their implemented assemblies instead of standard C\# API invocations. For example, Java2CSharp maps the \CodeIn{java.lang.Class.forName (String)} method in Java to the \CodeIn{ILOG.J2CsMapping.Reflect. Helper.GetNativeType(String)} method in C\#, and the latter method is provided by Java2CSharp. JLCA does not implement additional assemblies, but generate additional source code to hide different behaviors. For example, TeMaAPI generates one method for \CodeIn{java.awt.Dialog.add(Component m0,int m1,} \CodeIn{Frame c0)}:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
public Component testadd79nm(Component m0,int m1,Frame c0)\{
  java.awt.Dialog obj = new java.awt.Dialog(c0);
  return obj.add(m0,m1);
\}
\end{alltt}
\end{CodeOut}

JLCA translates the preceding method as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
@Test
public virtual Control testadd79nm(Control m0, int m1, 
                                              Form c0)\{
  Form obj = SupportClass.DialogSupport.CreateDialog(c0);
  Control temp_Control;
  temp_Control = m0;
  obj.Controls.Add(temp_Control);
  if (m1 != -1)
    obj.Controls.SetChildIndex(temp_Control, m1);
  return temp_Control;
\}
\end{alltt}
\end{CodeOut}

JLCA maps the API method in Java into many API methods in C\#. Besides adding a temporary variable named \CodeIn{tmp\_Control}, JLCA generates a class named \CodeIn{SupprtClass} where more API invocations are introduced.

Although all the three migration tools take the different behaviors of mapped APIs seriously, they do not cover all differences of API mapping relations. For example, when JLCA translates generated code, it generates a report with 1265 warning messages for different behaviors of API mapping relations. One warning message is ``Method 'java.lang.String.indexOf' was converted to 'System.String.IndexOf' which may throw an exception''. Still, the report does not tell programmers when such an exceptions will be thrown, and the rest of our evaluation targets at the problem. 


\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Type}}&
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{No}}}
& \multicolumn{2}{|c|}{\textbf{Net2Java}} & \multicolumn{2}{|c|}{\textbf{converter}}\\\cline{3-6} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}\\
\hline
sfg  &  3223 & 1    & 0.0\% & 3    & 0.1\% \\
\hline
sfs  &  8    & 0    & 0.0\% & 0    & 0.0\%   \\
\hline
nfg  &  117  & 0    & 0.0\% & 0    & 0.0\%\\
\hline
nfs  &  115  & 0    & 0.0\% & 0    & 0.0\%\\
\hline
sm   &996    & 22   & 2.2\% & 387  & 38.9\% \\
\hline
nm   &190376 & 4    & 0.0\% & 6    & 0.0\% \\
\hline
Total &194835& 27   &  0.0\% & 396 & 0.2\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of C\# to Java tools} \label{table:csharp2java}
\end{SmallOut}\vspace*{-2ex}
\end{table}

For C\# to Java migration tools, we use TeMaAPI to generate client-code methods for the .Net framework client profile\footnote{\url{http://tinyurl.com/252t2ax}}. As described in Section~\ref{sec:approach:generating}, besides generic methods, TeMaAPI also ignores methods whose parameters are marked with \CodeIn{out} or \CodeIn{ref}. Table~\ref{table:csharp2java} shows the translation results. Columns of Table~\ref{table:csharp2java} are of the same meanings with the columns of Table~\ref{table:java2csharp}. From the results of Table~\ref{table:java2csharp}, we find that TeMaAPI generates almost the same size of methods as it generates for J2SE 6.0, and both the two tool translate only quite a small size of API invocations. As described in the wikipedia\footnote{\url{http://tinyurl.com/yj4v2m2}}, C\# provides many features that Java does not have (\emph{e.g.}, partial class, reference parameters, output parameters, and named arguments). We suspect that a C\# to Java migration tool needs to deal with these differences, so many mapping relations of APIs are not addressed yet. 
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|p{3.6em}|r|r|r|r|r|c|c|}
 \hline
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{Name}}}&
\multicolumn{1}{|c|}{\multirow{2}*[-2pt]{\textbf{No}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{3-8} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}&  \textbf{M}& {\%}\\
\hline
awt  &  29199  & 0     &  0.0\%  &  8637  &  29.6\%  &  0   & 0.0\%\\
\hline
bean &  \hfill 1768   & 20    &  1.1\%  &  14    &  0.8\%   &  0   & 0.0\% \\
\hline
io   &  \hfill 3109   & 592   &  19.0\% & 1642   &  52.8\%  & 43   & 1.4\%\\
\hline
lang &  \hfill 5221   & 1494  &  28.6\% & 2377   &  45.5\%  & 791  & 15.2\%\\
\hline
math &  \hfill 1584   & 101   &  6.4\%  & 232    &  14.6\%  & 0    & 0.0\%\\
\hline
net  &  \hfill 1990   & 52    &  2.6\%  & 482    &  24.2\%  & 10   & 0.5\%  \\
\hline
nio  &  \hfill 536    & 30    &  5.6\%  & 0      &  0.0\%  &  0    & 0.0\%  \\
\hline
java.rmi  &  \hfill 1252   & 0     &  0.0\%  &  707   &  56.5\%  &  0   & 0.0\%\\
\hline
security &  \hfill 2797   & 50    &  1.8\%  &  702    &  25.1\%   &  0   & 0.0\% \\
\hline
java.sql   &  \hfill 3495   & 20   &  0.6\% & 183   &  5.2\%  & 0   & 0.0\%\\
\hline
text  &  \hfill 1068   & 96   &  9.0\% & 321   &  30.1\%  & 0  & 0.0\%\\
\hline
util  &  \hfill 9586   & 1372   &  14.3\%  & 1879    &  19.6\%  & 341    & 3.6\%\\
\hline
acc.  &  \hfill 237   & 1    &  0.4\%  & 25    &  10.5\%  & 0   & 0.0\%  \\
\hline
activation     &  \hfill 538   & 0    &  0.0\%  & 165   &  30.7\%  & 0   & 0.0\%  \\
\hline
activity      &   \hfill 252   & 0    &  0.0\%  &  0    &  0.0\%   &  0   & 0.0\%\\
\hline
annotation    &  \hfill 19    &  0    &  0.0\%  &  0    &  0.0\%   &  0   & 0.0\% \\
\hline
crypto        &  \hfill 625   &  0    &  0.0\%  &  263  &  42.1\%  &  0    & 0.0\%\\
\hline
imageio      &  \hfill 1261   &  0    &  0.0\%  &  0    &  0.0\%  & 0      & 0.0\%\\
\hline
model       &  \hfill 103    & 0     &  0.0\%  & 0     &  0.0\%  & 0    & 0.0\%\\
\hline
man.   &  \hfill 5380   & 2    &   0.0\%  & 0     &  0.0\%  & 0    & 0.0\%  \\
\hline
naming       &  \hfill 3565   & 0    &   0.0\%  & 1365   &  38.3\%  &  0    & 0.0\%  \\
\hline
net           &  \hfill 285    & 0     &  0.0\%  &  0     &  0.0\%   &  0   & 0.0\%\\
\hline
print         &  \hfill 1534   & 0     &  0.0\%  &  0    &  0.0\%   &  0   & 0.0\% \\
\hline
javax.rmi           &  \hfill 45     &  0    &  0.0\%  & 0     &  0.0\%   & 0   & 0.0\%\\
\hline
script         &  \hfill 195   & 0     &  0.0\% &  0     &  0.0\%  & 0  & 0.0\%\\
\hline
security       &  \hfill 1435  & 0     &  0.0\%  & 0     &  0.0\%  & 0    & 0.0\%\\
\hline
sound          &  \hfill 515   & 0    &  0.0\%  & 56    &  10.9\%  & 0   & 0.0\%  \\
\hline
javax.sql            &  \hfill 640   & 0    &  0.0\%  & 0     &  0.0\%   & 0   & 0.0\%  \\
\hline
swing          &  102389& 10   &  0.0\%  &  21364 &  20.9\%   &  0   & 0.0\%\\
\hline
tools          &  \hfill 11    & 0     &  0.0\%  &  0    &  0.0\%   &  0   & 0.0\% \\
\hline
transaction    &  \hfill 264   &  0    &  0.0\%  & 0     &  0.0\%   & 0   & 0.0\%\\
\hline
javax.xml            &  \hfill 4188  &  34   &  0.8\% &  580   &  13.8\%  & 0  & 0.0\%\\
\hline
ietf        & \hfill  189   & 0     &  0.0\%  & 0     &  0.0\%  & 0    & 0.0\%\\
\hline
org.omg              &  \hfill 8937   & 0    &  0.0\%  & 1578  &  17.7\%  & 0   & 0.0\%  \\
\hline
w3c.dom          &  \hfill 83     & 0    &  0.0\%  & 14     &  16.9\%   & 0   & 0.0\%  \\
\hline
org.xml             &   \hfill 897    & 49   &  5.5\%  & 473    & 52.7\%    & 0   & 0.0\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Package level results} \label{table:package}
\end{SmallOut}\vspace*{-2ex}
\end{table}

Comparing the translation results between Java-to-C\# tools and C\#-to-Java tools, we find that Java-to-C\# tools cover much more API invocations. To fully explore the translation results of Java-to-C\# tools, we present the results of the package level in Table~\ref{table:package}. Column ``Name'' lists the names of Java packages. To save space, we omit the prefixes such as ``java.'', ``javax.'', and ``org.'' if it does not introduce ambiguity. We also use short names for some packages. In particular, `we use ``acc.'' to denote the \CodeIn{javax.accessibility} package, and ``man.'' to denote the \CodeIn{javax.management} package. Other columns of Table~\ref{table:package} are of the same meanings with the columns of Table~\ref{table:java2csharp}. From the results of Table~\ref{table:package}, we find that all the three migration tools cover the \CodeIn{java.io} package, the \CodeIn{java.lang} package, and the \CodeIn{java.util} package. The three packages may be quite important for most Java programs. Almost for all packages, JLCA covers more API invocations. In particular, JLCA covers GUI-related packages such as the \CodeIn{java.awt} package and the \CodeIn{javax.swing} package. As a result, JLCA can translate some Java programs with GUI interfaces whereas the other two tools cannot. Still, we find that all the three tools do not cover 15 packages. As most of these packages are related to networks, all the three tools will fail to translate a program that use network APIs.


In summary, we find that APIs are quite large in size, and migration tools typically cover only a small set of API invocations. Existing migration tools already notice the differences between mapped APIs, but many differences are left unsolved.
\subsection{Testing Single Invocations}
\label{sec:evaluation:single}


To test different behaviors of single invocations, TeMaAPI leverages Pex to search internal paths for C\# client-code methods. These methods include the translated C\# methods without compilation errors as shown in Table~\ref{table:java2csharp} and the generated C\# methods that can be translated into Java without compilation errors as shown in Table~\ref{table:csharp2java}. When Pex searches those paths, TeMaAPI records the inputs and output of each iteration. Based on these inputs and outputs, TeMaAPI generates JUnit test cases to ensure that the generated methods and the translated methods produce the same outputs given the same inputs. As it requires human interactions to test GUI related APIs, we filter out GUI related APIs such as awt and swing although some migration tools such as JLCA are able to translate some GUI related APIs. In addition, when Pex searches methods without return values, we ignore those paths that do not throw any exceptions since we cannot generate JUnit test cases for them.

We run the generated JUnit test cases, and Table~\ref{table:singleinvoc} shows the results. Column ``Name'' lists the name of migration tools. Columns ``Pass'', ``Failure'', and ``Error'' list passes, failures, and errors after running JUnit test cases, respectively. Sub-column ``M'' numbers of test cases. Sub-column ``\%'' list percentages from the numbers of corresponding test cases to the numbers of total generated test cases. From the results of Table~\ref{table:singleinvoc}, we find that different behaviors between mapped APIs are quite common since only half of generated JUnit test cases get passed. However, even if a JUnit test case does not get passed, we do not have fully confidence that it is caused by different behaviors of mapped APIs. For example, some API methods such as \CodeIn{java.util.Random.nextDouble()} generate random values. As a result, we find that its corresponding JUnit test case fails, but we cannot conclude that these methods have different behaviors.

To better understand different behaviors of mapped APIs, we manually inspect failures and errors of JUnit test cases. Tools such as Java2CSharp, JLCA, and sharpen have too many test cases to inspect manually, so we limit our scope within the \CodeIn{java.lang} package for these tools. We choose to investigate the \CodeIn{java.lang} package since as shown in Table~\ref{table:package} all the three migration tools covers many API invocations of this package. 


\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Name}}
& \multicolumn{2}{|c|}{\textbf{Pass}} & \multicolumn{2}{|c|}{\textbf{Failure}}& \multicolumn{2}{|c|}{\textbf{Error}} \\\cline{2-7}  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}&  \textbf{M}& {\%}\\
\hline
Java2CSharp  &   7094  & 45.9\% & 3124 & 20.2\% & 5246 & 33.9\% \\
\hline
JLCA         &   17189 & 52.0\% & 8901 & 26.9\% & 6944 & 21.0\% \\
\hline
sharpen      &  1617  & 59.2\% & 662  & 24.2\% & 451  & 16.5\%\\
\hline
net2java     &   51    & 14.5\% & 40   & 11.4\%  & 261   & 74.1\%\\
\hline
converter    &  278    &  36.4\% & 302  & 39.6\% & 183   & 24.0\%\\
\hline
Total        &  26229  & 50.1\%  & 13029 & 24.9\% &13085 & 25.0\%  \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing single invocations} \label{table:singleinvoc}
\end{SmallOut}\vspace*{-2ex}
\end{table}
\subsection{Testing Invocation Sequences}
\label{sec:evaluation:sequence}

