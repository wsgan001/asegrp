\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|r|r|}
 \hline
\multirow{2}*[-2pt]{\textbf{Type}}&
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{Num}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{3-8} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}&  \textbf{M}& {\%}\\
\hline
sfg  &  16962 & 237 & 1.4\% & 3744 & 22.1\% & 47 & 0.3\%\\
\hline
sfs  &  0    & 0    & n/a   & 0    & n/a    & 0  & n/a  \\
\hline
nfg  &  832  & 0    & 0.0\% & 121  & 14.5\% & 0  & 0.0\%\\
\hline
nfs  &  823  & 0    & 0.0\% & 79   & 9.6\%  & 0   & 0.0\%\\
\hline
sm   &1175   & 97   & 8.3\% & 198  & 16.9\% & 26  & 2.2\%\\
\hline
nm   &175400 & 3589 & 2.0\% & 39536& 22.5\% & 1112& 0.6\%  \\
\hline
Total &195192& 3923 &  2.0\% & 43678 & 22.4\% & 1185 & 0.6\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of Java-to-C\# tools} \label{table:java2csharp}
\end{SmallOut}\vspace*{-4ex}
\end{table}
\section{Evaluations}
\label{sec:evaluation}

We implemented a tool for TeMAPI and conducted evaluations using our tool to address the following research questions:

\vspace*{-1.5ex}
\begin{enumerate}
%\item How effectively can existing translation tool translate API elements (Section~\ref{sec:evaluation:element})? \vspace*{-1.8ex}
\item How many API elements can be translated by existing translation tools (Section~\ref{sec:evaluation:element})? \vspace*{-1.8ex}
%\item How effectively can our approach detect behavioral differences of single API classes (Section~\ref{sec:evaluation:single})?\vspace*{-1.8ex}
\item How many behavioral differences of single API classes are effectively detected by our approach (Section~\ref{sec:evaluation:single})?\vspace*{-1.8ex}
%\item How effectively can our approach detect behavioral differences of multiple API classes (Section~\ref{sec:evaluation:single})?\vspace*{-1.8ex}
\item How many behavioral differences of multiple API classes are effectively detected by our approach (Section~\ref{sec:evaluation:sequence})?\vspace*{-1.8ex}
%\item Can the our combination strategy helps achieve better coverage (Section~\ref{sec:evaluation:coverage})?
\item How many behavioral differences are detected with and without TeMAPI's internal techniques (Section~\ref{sec:evaluation:techniques})?
\end{enumerate}\vspace*{-1.5ex}

Table~\ref{table:subjects} shows subject tools in our evaluations. Column ``Name'' lists names of these tools. We use \emph{converter} to denote the ``VB \& C\# to Java converter'' for short. Java2CSharp, sharpen, and Net2Java are open source tools, and JLCA and converter are closed source tools. Column ``Version'' lists versions of subject tools. Column ``Provider'' lists companies of these tools. Column ``Description'' lists main functionalities of these tools. We choose these tools as subjects, since they are popular and many programmers recommend these tools in various forums.

All evaluations were conducted on a PC with Intel Qual CPU @ 2.83GHz and 2G memory running Windows XP. More details
of our evaluation results are available at \url{https://sites.google.com/site/asergrp/projects/temapi}.

\subsection{Translating Synthesized Wrappers}
\label{sec:evaluation:element}
This evaluation focuses on the effectiveness of our approach to extract API mapping relations from both open source tools and closed source tools. The results are useful for subsequence steps, and also to show the effectiveness of existing translation tools. For Java-to-C\# tools, TeMAPI first synthesized wrapper methods for all classes of J2SE 6.0\footnote{\url{http://java.sun.com/javase/6/docs/api/}}. During synthesizing,  TeMAPI ignored all generic API methods as described in Section~\ref{sec:approach:single}. Table~\ref{table:java2csharp} shows the translation results. Column ``Type'' lists types of synthesized methods: ``sfg'' denotes getters of static fields, ``sfs'' denotes setters of static fields, ``nfg'' denotes getters of non-static fields, ``nfs'' denotes setters of non-static fields, ``sm'' denotes static methods, ``nm'' denotes non-static methods, and ``Total'' denotes the sum of all methods. Column ``Num'' lists numbers of corresponding types of methods. Columns ``Java2CSharp'', ``JLCA'', and ``sharpen'' list the translation results of corresponding translation tools, respectively. For these columns, sub-columns ``M'' and ``\%'' list numbers and percentages of translated wrapper methods without compilation errors, respectively.

Our results show that it is quite challenging for a translation tool to translate all API elements, since API elements are quite large in size. Although JLCA is able to translate 43,678 wrapper methods, these methods cover only 22.4\% of total synthesized methods. Furthermore, even if an API element is translated, it can be translated to API elements with behavioral differences. We observe that developers of translation tools may already aware of some behavioral differences. For example, after JLCA translated synthesized code, it generated a report with many warning messages regarding behavioral differences of translated API elements. For example, a warning message was ``Method \CodeIn{java.lang.String.indexOf} was converted to \CodeIn{System.String.IndexOf}, which may throw an exception'', but the report does not describe when such an exception is thrown or how to deal with that exception. TeMAPI complements the problem, and detects that the Java method does not check whether inputs are out of ranges as the C\# method does. For example, given an empty string \CodeIn{str}, the \CodeIn{str.indexOf("", -1)} statement in Java returns 0, whereas the \CodeIn{str.IndexOf("", -1)} statement in C\# throws \CodeIn{ArgumentOutOfRangeExcpetion}.

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Type}}&
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{Num}}}
& \multicolumn{2}{|c|}{\textbf{Net2Java}} & \multicolumn{2}{|c|}{\textbf{converter}}\\\cline{3-6} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}\\
\hline
sfg  &  3223 & 1    & 0.0\% & 3    & 0.1\% \\
\hline
sfs  &  8    & 0    & 0.0\% & 0    & 0.0\%   \\
\hline
nfg  &  117  & 0    & 0.0\% & 0    & 0.0\%\\
\hline
nfs  &  115  & 0    & 0.0\% & 0    & 0.0\%\\
\hline
sm   &996    & 4   & 0.4\% & 6  & 0.6\% \\
\hline
nm   &190376 & 94    & 0.0\% & 387    & 0.2\% \\
\hline
Total &194835& 99   &  0.1\% & 396 & 0.2\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Translation results of C\#-to-Java tools} \label{table:csharp2java}
\end{SmallOut}\vspace*{-4.5ex}
\end{table}

For C\#-to-Java translation tools, TeMAPI first synthesized wrapper methods for all the classes of .NET framework client profile\footnote{\url{http://tinyurl.com/252t2ax}}. As described in Section~\ref{sec:approach:single}, besides generic methods, TeMAPI also ignored \CodeIn{unsafe} methods, \CodeIn{delegate} methods, and methods whose parameters are marked with \CodeIn{out} or \CodeIn{ref}. TeMAPI synthesized almost the same size of wrapper methods as it synthesized for J2SE. Table~\ref{table:csharp2java} shows the translation results. We find that both tools translate only a small number of API elements. One primary reason could be that C\# provides many features such as partial classes, reference parameters, output parameters, and named arguments, that are not provided by Java\footnote{\url{http://tinyurl.com/yj4v2m2}}. We suspect that a C\#-to-Java translation tool needs take these issues into consideration. Currently, many mapping relations of API elements are not addressed yet.

Tables~\ref{table:java2csharp} and~\ref{table:csharp2java} show that the Java-to-C\# tools are able to translate much more API elements compared to the C\#-to-Java tools. To give more insights, we next present more details at the package level regarding the translation results of Java-to-C\# tools in Table~\ref{table:package}. Column ``Name'' lists names of Java packages. To save space, we omit the prefixes such as ``java.'', ``javax.'', and ``org.''. We also use short names ``acc.'', ``man.'', ``java.sec.'', and ``javax.sec.'' to represent the \CodeIn{javax.accessibility}, \CodeIn{javax.management}, \CodeIn{java.security}, and \CodeIn{javax.security} packages, respectively. Besides, we omit 12 packages that are not translated by all the three tools (\emph{e.g.}, the \CodeIn{javax.rmi} package). Table~\ref{table:package} shows that all the three translation tools can translate the \CodeIn{java.io}, \CodeIn{java.lang}, \CodeIn{java.util}, and \CodeIn{java.net} packages. These four packages seem to be quite important for most Java programs. Almost for all these packages, JLCA translates more API elements than the other two tools. JLCA can also handle GUI-related packages such as the \CodeIn{java.awt} package and the \CodeIn{javax.swing} package, and can translate some Java programs with GUI interfaces whereas the other two tools cannot translate such programs.

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|p{3.6em}|r|r|r|r|r|r|r|}
 \hline
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{Name}}}&
\multicolumn{1}{|c|}{\multirow{2}*[-2pt]{\textbf{Num}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{3-8} &  &  \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}&  \textbf{M}& {\%}\\
\hline
awt  &  29199  & 0     &  0.0\%  &  8637  &  29.6\%  &  0   & 0.0\%\\
\hline
bean &  \hfill 1768   & 20    &  1.1\%  &  14    &  0.8\%   &  0   & 0.0\% \\
\hline
io   &  \hfill 3109   & 592   &  19.0\% & 1642   &  52.8\%  & 43   & 1.4\%\\
\hline
lang &  \hfill 5221   & 1494  &  28.6\% & 2377   &  45.5\%  & 791  & 15.2\%\\
\hline
math &  \hfill 1584   & 101   &  6.4\%  & 232    &  14.6\%  & 0    & 0.0\%\\
\hline
java.net  &  \hfill 1990   & 52    &  2.6\%  & 482    &  24.2\%  & 10   & 0.5\%  \\
\hline
nio  &  \hfill 536    & 30    &  5.6\%  & 0      &  0.0\%  &  0    & 0.0\%  \\
\hline
java.rmi  &  \hfill 1252   & 0     &  0.0\%  &  707   &  56.5\%  &  0   & 0.0\%\\
\hline
java.sec. &  \hfill 2797   & 50    &  1.8\%  &  702    &  25.1\%   &  0   & 0.0\% \\
\hline
java.sql   &  \hfill 3495   & 20   &  0.6\% & 183   &  5.2\%  & 0   & 0.0\%\\
\hline
text  &  \hfill 1068   & 96   &  9.0\% & 321   &  30.1\%  & 0  & 0.0\%\\
\hline
util  &  \hfill 9586   & 1372   &  14.3\%  & 1879    &  19.6\%  & 341    & 3.6\%\\
\hline
acc.  &  \hfill 237   & 1    &  0.4\%  & 25    &  10.5\%  & 0   & 0.0\%  \\
\hline
activation     &  \hfill 538   & 0    &  0.0\%  & 165   &  30.7\%  & 0   & 0.0\%  \\
\hline
crypto        &  \hfill 625   &  0    &  0.0\%  &  263  &  42.1\%  &  0    & 0.0\%\\
\hline
man.   &  \hfill 5380   & 2    &   0.0\%  & 0     &  0.0\%  & 0    & 0.0\%  \\
\hline
naming       &  \hfill 3565   & 0    &   0.0\%  & 1365   &  38.3\%  &  0    & 0.0\%  \\
\hline
javax.sec.       &  \hfill 1435  & 0     &  0.0\%  & 619     &  43.1\%  & 0    & 0.0\%\\
\hline
sound          &  \hfill 515   & 0    &  0.0\%  & 56    &  10.9\%  & 0   & 0.0\%  \\
\hline
swing          &  102389& 10   &  0.0\%  &  21364 &  20.9\%   &  0   & 0.0\%\\
\hline
javax.xml            &  \hfill 4188  &  34   &  0.8\% &  580   &  13.8\%  & 0  & 0.0\%\\
\hline
org.omg              &  \hfill 8937   & 0    &  0.0\%  & 1578  &  17.7\%  & 0   & 0.0\%  \\
\hline
w3c.dom          &  \hfill 83     & 0    &  0.0\%  & 14     &  16.9\%   & 0   & 0.0\%  \\
\hline
org.xml             &   \hfill 897    & 49   &  5.5\%  & 473    & 52.7\%    & 0   & 0.0\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Java-to-C\# translation results at package level} \label{table:package}
\end{SmallOut}\vspace*{-4ex}
\end{table}
%------------------------------------------------------------
\subsection{Generating C\# Test Cases for Java Code}
\label{sec:evaluation:single}

To detect behavioral differences through wrappers, TeMAPI leverages Pex to explore safe wrapper methods. These methods include both the translated C\# wrapper methods without compilation errors (as shown in Table~\ref{table:java2csharp}) and the synthesized C\# wrapper methods that can be translated to Java without compilation errors (as shown in Table~\ref{table:csharp2java}). During exploration, when Pex generates inputs that exercise a feasible path in the wrapper method, TeMAPI records the inputs and resulting outputs of that path. Based on these inputs and outputs, TeMAPI generates Java test cases to ensure that synthesized wrapper methods and translated wrapper methods return the same outputs given the same inputs. Since testing GUI related API elements requires human interactions, we filter out these elements (\emph{i.e.}, the \CodeIn{awt} package and the \CodeIn{swing} package). In addition, when Pex explores methods without return values, TeMAPI ignores paths that do not throw any exceptions, since it cannot generate Java related test cases. We discuss this issue in Section~\ref{sec:discuss}.

Table~\ref{table:singleinvoc} shows the results of executing generated Java test cases. Column ``Name'' lists names of translation tools. Column ``Num'' lists numbers of generated Java test cases. Columns ``E-Tests'' and ``A-Tests'' list numbers of exception-causing and assertion-failing test cases. For the two columns, sub-columns ``M'' and ``\%'' list the number and percentages of these test cases. Table~\ref{table:singleinvoc} shows that only about half of the generated Java test cases are passed. Among the five tools, sharpen includes the lowest number of ``E-Tests'' and ``A-Tests''. It seems that programmers of sharpen put great efforts to fix behavioral differences. The percentage of JLCA is also relatively low. The results are comparable, since JLCA translates much more API elements than the other tools. In total, about 50\% of test cases are failed. These results show the effectiveness of TeMAPI, since these test cases represent behavioral differences.


For Java2CSharp, JLCA, and sharpen, we further present their testing results at the package level in Table~\ref{table:packagetest}. Column ``Name'' lists names of J2SE packages. For columns ``Java2CSharp'', ``JLCA'', and ``sharpen'', sub-column ``R'' lists numbers of generated Java test cases, and sub-column ``\%'' lists percentages of failing test cases (including exception-causing and assertion-failing). Table~\ref{table:packagetest} shows that for the \CodeIn{java.sql} and \CodeIn{java.util} packages, all tools suffer from relatively high percentages of failing test cases, and for the \CodeIn{java.lang} and \CodeIn{java.math} packages, all tools include relatively low percentage of failing test cases. This result may reflect that some packages between Java and C\# are more similar than the others, so they can be more easily translated. We also find that for the \CodeIn{java.text}, \CodeIn{javax.xml}, and \CodeIn{org.xml} packages, JLCA includes the lowest percentage of failing test cases among the five tools. The result indicates that a translation tool can achieve better translation results if its developers carefully prepare API mapping relations.

Tables~\ref{table:singleinvoc} and~\ref{table:packagetest} show that a high percentage of generated Java test cases are failed. To better understand behavioral differences between mapped API elements, we inspected 3,759 failing Java test cases. For Net2Java and converter, we inspect all failing test cases, whereas for Java2CSharp, JLCA, and sharpen, we inspect test cases generated for the \CodeIn{java.lang} package, due to a large number of failing test cases. As each failing test case reflects one unique behavioral difference, we next present our findings ranked by percentages of failing test cases.

\textbf{Finding 1:} 36.8\% test cases show the behavioral differences caused by \CodeIn{null} inputs.

We find that many Java API methods and their translated C\# API methods have behavioral differences when \CodeIn{null} values are passed as inputs. In some cases, a Java API method can accept \CodeIn{null} values, but its translated C\# API method throws exceptions. One such example is shown in Section~\ref{sec:example} (\emph{i.e.}, the \CodeIn{skip(long)} method). In other cases, a Java API method throws exceptions given a \CodeIn{null} input, but its translated C\# API method can accept \CodeIn{null} values. For example, JLCA translates the \CodeIn{java.lang.Integer.parseInt (String,int)} method in Java to the \CodeIn{System.Convert.ToInt32 (string,int)} in C\#. If the inputs of the Java method are \CodeIn{null} and $10$, it throws \CodeIn{NumberFormatException}, but given the same inputs, the output of the C\# method is 0. We notice that translation tools can fix some differences caused by \CodeIn{null} inputs. For example, to fix the behavioral difference of \CodeIn{null} inputs for the \CodeIn{valueOf(Object)} method as shown in Section~\ref{sec:approach:single}, sharpen translates the method to its own method, and thus fixes the difference.

\Comment{We also find that given the same inputs, a method may produce null outputs, whereas its mapped method will not. For example, converter maps the \CodeIn{Sys- tem.Collections.Queue.ToArray()} in C\# to the \CodeIn{java.util. LinkedList.toArray()} method in Java. Given an empty list, the C\# method produce a null value, whereas the Java method produce an empty array.}

\textbf{Implication 1:} Although implementers of API libraries in different languages can come to agreements on functionalities of many API methods, behaviors for \CodeIn{null} inputs are typically controversial. Some translation tools such as sharpen try to fix these differences, however, many such differences are still left to programmers as shown in our results. Therefore, programmers should be careful when inputs are \CodeIn{null}.

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Name}}
& \multirow{2}*[-2pt]{\textbf{Num}} & \multicolumn{2}{|c|}{\textbf{E-Tests}}& \multicolumn{2}{|c|}{\textbf{A-Tests}} \\\cline{3-6}  &  & \textbf{M}& \textbf{\%} &  \textbf{M}& \textbf{\%}\\
\hline
Java2CSharp  &   15458 & 5248 & 34.0\% & 3261 & 21.1\% \\
\hline
JLCA         &   33034 & 8901 & 26.9\% & 6944 & 21.0\% \\
\hline
sharpen      &  2730 & 662  & 24.2\% & 451  & 16.5\%\\
\hline
net2java     &   352 & 40   & 11.4\%  & 261   & 74.1\%\\
\hline
converter    &  762 & 302  & 39.6\% & 182   & 23.9\%\\
\hline
Total        &  52336  &  15153 & 29.0\% &11099 & 21.2\%  \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing single classes} \label{table:singleinvoc}
\end{SmallOut}\vspace*{-6ex}
\end{table}
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|p{3.4em}|r|r|r|r|r|r|r|r|r|r|}
 \hline
\multicolumn{1}{|c}{\multirow{2}*[-2pt]{\textbf{Name}}}
& \multicolumn{2}{|c|}{\textbf{Java2CSharp}} & \multicolumn{2}{|c|}{\textbf{JLCA}}& \multicolumn{2}{|c|}{\textbf{sharpen}} \\\cline{2-7} &  \textbf{R}&  \textbf{\%} &   \textbf{R}& \textbf{\%} & \textbf{R}&   \textbf{\%}\\
\hline
bean &  \hfill 17     &    82.4\%  &  18        &  33.3\%   &  0      & n/a \\
\hline
io   &  \hfill 4155   &  67.8\%  &  6981       &  58.0\%   &   33    & 39.4\%\\
\hline
lang &  \hfill 3480   &   37.5\%  &  4431      &  26.1\%   &   1753 & 29.3\%\\
\hline
math &  \hfill 561    &   4.3\%  &   1629     &   1.5\%   &  0      & n/a\\
\hline
java.net  &   438     &   25.1\% &   3941     &   47.8\%  & 9       & 44.4\%  \\
\hline
nio  &  \hfill 27     &  48.1\% &    0        &   n/a     &  0     &  n/a \\
\hline
java.rmi  &  \hfill 0   &   n/a   &   884     &   32.6\%  &  0     & n/a\\
\hline
java.sec. &  \hfill 45  &   55.6\%  &  828    &  35.6\%   &  0    & n/a \\
\hline
java.sql   &  \hfill 260&   88.1\%  & 1465    &  91.0\%   &   0     & n/a\\
\hline
text  &  \hfill 566   &   61.5\%  & 374      &  18.2\%   & 0      & n/a\\
\hline
util  &  \hfill 5519  &   60.8\%  & 6177     & 70.2\%  & 935      & 62.4\%\\
\hline
acc.  &  \hfill 1    &   0.0\%   & 25         & 16.0\%    & 0          & n/a \\
\hline
activation  &  0     &    n/a    & 694      & 53.9\% & 0           & n/a  \\
\hline
crypto      &  0     &     n/a    & 298     & 24.2\% &  0        & n/a\\
\hline
man.        &  2     &    0.0\%  & 0        & n/a    &  0          & n/a  \\
\hline
naming      &  0     &    n/a     & 1569    & 40.6\%  &  0         & n/a  \\
\hline
javax.sec.  &  0     &   n/a     & 683     & 29.4\%  &  0        & n/a\\
\hline
sound       &  0     &   n/a     & 66       & 36.4\%  &   0        &n/a  \\
\hline
javax.xml   &  110   &    71.8\%  &  628    & 45.9\%  &   0         & n/a\\
\hline
org.omg     &  0     &   n/a     & 1842    & 36.3\%  & 0           & n/a  \\
\hline
w3c.dom     &  0     &   n/a     & 18      & 33.3\%  &  0         & n/a  \\
\hline
org.xml     &   277  &   70.0\%  & 483     & 27.3\%  & 0         & n/a\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Java-to-C\# testing results of package level } \label{table:packagetest}
\end{SmallOut}\vspace*{-4ex}
\end{table}

\textbf{Finding 2:} 22.3\% test cases show the behavioral differences caused by stored \CodeIn{string} values.

We find that \CodeIn{string} values stored in fields between Java classes and their mapped C\# classes are typically different. This difference ranks as the second, since each Java class has a \CodeIn{toString()} method and each C\# class also has a \CodeIn{ToString()} method. Many translation tools map the two API methods, but the return values of the two methods are quite different in many cases. Besides, many API classes declare methods like \CodeIn{getName} or \CodeIn{getMessage}. These methods also return \CodeIn{string} values that can be quite different. In particular, we find that the \CodeIn{Message} fields of exceptions in C\# often return informative messages. One such message is ``Index was outside the bounds of the array'' provided by the \CodeIn{System.Index- OutOfRangeException.Message} field in C\#. On the other hand, exceptions in Java often provide only \CodeIn{null} messages. Overall, we find that none of the five tools fixes this difference.

\textbf{Implication 2:} \CodeIn{String} fields of mapped classes in different languages typically store different values, but existing translation tools do not fix those differences. Programmers should not rely on these values, since they are typically different across languages.

\textbf{Finding 3:} 11.5\% test cases show the behavioral differences caused by illegal inputs or inputs out of ranges.

We find that API methods in Java seldom check whether their inputs are illegal or out of range, whereas API methods in C\# often do. For example, the \CodeIn{java.lang.Boolean.parseBoolean (String)} method in Java does not check for illegal inputs, and returns \CodeIn{false} given an illegal input such as ``\CodeIn{test}''. Java2CSharp translates it to the \CodeIn{System.Boolean.Parse(String)} method in C\#. The C\# method throws \CodeIn{FormatException} given the same input since it checks for illegal inputs. As another example, the \CodeIn{java.lang.Double.shortValue()} method in Java accepts values that are larger than 32,767. JLCA translates the Java method to the \CodeIn{Convert.ToInt16(double)} method in C\#. The C\# method throws \CodeIn{OverflowException} when values are larger than 32,767 since it checks whether inputs are too large.

\textbf{Implication 3:} API methods across languages may follow different standards to check their inputs for different considerations. If a tool translates code from a low standard to a high standard (\emph{e.g.}, Java to C\#), it can add extra code to satisfy the high standard. When programmers migrate from one language to another, they should check whether the new language follow a high standard or not.

\textbf{Finding 4:} 10.7\% test cases show the behavioral differences caused by different understanding.


We find that implementers of API libraries may have different understanding for mapped API methods in different languages. Two such examples are shown in Section~\ref{sec:approach:single} (\emph{i.e.}, the \CodeIn{capacity()} method and the \CodeIn{length()} method). In some cases, such differences reflect different natures between languages. For example, we find that Java considers ``\CodeIn{\textbackslash}'' as existing directories, but  C\# considers it not. In some other cases, we find that such differences can indicate defects in translation tools. For example, Java2CSharp translates the \CodeIn{java.lang.Integer.toHexString(int)} method in Java to the \CodeIn{ILOG.J2CsMapping.Util.IlNumber.ToString(int, 16)} method in C\#.
Given an integer -2147483648, the Java method returns ``80000000'', but the C\# method returns ``\textbackslash080000000''. As another example, Java2CSharp translates the \CodeIn{Character.isJava- IdentifierPart(char)} method in Java to the \CodeIn{ILOG.J2CsMapping. Util.Character.IsCSharpIdentifierPart(char)} method in C\#. Given a input ``\CodeIn{\textbackslash0}'', the Java method returns \CodeIn{true}, but the C\# method returns \CodeIn{false}. These two behavioral differences were confirmed as defects by developers of Java2CSharp.

\textbf{Implication 4:} Implementers can have different understanding on functionalities of specific methods. Some such differences reflect different natures of different languages, and some other differences indicate  defects in translation tools. Programmers should test their translated code carefully since this type of differences are difficult to figure out.

\textbf{Finding 5:} 7.9\% test cases show the behavioral differences caused by exception handling.

We find that two mapped API methods can throw exceptions that are not mapped. For example, when indexes are out of bounds, the \CodeIn{java.lang.StringBuffer.insert(int,char)} method in Java throws \CodeIn{ArrayIndexOutofBoundsException}. Java2CSharp translates the method to the \CodeIn{StringBuilder.Insert(int,char)} method in C\# that throws \CodeIn{ArgumentOutOfRangeException} when indexes are out of bounds. As Java2CSharp maps \CodeIn{ArrayIndexOut- ofBoundsException} in Java to \CodeIn{IndexOutOfRangeException} in C\#, the mapped C\# method fails to catch exceptions when indexes are out of bounds.

\textbf{Implication 5:} Implementers of API libraries may design quite different exception handling mechanisms. This type of differences is quite challenging to fix for translation tools. Even if two methods are of the same functionality, programmers should notice that they may produce exceptions that are not mapped.

\textbf{Finding 6:} 2.9\% test cases show the behavioral differences caused by static values.


We find that mapped static fields may have different values. For example, the \CodeIn{java.lang.reflect.Modifier} class in Java has many static fields to represent modifiers (\emph{e.g.}, FINAL, PRIVATE and PROTECTED). Java2CSharp translates these fields to the fields of the \CodeIn{ILOG.J2CsMapping.Reflect} class in C\#. Although most values of the mapped fields are the same, we find that fields such as VOLATILE and TRANSIENT are of different values. In addition, we find that different values sometimes reveal different ranges of data types. For example, \CodeIn{java.lang.Double.MAX\_VALUE} in Java is 1.7976931348623157E+308, and \CodeIn{System.Double.MaxValue} in C\# is 1.79769313486232E+308.  Although the difference is not quite large, it can cause serious defects if a program needs highly accurate calculation results.

\textbf{Implication 6:} Implementers of API libraries may store different values in static fields. Even if two static fields have the same names, programmers should be aware of that they can have different values. The results also reveal that data types between Java and C\# can have different bounds. Programmers should be aware of this if they need highly accurate results.

The rest 7.9\% failing test cases are related to the API methods that can return random values or values that depend on time. For example, the \CodeIn{java.util.Random.nextInt()} method returns random values, and the \CodeIn{java.util.Date.getTime()} method returns the number of milliseconds since Jan. 1st, 1970, 00:00:00 GMT. As another example, each Java class has a \CodeIn{hashCode()} method, and each C\# class has also a \CodeIn{GetHashCode()} method. Both the methods return a hash code for the current object, so translation tools such as JLCA map the two methods. Since a hash code is randomly generated, the two methods typically return different values. For these methods, TeMAPI can detect behavioral differences of their inputs. For example, converter translates the \CodeIn{System.Random.Next(int)} method in C\# to the \CodeIn{java.util. Random.nextInt(int)} method in Java. Given an integer value 0, the C\# method returns 0, but the Java method throws \CodeIn{IllegalArgu- mentException} with a message: ``n must be positive''. However, since these methods return values randomly, we cannot conclude that they have behavioral differences even if their outputs are different. We discuss this issue further in Section~\ref{sec:discuss}.

%--------------------------------------------------------------
\subsection{Generating Java Test Cases for C\# Code}
\label{sec:evaluation:sequence}
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Name}}& \multirow{2}*[-2pt]{\textbf{Method}} & \multirow{2}*[-2pt]{\textbf{Java}}
& \multirow{2}*[-2pt]{\textbf{C\#}} & \multicolumn{2}{|c|}{\textbf{A-Tests}} \\\cline{5-6} & &  & & \textbf{M}& \textbf{\%} \\
\hline
Java2CSharp  &  1996 & 15385&  2971 & 2151 & 72.4\%\\
\hline
JLCA         &  7060 & 16630& 1067 & 295  & 27.6\%  \\
\hline
sharpen      &  586  & 13532& 936  & 456  & 48.7\% \\
\hline
Total        &  9642 & 45547& 4974  &  2902 & 58.3\% \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of testing invocation sequences} \label{table:invocsequence}
\end{SmallOut}\vspace*{-4ex}
\end{table}
To test behavioral differences involving invocation sequences, TeMAPI leverages Randoop to generate test cases, given the list of translatable API methods. In this evaluation, we focus on the Java-to-C\# tools only, since the C\#-to-Java tools translate only a few API elements as shown in Table~\ref{table:java2csharp}. For each Java-to-C\# tool, TeMAPI first extracted the list of translatable API methods using the technique as described in Section~\ref{sec:approach:sequence}. When generating test cases, TeMAPI extends Randoop, so that each generated test case use only translatable API methods. Randomly generated invocation sequences may not reflect API usages in true practice, and we discuss this issue in Section~\ref{sec:discuss}. Among generated test cases, we translate only passing test cases from Java to C\#.

Table~\ref{table:invocsequence} shows the results. Column ``Method'' lists sizes of translatable API methods for the three tools. Column ``Java'' lists numbers of passing test cases in Java. Column ``C\#'' lists numbers of translated test cases in C\#. We notice that many Java test cases are not successfully translated to C\# for three factors that are not general or not related with API migration: (1) to prepare inputs of translatable API methods, Randoop introduces API methods that are not translatable; (2) some code structures are too complicated to translate, and we further discuss this issue in Section~\ref{sec:discuss}; (3) the numbers of compilation errors can be magnified since Randoop produces many redundancies (Section~\ref{sec:evaluation:techniques} shows an example of produced redundancies). Besides, our finding is as follows:

\textbf{Finding 7:} Many translated test cases have compilation errors, since Java API classes and their mapped C\# classes have different inheritance hierarchies.

We find that Java API classes can have different inheritance hierarchies with their translated C\# classes, and thus introduce compilation errors. For example, many compilation errors are introduced by type cast statements, and such an example is as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
public void test87() throws Throwable\{
  ...
  StringBufferInputStream var4=...;
  InputStreamReader var10=
    new InputStreamReader((InputStream)var4, var8);\}
\end{alltt}
\end{CodeOut}\vspace*{-2ex}

Since the preceding two Java API classes are related through inheritance, the test case gets passed. JLCA translates the Java test case to a C\# test case as follows:

\begin{CodeOut}\vspace*{-1ex}
\begin{alltt}
public void test87() throws Throwable\{
  ...
  StringReader var4=...;
  StreamReader var10=
    new StreamReader((Stream)var4, var8);\}
\end{alltt}
\end{CodeOut}\vspace*{-2ex}

Since the two translated C\# classes have no inheritance relations, the translated C\# test case has compilation errors.

\textbf{Implication 7:} It seems to be too strict to require that implementers of API libraries in different languages follow the same inheritance hierarchy, and it is also quite difficult for translation tools to fix this behavioral difference. Programmers should deal with this difference carefully.


%We do not list numbers of test cases end with errors since C\# does not separate errors from failures as Java does. Sub-column ``M'' lists numbers of test cases, and sub-column ``\%'' lists percentages from failed test cases to total test cases.

Column ``A-Tests'' lists the number and percentage of failing C\# test cases. Table~\ref{table:invocsequence} shows that JLCA achieves the lowest percentages among the five tools. For each tool, we further investigated its first 100 failing test cases. We find that 93.6\% failing test cases are due to the same factors described in Section~\ref{sec:evaluation:single}: 45.0\% for ranges of parameters, 34.0\% for \CodeIn{string} values, 5.3\% for different understanding, 4.0\% for exception handling, 3.0\% for \CodeIn{null} inputs, 2.0\% for values of static fields, and 0.3\% for random values. We find that Randoop's random strategy affects the distribution. For example, as invocation sequences are random, inputs of many methods are out of range or illegal. Java API methods typically do not check for illegal inputs, therefore, these test cases get passed, but translated C\# test cases get failed since C\# API methods typically check for illegal inputs. Besides the preceding finding, we find an additional finding described as follows:

\textbf{Finding 8:} 3.4\% test cases fail because of invocation sequences.


We find that random invocation sequences can violate specifications of API libraries. One type of such specifications is described in our previous work~\cite{zhong09:inferring}: closed resources should not be manipulated. Java sometimes allows programmers to violate such specifications although return values can be meaningless. One such example is shown in Section~\ref{sec:example} (\emph{i.e.}, the \CodeIn{test413} test case). Besides invocation sequences that are related to specifications, we find that field accessibility also leads to failures of test cases. For example, a generated Java test case is as follows:

\begin{CodeOut}\vspace*{-1.5ex}
\begin{alltt}
public void test423() throws Throwable\{
  ...
  DateFormatSymbols var0=new DateFormatSymbols();
  String[] var16=new String[]{...};
  var0.setShortMonths(var16);\}
\end{alltt}
\end{CodeOut}\vspace*{-2ex}

JLCA translates the Java test case to a C\# test case as follows:

\begin{CodeOut}\vspace*{-1.5ex}
\begin{alltt}
public void test423() throws Throwable\{
  ...
  DateTimeFormatInfo var0 =
  System.Globalization.DateTimeFormatInfo.CurrentInfo;
  String[] var16=new String[]{...};
  var0.AbbreviatedMonthNames = var16;\}
\end{alltt}
\end{CodeOut}\vspace*{-2ex}

The \CodeIn{var0.AbbreviatedMonthNames=var16} statement throws \CodeIn{InvalidOperationException} since a constant value is assigned to \CodeIn{var0}.

\textbf{Implication 8:} Legal invocation sequences can become illegal after translation. The target language may be more strict to check invocation sequences, and other factors such as field accessibility can also cause behavioral differences. In most cases, programmers should deal with the difference themselves.

The rest 3.0\% test cases get failed since translation tools such as Java2CSharp translate API elements in Java to C\# API elements that are not implemented yet. For example, Java2CSharp translates the \CodeIn{java.io.ObjectOutputStream} class in Java to the \CodeIn{ILOG. J2CsMapping.IO.IlObjectOutputStream} class in C\# that is not yet implemented, and such translations lead to \CodeIn{NotImplement- Exception}. The evaluation in Section~\ref{sec:evaluation:single} does not detect this difference since the specific exception is not mapped.

\subsection{Significance of Internal Techniques}
\label{sec:evaluation:techniques}
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c|r|r|r|r|r|c|c|}
 \hline
\textbf{Class}& \textbf{M} & \textbf{P} & \textbf{R}
& \textbf{T} & \textbf{\%} \\
\hline
ParserAdapter                  &  23 &  8   & 2    &  9 & 39.1\%\\
\hline
AttributeListImpl              &  19 &  7   & 3    & 7  & 36.8\%\\
\hline
AttributesImpl                 &  31 & 15  & 11    &  18 & 58.1\%\\
\hline
XMLReaderAdapter               &  23 & 8    & 2    &  9 & 39.1\%\\
\hline
LocatorImpl                    &  17 & 4    & 0    &  4 & 23.5\%\\
\hline
DefaultHandler                 &  26 & 4    & 0    &  4 & 15.4\%\\
\hline
HandlerBase                    &  23 & 4   & 1    &  5 & 21.7\%\\
\hline
InputSource                    &  15 & 4   & 0    &  4 & 26.7\%\\
\hline
NamespaceSupport               &  15  & 5   & 2    &  6 & 40.0\%\\
\hline
SAXException                   &  15 & 5    & 1    &  5 & 33.3\%\\
\hline
SAXParseException              &  19 & 6   & 1    &  6 & 31.6\%\\
\hline
SAXNotSupportedException       &  15 & 5   & 1    &  5 & 33.3\%\\
\hline
SAXNotRecognizedException      &  15 & 5   & 1    &  5 & 33.3\%\\
\hline
Total                          &  256& 80  & 25   &  87 & 34.0\%\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results with and without our internal techniques} \label{table:techniques}
\end{SmallOut}\vspace*{-4ex}
\end{table}
To investigate the significance of TeMAPI's internal techniques, we use JLCA as the subject tool, and the \CodeIn{org.xml} package in Java as the subject package for detecting behavioral differences. For each class of the package, we compare number of distinct translatable methods with behavioral differences when we use TeMAPI with and without its internal techniques, and Table~\ref{table:techniques} shows the results. Column ``Class'' shows names of classes in Java that can be translated to C\# by JLCA. Column ``M'' lists numbers of translatable methods of each class. These methods include inherited ones. Columns ``P'', ``R'', and ``T'' list numbers of found distinct translatable methods with behavioral differences when TeMAPI uses only Pex, only Randoop, and both Pex and Randoop, respectively. With only Pex, 483 test cases were generated, and 132 test cases failed. With only Randoop, 1200 test cases were generated in Java, and all these test cases got passed. After translation, all translated test cases in C\# had no compilation errors, and 1168 C\# test cases got failed. We manually inspected these failing test cases, and we find that test cases generated by Pex are more effective to reveal behavioral differences than test cases generated by Randoop, since for test cases, Pex explores feasible paths whereas Randoop generates randomly. Although more test cases were generated by Randoop fail than by Pex, these failing test cases does not reveal any new methods with behavioral differences since they are redundant. For example, we find 1151 test cases generated by Randoop all have the same invocation sub-sequence like follows:

\begin{CodeOut}\vspace*{-1.5ex}
\begin{alltt}
SaxAttributesSupport var25 = new SaxAttributesSupport();
System.Int32 var26 = 1;
System.String var27 = var25.GetLocalName((int) var26);
Assert.IsTrue(var27 == null);
\end{alltt}
\end{CodeOut}\vspace*{-1.5ex}

In this sub-sequence, JLCA translates the \CodeIn{AttributeListImpl. getName(int)} method in Java to the \CodeIn{SaxAttributesSupport. GetLocalName(int)} method in C\#. The translation makes the assertion fail since the C\# method does not return \CodeIn{null} given an empty attribute as the Java method does. Besides redundancies, each test case generated by Randoop uses many API elements, and each test case generated by Pex focuses on only one field or method within a synthesized wrapper method. As a result, it takes much more efforts to locate a method with behavioral differences from failing test cases generated by Randoop than by Pex. However, the combination of the two techniques helps TeMAPI detect more methods with behavioral difference. Besides the behavioral differences that involve invocation sequences, we also find that Pex can fail to explore paths that are too complicated. Randoop complements Pex to generate test cases for detecting behavioral differences of such methods since it generates test cases randomly. Column ``\%'' lists percentages from ``T'' to ``M''. We find that behavioral differences of mapped API methods are quite common since about one third methods have such differences.

%---------------------------------------------------------------
%\subsection{Coverage}
%\label{sec:evaluation:coverage}
%
%
%%especially in our context where most mapping relations are between J2SE and .NET Framework. For example, we find that coverage tools such as PartCover\footnote{\url{http://partcover.blogspot.com/ }} rely on the \CodeIn{JITCompilationStarted} method\footnote{\url{http://tinyurl.com/2gy2nqk}} for notifications of called methods, and thus fail to extract coverage for many methods in .NET Framework since usually no notifications are received when these method are called.
%Test coverage is a common criterion to measure the adequacy of test cases~\cite{zhu1997software}. To investigate coverage achieved by our approach with its internal techniques on and off for Java-to-C\# tools, we conduct an evaluation on JLCA. Table~\ref{table:coverageJLCA} shows the results. Column ``Class'' shows names of the subject C\# classes. JLCA generates the eight classes, and translates some classes of the \CodeIn{org.xml} package in Java to the eight C\# classes. We choose only the \CodeIn{org.xml} package in Java as the subject since it is tricky to extract coverage for internal classes of J2SE and .NET. Column ``Pex'' lists achieved coverage if TeMAPI uses only Pex to generate test cases. Column ``Randoop'' lists  achieved coverage if TeMAPI uses only Randoop to generate test cases. As Pex explores feasible paths in a systematic manner and Randoop uses random strategy, Pex achieves better coverage than Randoop except for the \CodeIn{XmlSaxLocatorImpl} class. We find that Pex can fail to generate \CodeIn{non-null} values for some interfaces. For example, the parameter of the \CodeIn{XmlSaxLocatorImpl (XmlSaxLocator)} constructor is an interface. Pex generates only \CodeIn{null} inputs for the constructor, but Randoop casts a value to the interface. As a result, Randoop achieves better coverage on this class than Pex. Still, both Pex and Randoop do not achieve high coverage for some classes (\emph{e.g.}, the \CodeIn{XmlSAXDocumentManager} class), since covering some methods requires file interactions. As both Pex and Randoop generate filenames randomly, these methods are not covered by either tool. Column ``TeMAPI'' lists the coverage achieved by combining Pex and Randoop. We find that the combination achieves the best results for all classes.
%
%To investigate coverage achieved by our approach with its internal techniques on and off for C\# to Java tools, we conduct an evaluation on converter, and Table~\ref{table:coverageconverter} shows the results.  For similar consideration, we select four classes (\emph{i.e.}, the \CodeIn{System.Collections. ArrayList} class, the \CodeIn{System.Collections.Hashtable} class, the \CodeIn{System.Collections.Queue} class, and the \CodeIn{System.Collec- tions.Stack} class). Table~\ref{table:coverageconverter} shows coverage of their translated classes in Java. The four Java classes are decompiled by JAD\footnote{\url{http://www.varaneckas.com/jad}}. We fixed compilation errors introduced during decompiling, and changed their package names. Column ``Class'' shows the names of the four Java classes. Column ``Pex'' lists achieved coverage if leveraging only Pex. We use TeMAPI to generate Java test cases when Pex explores feasible paths. Column ``Randoop'' lists  achieved coverage if leveraging only Randoop.
%%From the perspective of the four Java classes, Pex also generates test cases randomly since it does not search their feasible paths. As a result, the achieved coverage shown in Table~\ref{table:coverageconverter} are also half to half.
%Column ``TeMAPI'' lists the coverage achieved by combining Pex and  Randoop. We also find that the combination achieves the best results.
%
%\begin{table}[t]
%\centering
%\begin{SmallOut}
%\begin {tabular} {|c|r|r|r|r|r|c|c|}
% \hline
%\textbf{Class}& \textbf{Pex} & \textbf{Randoop}
%& \textbf{TeMAPI} \\
%\hline
%ManagerNotRecognizedException  &  100\% & 100\% &  100\%\\
%\hline
%ManagerNotSupportedException   &  100\% & 100\% &  100\%  \\
%\hline
%SaxAttributesSupport           &  78\%  & 74\%  &  80\%\\
%\hline
%XmlSaxDefaultHandler           &  100\% & 94\%  &  100\%\\
%\hline
%XmlSAXDocumentManager          &  29\%  & 17\%  &  29\%\\
%\hline
%XmlSaxLocatorImpl              &  83\%  & 100\%  &  100\%\\
%\hline
%XmlSaxParserAdapter            &  100\%  & 100\%  &  100\%\\
%\hline
%XmlSourceSupport               &  100\%  & 56 \%  &  100\%\\
%\hline
%\end{tabular}\vspace*{-2ex}
%\Caption{Results of testing coverage} \label{table:coverageJLCA}
%\end{SmallOut}\vspace*{-4ex}
%\end{table}

\subsection{Summary}
\label{sec:evaluation:summary}
In summary, we find that API elements are quite large in size, and translation tools typically can translate only a small portion of API elements. Although existing translation tools already notice behavioral differences of mapped API elements, many differences are not fixed. To detect behavioral differences, our approach combines random testing with dynamic-symbolic-execution-based testing, and achieves to detect more behavioral differences than with single techniques. Our approach enables us to present the first empirical comparison on behavioral differences of API mapping relations between Java and C\#. We find that various factors such as \CodeIn{null} inputs, \CodeIn{string} values, ranges of inputs, different understanding, exception handling, and static values that could lead to behavioral differences for single API classes. The preceding factors can accumulate to behavioral differences of multiple API elements. Besides, TeMAPI detects that other factors such as type cast statements and invocation sequences can also lead to behavioral differences of multiple API classes.
\subsection{Threats to Validity}
\label{sec:evaluation:threat}
The threats to external validity include the representativeness of the subject tools. Although we applied
our approach on five popular translation tools, our approach is evaluated only on these limited tools. This threat could be reduced by introducing more subject tools in future work. The threats to internal validity include human factors for inspecting behavioral differences from failing test cases. To reduce these threats, we inspected those test cases carefully. The threat could be further
reduced by introducing more researchers to inspect detected differences.
%\begin{table}[t]
%\centering
%\begin{SmallOut}
%\begin {tabular} {|c|r|r|r|r|r|c|c|}
% \hline
%\textbf{Class}& \textbf{Pex} & \textbf{Randoop}
%& \textbf{TeMAPI} \\
%\hline
%HashTable                      &  23\%  & 15\%  &  26\%\\
%\hline
%LinkedList                     &  32\%  & 26\%  & 37\%\\
%\hline
%ArrayList                      &  18\%  & 25\%  &  31\%\\
%\hline
%Stack                          &  21\%   & 55\%  &  55\%\\
%\hline
%\end{tabular}\vspace*{-2ex}
%\Caption{Results of testing coverage} \label{table:coverageconverter}
%\end{SmallOut}\vspace*{-4ex}
%\end{table} 