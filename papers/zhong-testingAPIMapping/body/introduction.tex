\section{Introduction}
\label{sec:introduction}

Migration tools can help translate projects from one language into another language. For example, as stated by Patrick Roemer\footnote{\url{http://tinyurl.com/29kw78e}}, a migration tool named sharpen translates most of db4o\footnote{\url{http://www.db4o.com/}} engine core code and its unit test suites from Java into C\#. As existing projects typically use many Application Programming Interfaces (APIs), a migration tool should know the mapping relations of APIs between two languages, so that it can translate projects with API callsites correctly. However, two mapped APIs may have different behaviors, and thus can introduce defects in translated client code silently. For example, in Java2CSharp\footnote{\url{http://j2cstranslator.sourceforge.net/}}, one mapping relation of APIs is described in its mapping files as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
1 package java.lang::System\{
2  class java.lang.String :: System:String\{
3   method valueOf(Object) { pattern = @1.ToString(); }
4   ...\}\}
\end{alltt}
\end{CodeOut}

Based on Line 3 of the preceding mapping relation, Java2CSharp translates a Java code snippet (Lines 5 and 6) into a C\# code snippet (Lines 7 and 8) as follows.

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
\textbf{  Java Code}
5 Object obj = ...
6 String value = java.lang.String.valueOf(obj);
\textbf{  C# Code translated by Java2CSharp}
7 Object obj = ...
8 String value = obj.ToString();
\end{alltt}
\end{CodeOut}

The translated code snippet compile well, but it has different behaviors with the original Java code snippet. For example, if Line 5 assigns null to \CodeIn{obj}, \CodeIn{value} of Line 6 will be ``null''. If Line 7 assigns null to \CodeIn{obj}, \CodeIn{value} of Line 8 will not be set to ``null'' since it throws \CodeIn{NullReferenceException}.

The developers of sharpen are aware of the differences, and the mapping relation in sharpen is defined as follows:

\begin{CodeOut}
\begin{alltt}
9 public abstract class Configuration \{
10 protected void setUpStringMappings() \{
11   mapMethod("java.lang.String.valueOf",
              runtimeMethod("getStringValueOf"));
12  ...\} \}
\end{alltt}
\end{CodeOut}

Based on Line 11 of the preceding mapping relation, Java2CSharp translates the Java code snippet (Lines 5 and 6) into a C\# code snippet (Lines 7 and 8) as follows.

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
\textbf{  C# Code translated by Sharpen}
13 Object obj = ...
14 String value = getStringValueOf(obj);
\end{alltt}
\end{CodeOut}

In sharpen, the \CodeIn{getStringValueOf(object)} is implemented as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
15 public static string GetStringValueOf(object value)\{
16  return null == value? "null": value.ToString();
17	\}
\end{alltt}
\end{CodeOut}

If Line 13 assigns null to \CodeIn{obj}, \CodeIn{value} will also be ``null''. Still, we find that the mapping relation defined by sharpen does not hide all differences between the \CodeIn{java.lang.String.valueOf(Object)} method and its mapped C\# API. For example, if Line 5 assign a \CodeIn{false} boolean value to \CodeIn{obj}, \CodeIn{value} of Line 6 will be ``false'', but if Lines 7 and 13 assign a \CodeIn{false} boolean value to \CodeIn{obj}, \CodeIn{value} of Line 8 and \CodeIn{value} of Line 14 will both be ``False''. This difference will potentially introduce defects into client code since it produces different outputs given the same inputs.

It is challenging to detect different behaviors of API mapping relations via testing for two factors: (1) as shown in our previous work~\cite{zhong2010mining}, translated code often cannot be tested directly since it typically contains compilation errors; (2) it requires techniques to generate adequate test cases for APIs whose code is often not available. In this paper, we propose an approach, called TeMaAPI (\textbf{Te}sting \textbf{Ma}pping relations of \textbf{API}s), that detects different behaviors of mapped APIs via testing. TeMaAPI generates various test cases and compares testing results of mapped APIs for their different behaviors. This paper makes the following major contributions:

\begin{itemize}\vspace*{-1.5ex}
\item A novel approach, called TeMaAPI, that detect different behaviors of mapped APIs via testing. The different behaviors can introduce defects in translated code silently.\vspace*{-1.5ex}
\item Test adequacy criteria proposed for generating sufficient test cases to test API mapping. For the testing criteria, TeMaAPI introduces a feedback loop when it generates test cases .\vspace*{-1.5ex}
\item A tool implemented for TeMaAPI and two
evaluations on ?? projects that include ?? mapping relations from Java to C\#, and ?? mapping relations from C\# to Java. The results show that our tool detects ?? unique defects of mapping relations...
\end{itemize}\vspace*{-1.5ex}

The rest of this paper is organized as follows.
Section~\ref{sec:mapping} presents our test adequacy criteria.
Section~\ref{sec:example} illustrates our approach using an example.
Section~\ref{sec:approach} presents our approach.
Section~\ref{sec:evaluation} presents our evaluation results.
Section~\ref{sec:discuss} discusses issues of our approach.
Section~\ref{sec:related} presents related work.
Finally, Section~\ref{sec:conclusion} concludes.
