\section{Example}
\label{sec:example}

We next illustrate the basic steps to detect the different behaviors of the API mapping relation as discussed in Section~\ref{sec:introduction}.

\textbf{Translating Generated client code.} First, TeMaAPI generates a client code method for each API method an each API field of the \CodeIn{java.lang.String} class. For example, the generate clinet code for the \CodeIn{valueOf(Object)} method is as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
  public java.lang.String testvalueOf64sm0(Object m0)\{
    return java.lang.String.valueOf(m0);\}
\end{alltt}
\end{CodeOut}


After that, we use a migration tool such as Java2CSharp to translate generated client code from Java to C\#. 

\textbf{Removing translated client-code methods with compilation errors.} A migration tool typically cannot cover all API mapping relations, so some translated client-code methods can have compilation errors if their used API methods or API fields are not covered. TeMaAPI parses translated code, and removes all client-code methods with compilation errors. The remaining client-code methods are testable since no compilation errors are left.

In this example, the translated C\# \CodeIn{testvalueOf64sm} method is as follows:
\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
  public System.String TestvalueOf64sm(Object m0) \{
    return m0.ToString();\}
\end{alltt}
\end{CodeOut}

This method contains no compilation errors since Java2CSharp covers the mapping relation of the \CodeIn{valueOf(Object)}method in Java as shown in Figure~\ref{fig:mapping}.

\textbf{Generating and executing test cases to reveal different behaviors.} TeMaAPI leverages various techniques to generate test cases for remaining client-code methods. For example, TeMaAPI extends Pex~\cite{tillmann2008pex}, so that it records all inputs and output of each execution. In this example, for the \CodeIn{TestvalueOf64sm} method in C\#, one recorded input is a boolean value, and the corresponding output is "False". Based on the input and output, TeMaAPI generates a JUnit test case as follows:

\begin{CodeOut}%\vspace*{-2ex}
\begin{alltt}
  @Test
  public void testvalueOf64sm0()\{
    sketch.Test_java_lang_String obj = 
          new sketch.Test_java_lang_String();
    boolean m0 = false;
    Assert.assertEquals("False", obj.testvalueOf64sm(m0));
  \} 
\end{alltt}
\end{CodeOut}

This JUnit test case fails since the \CodeIn{testvalueOf64sm} method in Java returns ``false'' instead of ``False''. Thus, TeMaAPI detects a different behavior between the \CodeIn{valueOf(Object)} method in Java and its mapped C\# API methods in Java2CSharp.

%\begin{figure}[t]
%\centering %\hfill
%\includegraphics[scale=0.95,clip]{figure/sample.eps}\vspace*{-3ex}
% \caption{\label{fig:example}API mapping}\vspace*{-4ex}
%\end{figure}

%Based on the mapping relations, a migration tool can migrate the
%preceding code snippet automatically. To learn the mapping
%relations,
%
%%\begin{figure}[t]
%%\centering
%%\includegraphics[scale=0.86,clip]{figure/openfile.eps}\vspace*{-1.5ex}
%% \caption
%%{\label{fig:openfile}Aligned client code}\vspace*{-2ex}
%%\end{figure}
%
%In this section, we illustrate the main steps of MAM to
%mine the API mapping in Java for \CodeIn{System.IO.Directory.
%Exists()} in C\# from the HypoLog
%project\footnote{\url{http://sourceforge.net/projects/twlog/}}.
%
%The first step of MAM is to align classes and methods of
%client code by names. This step finds class pairs and method pairs
%that implement similar functionalities, and each pair may use
%API mapping since it implements a similar functionality. Our
%approach chooses names to align classes and methods because these
%classes and methods are from the same project. In this example, our
%approach aligns the two methods as shown in
%Figure~\ref{fig:openfile} because the two method have similar names
%and their declaring classes also have similar names (see
%Section~\ref{sec:approach:alignclientcode} for details).
%
%The second step of MAM is to mine mapping relations of API
%classes based on the names of corresponding fields, parameters,
%returned types, and local variables. This step also relies on names
%for the same consideration of the first step. For example, our
%approach maps the two parameters with the same name as shown by the
%red arrow of Figure~\ref{fig:openfile}. From the types of the two
%parameters, MAM mines the mapping relation between two API
%classes: \CodeIn{System.String} $\leftrightarrow$
%\CodeIn{java.lang.String} (see
%Section~\ref{sec:approach:mappingtypes} for details).
%
%
%The final step of MAM is to mine mapping relations of API
%methods. Besides the factors listed in
%Section~\ref{sec:introduction}, another factor is that API calls in
%client code are often not carefully aligned. To deal with those
%challenges, MAM first builds an API Transformation Graph
%(ATG) for each method. After that, MAM compares built
%graphs to mine mapping relations of API methods (see
%Section~\ref{sec:approach:mappingtypes} and
%Figure~\ref{fig:approach1} for details). Figure~\ref{fig:example}
%shows the mined mapping relation between
%\CodeIn{System.IO.Directory.Exists()} and its API mapping in
%Java.
