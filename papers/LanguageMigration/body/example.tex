\section{Example}
\label{sec:example}

\begin{figure}[t]
\centering
\includegraphics[scale=0.8,clip]{figure/dataflow.eps}\vspace*{-3ex}
 \caption
{\label{fig:dataflow}API methods connected by inputs and
outputs}\vspace*{-3ex}
\end{figure}

We next use an example to illustrate challenges involved in
mining API mapping. Consider that a programmer needs to migrate 
a Java code example (shown in Figure~\ref{fig:totranslation}) to C\# using a translation tool.
This code example accepts a \CodeIn{string} input that represents
name of a file or directory and returns a \CodeIn{boolean} value that
describes whether the file or directory exists. To achieve this functionality, 
the code example declares a local variable, called \CodeIn{file},
of type \CodeIn{java.io.File} and calls the \CodeIn{exists} method. 
We consider the local variable \CodeIn{file} as a receiver object for
the \CodeIn{exists} method. 

To translate this code example into C\#, the translation
tool needs to know mapping relations of API classes. For example,
the translation tool needs to know the mapped API class for \CodeIn{java.io.File}
in C\# to translate the variable \CodeIn{file} to C\#. In addition, the translation tool needs
to know the mapped API methods of \CodeIn{exists}. Furthermore,
the translated code should be able to accept the same input
``\CodeIn{test}'' and produce the same output as the Java code example.

As APIs are often large in size, existing translation tools~\cite{} 
(@Hao: Please add citations) often support only a subset of 
mapping relations of used APIs. The reason for supporting only
a subset of mapping relations is that the mapping relations are written
manually in these translation tools. Therefore, the translation
tool cannot translate this Java code example, if the mapping relation
for the \CodeIn{java.io.File} does not exist. To address this issue,
a few translation other tools~\cite{} (@Hao, please add citations)
provide extensions for the programmer to write customized rules for translation.
However, to write customized rules, programmer needs to have 
knowledge about both the languages. Furthermore, writing these
customized rules manually for all APIs is tedious and error-prone.

To address these preceding issues and to generate the rules for translation,
we propose a novel approach that automatically mines mapping
relations of APIs. Our approach uses existing projects such as
Lucene that have both Java and C\# versions, and mines
mapping relations of APIs. One would argue that given projects
such as Lucene with both Java and C\# versions, a programmer
can manually learn these mapping relations easily. 
We next explain why it is not straightforward to learn these mapping relations of APIs.

First, the programmer needs to find Java source files that implement the
same functionality with the same input and output. For this example,
the programmer may find that \CodeIn{IndexFiles.java} in the Java
version of Lucene is a suitable source file. The programmer then
finds the corresponding source file \CodeIn{IndexFiles.cs} from the
C\# version of Lucene. The two files are as follows:

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
1  File file = \textbf{new} File("test");
2    \textbf{if}(file.exists())\{...\}
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\caption{\label{fig:totranslation} A code example for language
migration.}%\vspace*{-1ex}
\end{figure}
\begin{figure}[t]
\begin{CodeOut}\vspace*{-2ex}
\begin{alltt}
                  IndexFiles.java
3 public class IndexFiles \{
4   static final File INDEX_DIR = new File("index");
5   public static void main(String[] args) \{
      ...
6     if (INDEX_DIR.exists()) \{...\}
      ...
7       INDEX_DIR.delete();
    \}
  \}
                  IndexFiles.cs
8 class IndexFiles\{
9   internal static readonly System.IO.FileInfo INDEX_DIR
          = new System.IO.FileInfo("index");
10   public static void  Main(System.String[] args)\{
      ...
11     bool tmpBool;
12     if (System.IO.File.Exists(INDEX_DIR.FullName))
13       tmpBool = true;
14    else
15       tmpBool = System.IO.Directory
                         .Exists(INDEX_DIR.FullName);
      ...
    \}
 \}
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\caption{\label{fig:clientcode} Two versions (Java and C\#) of
client code.}\vspace*{-4ex}
\end{figure}

It is time-consuming to find out the two files as the two versions
of Lucene have more than 1,000 classes totally. Even after the
programmer successfully finds out the two aligned files, it is still
non-trivial to learn mapping relations of APIs. The programmer first
needs to map inputs of the three code snippets. In particular, by
comparing Line 1 with Line 4, the programmer knows that
\CodeIn{index} is the name for a file or a directory. Consequently,
the programmer analyzes how \CodeIn{index} in Line 4 (Java code) and
\CodeIn{index} in Line 9 (C\# code) are used in the two source files
for API mapping of interest so that boolean values are produced for
the functionality. To achieve so, the programmer may need to analyze
inputs and outputs of each API method. Figure~\ref{fig:dataflow}
shows API methods connected by inputs and outputs for the preceding
two files. In particular, a box denotes an API method, and an
ellipse denotes either an input or an output. The strategy of
analyzing inputs and outputs helps find out an API method like
\CodeIn{System.IO.Directory.Exists()}. This API method is called in
an assignment statement, whereas three other related API methods are
called in infix expressions of if-statements. If the programmer
relies on call-site structures only, the programmer can miss the API
method as its call-site structure is quite different. To match
outputs, the programmer must know the mapping relations of classes.
For this example, the programmer should know the mapping relation
between \CodeIn{boolean} in Java and \CodeIn{System.Boolean}. After
the inputs and outputs are mapped, the programmer needs to further
match functionalities. For this example, the \CodeIn{delete()}
branch of Figure~\ref{fig:dataflow} implements a different
functionality as indicated by its name, and thus this branch is not
mapped with other branches.

The programmer learns mapping relations of APIs from the preceding
analysis. However, the analysis is not accurate enough. In
particular, Figure~\ref{fig:dataflow} does not consider parameters
and fails to provide useful information if two API methods have
different parameter orders. For this example, as shown in Line 6,
the input of \CodeIn{java.io.File.exist()} is a variable, but the
inputs of \CodeIn{System.IO.Directory.Exist()} and
\CodeIn{System.IO.File.Exist()} are both their parameters as shown
in Line 12 and Line 15. The preceding analysis does not consider
parameters yet.
\begin{figure}[t]
\centering
\includegraphics[scale=0.65,clip]{figure/sample.eps}\vspace*{-3ex}
 \caption
{\label{fig:example}API mapping}\vspace*{-3ex}
\end{figure}

In this paper, we propose a novel approach that mines API mapping
automatically. Figure~\ref{fig:example} show the mined mapping
relation of APIs from the preceding two source files. In this
figure, a box denotes an API method. Here, our approach uses
\CodeIn{getFullName()} to denote the field access of
\CodeIn{FullName}. An ellipse denotes a parameter, a variable, or a
return value. Each ellipse is named as ``\emph{name:type}''. Here,
our approach uses ``variable'' for accesses of variables, ``null''
for return values, and parameter names for parameters.


The mined API mapping has matched inputs, outputs, and how inputs
and outputs are connected. Consequently, with the mined API mapping,
a translation tool can automatically translate the preceding code
snippet into C\# as follows:



In summary, for this example, we find that a programmer needs to
take tedious and error-prone efforts to find and to analyze source
files from two versions of a project for API mapping. We next
present our approach to mine API mapping automatically.


%Based on the mapping relations, a translation tool can migrate the
%preceding code snippet automatically. To learn the mapping
%relations,
%
%%\begin{figure}[t]
%%\centering
%%\includegraphics[scale=0.86,clip]{figure/openfile.eps}\vspace*{-1.5ex}
%% \caption
%%{\label{fig:openfile}Aligned client code}\vspace*{-2ex}
%%\end{figure}
%
%In this section, we illustrate the main steps of our approach to
%mine the API mapping in Java for \CodeIn{System.IO.Directory.
%Exists()} in C\# from the HypoLog
%project\footnote{\url{http://sourceforge.net/projects/twlog/}}.
%
%The first step of our approach is to align classes and methods of
%client code by names. This step finds class pairs and method pairs
%that implement similar functionalities, and each pair may use
%API mapping since it implements a similar functionality. Our
%approach chooses names to align classes and methods because these
%classes and methods are from the same project. In this example, our
%approach aligns the two methods as shown in
%Figure~\ref{fig:openfile} because the two method have similar names
%and their declaring classes also have similar names (see
%Section~\ref{sec:approach:alignclientcode} for details).
%
%The second step of our approach is to mine mapping relations of API
%classes based on the names of corresponding fields, parameters,
%returned types, and local variables. This step also relies on names
%for the same consideration of the first step. For example, our
%approach maps the two parameters with the same name as shown by the
%red arrow of Figure~\ref{fig:openfile}. From the types of the two
%parameters, our approach mines the mapping relation between two API
%classes: \CodeIn{System.String} $\leftrightarrow$
%\CodeIn{java.lang.String} (see
%Section~\ref{sec:approach:mappingtypes} for details).
%
%
%The final step of our approach is to mine mapping relations of API
%methods. Besides the factors listed in
%Section~\ref{sec:introduction}, another factor is that API calls in
%client code are often not carefully aligned. To deal with those
%challenges, our approach first builds an API Transformation Graph
%(ATG) for each method. After that, our approach compares built
%graphs to mine mapping relations of API methods (see
%Section~\ref{sec:approach:mappingtypes} and
%Figure~\ref{fig:approach1} for details). Figure~\ref{fig:example}
%shows the mined mapping relation between
%\CodeIn{System.IO.Directory.Exists()} and its API mapping in
%Java.
