\section{Evaluations}
\label{sec:evaluation}

We implemented a tool named MAM for our approach and
conducted two evaluations using our tool to show the effectiveness
of our approach. In our evaluations, we address the following
two research questions.

\vspace*{-1.5ex}
\begin{enumerate}
\item How effectively can our approach mine various API mapping relations
(Section~\ref{sec:evaluation:mining})? \vspace*{-1.8ex}
\item How much benefit can the mined API mapping relations offer in aiding language
translation (Section~\ref{sec:evaluation:migration})?\vspace*{-1.6ex}

\end{enumerate}%\vspace*{-1.5ex}
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c!{\vrule width 1pt}c!{\vrule width 1pt}c|c!{\vrule width 1pt}c|c|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Project}}&
\multirow{2}*[-2pt]{\textbf{Source}}
& \multicolumn{2}{|c|}{\textbf{Java version}} & \multicolumn{2}{|c|}{\textbf{C\# version}} \\\cline{3-6} &  &  \emph{\textbf{\#C}}& \emph{\textbf{\#M}} &\emph{\textbf{\#C}}& \emph{\textbf{\#M}}\\
\hline \hline
  neodatis &   SourceForge  & 1298 &   9040 & 464  & 3983     \\
\hline
  db4o     &   SourceForge  & 3047 &   17449 & 3051 & 15430     \\
\hline
numerics4j &   SourceForge  & 145 &   973   & 87   & 515     \\
\hline
  fpml     &   SourceForge  & 143  &   879   & 144  & 1103     \\
\hline
  PDFClown &   SourceForge  & 297  &   2239  & 290  & 1393     \\
\hline
  OpenFSM &   SourceForge   & 35   &   179   & 36  & 140    \\
\hline
binaryNotes &   SourceForge  & 178 &   1590  & 197 & 1047    \\
\hline
  lucene   &    Apache      & 1298 &   9040  & 464& 3015    \\
\hline
  logging  &    Apache      & 196 &   1572   & 308 & 1474     \\
\hline
  hibernate &   hibernate  & 3211 &   25798 & 856 & 2538     \\
\hline \hline
  rasp     &   SourceForge  & 320  &   1819  & 557 & 1893     \\
\hline
  llrp     &   SourceForge  & 257 &   3833   & 222 & 978   \\
\hline
 simmetrics &   SourceForge & 107 &   581    & 63 & 325     \\
\hline
  aligner &   SourceForge  & 41    &   232 & 18 & 50     \\
\hline
  fit       &   SourceForge  & 95 &   461    & 43 & 281     \\
\hline\hline
  \multicolumn{2}{|c|}{Total} &   11668 & 75685  &   6900 & 34165   \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Subjects} \label{table:subjects}
\end{SmallOut}\vspace*{-4ex}
\end{table}

Table~\ref{table:subjects} shows 15 open source projects with both Java and
C\# versions used as subjects in our evaluations.
Column ``Project'' lists names of subjects. Column ``Source'' lists sources of these
subjects. These subjects are collected from popular open source societies such
as SourgeForge\footnote{\url{http://www.sf.net}},
Apache\footnote{\url{http://www.apache.org/}}, and
hibernate\footnote{\url{http://www.hibernate.org/}}. Columns ``Java
version'' and ``C\# version'' list versions in Java and
C\#, respectively. In these two columns, sub-columns
``\emph{\#C}'' and ``\emph{\#M}'' list number of classes and methods, respectively. As shown
in the table, Java versions are much larger than C\# versions
for all subjects. We found two major factors for such
a difference. First, Java versions of some of the
projects are more up-to-date. For example, the latest Java
version of \emph{numericas4j} is 1.3, whereas the latest C\# version
is 1.2. Second, for some projects, translation from Java to C\# is still in
progress. For example, the
website\footnote{\url{http://wiki.neodatis.org/}} of \emph{neodatis}
states that \emph{neodatis} is a project in Java and is being ported
to C\#. This observation further confirms the usefulness of our
approach since our approach aids translating projects from one language to other
languages. In total, all these projects include 18,568 classes and 109,850
methods.

We conducted all evaluations on a PC with Intel Qual CPU @
2.83GHz and 1.98M memory running Windows XP. More details of our
evaluation results are available at \url{https://sites.google.com/site/asergrp/projects/mam}.

\subsection{Mining API mapping relations}
\label{sec:evaluation:mining}

To investigate the first research question, we use the top 10 projects
from Table~\ref{table:subjects} as subjects for mining API mapping relations.

\textbf{Aligning client code.}
We first present the results of aligning client code.
We use the \emph{SIM\_THRESHOLD} value as 0.6, which is set based on our initial
empirical experience. We choose a relatively low threshold since it helps our
approach to take into account as much client code as possible.

Table~\ref{table:analyzingclient} shows our evaluation results.
In column ``Aligned'', sub-columns ``\emph{\# C}'' and
``\emph{\# M}'' list the number of aligned classes and aligned methods.
For each project of Column ``C\# version'' and
Column ``Java version'', sub-column ``\emph{\%C}'' lists the
percentage of the aligned classes among total classes of
corresponding versions. Sub-column ``\emph{\%M}'' lists the
percentage of the aligned methods among total methods of
corresponding versions. Row ``Total'' of the two sub-columns lists
the percentage of aligned methods/classes among the total
methods/classes as shown in Table~\ref{table:subjects}. We find that
the results of Table~\ref{table:analyzingclient} fall into three
categories. This first category includes \emph{db4o}, \emph{fpml},
\emph{PDFClown}, \emph{OpenFSM}, and \emph{binaryNotes}. In this category, our
approach achieves relatively high percentages for both Java
and C\# versions. For all these five projects, ``\emph{\%M}'' is
relatively smaller than ``\emph{\%C}'' because methods of those
unaligned classes cannot be aligned and hence are counted as
unaligned\footnote{Another factor lies in that Java versions usually
have many getters and setters and these getters and setters often do
not have corresponding methods in C\# versions.}. The second
category includes \emph{neodatis}, \emph{numerics4j}, and
\emph{lucene}. In this category, our approach aligns C\# versions well but does
not align Java versions so well. We find that the translation of \emph{neodatis} and
\emph{lucene} from Java to C\# is in progress, and the
Java version of \emph{numerics4j} is more up to date than its
C\# version. As a result, some Java classes or methods do not have
corresponding implementations in C\# versions in these projects and
hence are not mapped. The third category includes \emph{logging}
and \emph{hibernate}. In this category, our approach does not align classes and
methods of the two projects well. Although both of the two projects
seem to be translated from existing Java versions, the programmers of
the two projects often do not refer to names of existing Java
versions for naming entities. For these two projects, the
percentage of aligned classes is relatively high, and the percentage
of aligned methods is relatively low. We find that even if our
approach aligns a wrong class pair, our approach does not align
methods within the wrong pair since the method names of a wrong pair
are quite different. These results suggest that we can take method
names into account when aligning classes in future work. For all
these projects, our approach does not align all classes and all
methods. We discuss these issues in Section~\ref{sec:discuss}.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c!{\vrule width 1pt}c|c!{\vrule width 1pt}c|c!{\vrule width 1pt}c|c|c|c!{\vrule width 1pt}c|c|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Project}}&
\multicolumn{2}{|c|}{\textbf{Java version}}
& \multicolumn{2}{|c|}{\textbf{C\# version}} & \multicolumn{2}{|c|}{\textbf{Aligned}} \\\cline{2-7} &  \emph{\textbf{\%C}}& \emph{\textbf{\%M}}&  \emph{\textbf{\%C}}& \emph{\textbf{\%M}} &\emph{\textbf{\#C}}& \emph{\textbf{\#M}}\\
\hline\hline
  db4o     &   87.8\%  &  65.5\%&    87.6\%  & 74.1\% & 2674  & 11433   \\
\hline
  fpml       & 93.7\%  &  70.5\% & 93.5\%  & 56.2\% &  134 &  620  \\
\hline
  PDFClown   & 86.5\%  &  51.0\% & 88.6\%  & 82.1\% & 257  & 1143  \\
\hline
  OpenFSM    & 97.1\%  &  72.1\% &  94.4\% &  92.1\%  & 34   & 129   \\
\hline
  binaryNotes & 98.9\%  & 61.1\% &  89.3\% &  92.7\% & 176   & 971  \\
\hline \hline
  neodatis &   44.7\%  &  54.8\% &   100.0\% & 93.6\% & 408  & 3728   \\
\hline
  numerics4j & 57.2\%  &  48.6\% & 95.4\%  & 89.9\% &  75  &  174   \\
\hline
  lucene     &  34.9\%  & 26.6\%&   97.6\% &  79.8\% & 453  & 2406  \\
\hline\hline
  logging    &   91.8\% & 18.1\%&   58.4\% & 19.3\% &  180  & 285   \\
\hline
  hibernate &   26.4\%  & 1.2\%&    99.1\% & 12.6\% &  848  & 319   \\
\hline\hline
  Average &   53.2\% & 30.8\% &   88.8\% & 69.2\% & 524 & 2121 \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of Aligning client code}
\label{table:analyzingclient}
\end{SmallOut}\vspace*{-4ex}
\end{table}

In summary, as shown by Row ``Average'', our approach aligns most
classes and methods on average. The result confirms that many
programmers refer to existing versions of another language to name
entities of a version under development.

\textbf{Mining API mapping relations.}
Table~\ref{table:minedresults} shows the results of mined mapping
relations of API classes and methods. Columns ``Class'' and ``Method''
list results of mining mapping relations of API classes and API methods, respectively. Sub-column
``\emph{Num.}'' lists the number of mined mapping relations. The
number of mined API mapping relations is highly proportional to the sizes
of projects as shown in Table~\ref{table:subjects}, except for
\emph{logging} and \emph{hibernate}. Since classes and methods of these
two projects are not well aligned, our approach does not mine
many API mapping relations from these two projects. For the
remaining projects, our approach mines many mapping relations of API
classes and API methods. Sub-column ``\emph{Acc.}'' lists accuracies
of the top 30 mined API mapping relations (\emph{i.e.}, percentages of correct
mapping relations). For mined API mapping relations from each project, we
manually inspect top 30 mined API mapping relations by alphabetical order and classify
them as correct or incorrect based on inspecting API client code and
API documents. We find that our approach achieves high accuracies, except for
\emph{hibernate}. Although our approach does not align
\emph{logging} quite well either, the accuracies of API mapping relations from
\emph{logging} are still relatively high. To mine API mapping relations of
classes, our approach requires that names of classes, methods, and
variables are similar. To mine API mapping relations of methods, our
approach requires that two built ATGs are
similar. These two requirements are relatively strict. As a result, if
the first step does not align client code well, our approach may
miss some API mapping relations but does not introduce many
false mapping relations. In other words, our approach is robust to
mine accurate API mapping relations. Sub-column ``\emph{J2SE}'' lists the number of mined
API mapping relations between J2SE and .NET. We next compare these API mapping
relations with manually written mapping relations.

Row ``Total'' lists the total result after we merge all duplicated
mapping relations. In summary, our approach mines a large number of
API mapping relations. These mined API mapping relations are
accurate and associated with various libraries.
%Sub-column ``\emph{1-1}'' list the number of one-to-one relations.
%We find that most mined mapping relations are of this kind. Our
%approach still needs improvements to mine those many-to-many mapping
%relations. We further discuss this issue in
%Section~\ref{sec:discuss}.
\begin{table}[t]
%\flushleft
\centering
\begin{SmallOut}
\begin {tabular} {|c!{\vrule width 1pt}c|c|c!{\vrule width 1pt}c|c|c!{\vrule width 1pt}c|c|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Project}}&
\multicolumn{3}{|c|}{\textbf{Class}}
& \multicolumn{3}{|c|}{\textbf{Method}}  \\\cline{2-7} &  \emph{\textbf{Num.}}&\emph{\textbf{Acc.}}&\emph{\textbf{J2SE}}& \emph{\textbf{Num.}}&  \emph{\textbf{Acc.}}&\emph{\textbf{J2SE}} \\
\hline \hline
  db4o         &   3155  & 83.3\%  &   117 & 10787 & 90.0\%  & 297  \\
\hline
  fpml         &   199   & 83.3\%  &   41  & 508   & 83.3\%  & 216   \\
\hline
  PDFClown     &   539   & 96.7\%  &   36 & 514   & 100.0\% & 111  \\
\hline
  OpenFSM      &   64    & 86.7\%  &   16  & 139   & 73.3\%  &  12  \\
\hline
  binaryNotes  &   287   & 90.0\%  &   31  & 671   & 90.0\%  &  55   \\
\hline \hline
  neodatis     &   526   & 96.7\%  &    41 & 3517  & 100.0\% & 539    \\
\hline
  numerics4j   &   97    & 83.3\%  &   2   & 429   & 83.3\%  &  29  \\
\hline
  lucene       &   718   & 90.0\%  &   83  & 2725  & 90.0\%  & 522   \\
\hline\hline
  logging      &   305   & 73.3\%  &   45  & 56    & 90.0\%  & 19  \\
\hline
  hibernate    &   1126  & 66.7\%  &   87  & 7     & 13.3\%   & 5  \\
\hline\hline
  Total        &   6695   & 86.7\% &   344  & 19110 & 90.0\%  & 1768\\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of mining API mapping relations.} \label{table:minedresults}
\end{SmallOut}\vspace*{-4ex}
\end{table}

\textbf{Comparing with manually written API mapping relations.} Some translation
tools such as
Java2CSharp\footnote{\url{http://j2cstranslator.wiki.sourceforge.net}}
include manually written API mapping relations of APIs.
For example, one item from the mapping files of Java2CSharp is as
follows:

\begin{CodeOut}\vspace*{-2ex}
\begin{alltt}
package java.math :: System \{
  class java.math.BigDecimal :: System:Decimal \{
    method multiply(BigDecimal)
       \{ pattern =  Decimal.Multiply(@0, @1); \}
  \}
\}
\end{alltt}
\end{CodeOut}\vspace*{-2ex}

This item describes API mapping relations between the \CodeIn{multiply}
method of Java and the \CodeIn{Multiply} method of C\#. The pattern
string describes API mapping relations of inputs. In particular,
``\CodeIn{@0}'' denotes the receiver of the \CodeIn{multiply}
method, and ``\CodeIn{@1}'' denotes the first parameter of the
\CodeIn{multiply} method. Based on this item, Java2CSharp translates
the following code snippet from Java to C\# as follows:

\begin{CodeOut}\vspace*{-2ex}
\begin{alltt}
  BigDecimal m = new BigDecimal(1);
  BigDecimal n = new BigDecimal(2);
  BigDecimal result = m.multiply(n);
  ->
  Decimal m = new Decimal(1);
  Decimal n = new Decimal(2);
  Decimal result = Decimal.Multiply(m,n);
\end{alltt}
\end{CodeOut}\vspace*{-2ex}

To compare with manually written mapping files of Java2CSharp, we
translate our mined API mapping relations using the following strategy. First,
for each Java class, we translate its mapping relations of classes
with the highest support values. Here, the support value of a mapping relation is the frequency that the mapping relation is mined from the subjects listed in Table~\ref{table:minedresults}. Second, for each Java method, we translate its
mapping relations of methods with the highest support values into mapping
files as relations of methods with pattern strings. For one-to-one
mapping relations of methods, this step is automatic since mined
mapping relations describe mapping relations of corresponding
methods and inputs. For a few many-to-many mapping relations of methods,
this step is manual since mined mapping relations do not include
adequate details. We further discuss this issue in Section~\ref{sec:discuss}.

The mapping files of Java2CSharp are associated with
13 packages defined by J2SE and 2 packages defined by
JUnit\footnote{\url{http://www.junit.org/}}, and we treat these
mapping files as a golden standard. We find 9 packages with overlapping
between the mined mapping files and the mapping files of
Java2CSharp. Table~\ref{table:compare} shows the comparison
results of our mined API mapping relations within these mapping packages.
Columns ``Class'' and ``Method'' list results of comparing API
classes and methods, respectively. Sub-columns
``\emph{P}'', ``\emph{R}'', and ``\emph{F}'' denote precision,
recall, and F-score. \emph{Precision}, \emph{Recall}, and \emph{F-score} are defined as
follows:\vspace*{-1ex}
\begin{equation}\label{eq-precison}
Precision=\frac{true\ positives}{true\ positives+false\ positives}
\end{equation}\vspace*{-2ex}
\begin{equation}\label{eq-recall}
Recall=\frac{true\ positives}{true\ positives+false\ negatives}
\end{equation}\vspace*{-2ex}
\begin{equation}\label{eq-fscore}
F\!-\!score=\frac{2\times Precision \times Recall}{Precision+Recall}
\end{equation}\vspace*{-2ex}

\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|c!{\vrule width 1pt}c|c|c!{\vrule width 1pt}c|c|c!{\vrule width 1pt}c|c|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Package}}&
\multicolumn{3}{|c|}{\textbf{Class}}
& \multicolumn{3}{|c|}{\textbf{Method}}  \\\cline{2-7} &  \emph{\textbf{P}}& \emph{\textbf{R}}& \emph{\textbf{F}}& \emph{\textbf{P}}& \emph{\textbf{R}}& \emph{\textbf{F}}\\
\hline
  java.io   &   78.6\%  & 73.3\%   &   76.0\%   & 93.1\%  & 66.3\%  & 79.7\%   \\
\hline
  java.lang &   82.6\%  & 86.4\%   &   84.5\%   & 93.8\%  & 81.5\%  & 87.6\%   \\
\hline
  java.math &   50.0\%  & 50.0\%   &   50.0\%   & 66.7\%  & 66.7\%  & 66.7\%   \\
\hline
  java.net  &   100.0\% & 50.0\%  &   75.0\%  & 100.0\% & 50.0\% & 75.0\%   \\
\hline
  java.sql  &   100.0\% & 66.7\%   &   83.3\%   & 100.0\% & 66.7\%  & 83.3\%   \\
\hline
  java.text &   50.0\%  & 50.0\%   &   50.0\%   & 50.0\%  & 50.0\%  & 50.0\%   \\
\hline
  java.util &   56.0\%  & 87.5\%   &   71.8\%   & 65.8\%  & 67.6\%  & 66.7\%   \\
\hline
  junit     &   100.0\% & 50.0\%   &   75.0\%   & 92.3\%  & 88.9\%  & 90.6\%   \\
\hline
  orw.w3c   &   42.9\%  & 75.0\%   &   58.9\%   & 41.2\%  & 77.8\%  & 59.5\%   \\
\hline
  Total     &   68.8\%  & 77.9\%   &    73.4\%  & 84.6\%  & 73.9\%  & 79.3\% \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{Results of comparing mined relations with manually written ones.} \label{table:compare}
\end{SmallOut}\vspace*{-4ex}
\end{table}

In these preceding formula, true positives represent those API mapping
relations that exist in both the mined API mapping relations and the golden
standard\footnote{We ignore those API mapping relations that do
not have call sites in the projects listed in
Table~\ref{table:minedresults}, since our approach relies on
API call sites to mine mapping relations. By adding
more projects using these APIs to our subjects, our approach can then
mine relations of these APIs.}; false positives represent those relations that exist in the mined API
mapping relations but not in the golden standard; false negatives represent
those mapping relations that exist in the golden standard but not in
the mined API mapping relations. Row ``Total'' shows the results when we
compare mapping relations of all the packages listed in
Table~\ref{table:compare}.

From sub-columns ``\emph{P}'' of Table~\ref{table:compare}, we find
that our approach achieves relatively high precisions, but the
precisions are lower than the accuracies shown in
Table~\ref{table:minedresults}. After inspecting those differences,
and we find 25 new correct mapping relations of API classes from our
mined mapping files. For example, these mined mapping files contain
a mapping relation between \CodeIn{org.w3c.dom.Attr} and
\CodeIn{System.Xml.XmlAttribute}, and the mapping relation does not
exist in the mapping files of Java2CSharp. If we consider these 25 new relations as true positives,
the total precision would be 85.7\%. These new mapping relations are useful and
complements the existing mapping files of the Java2CSharp tool.

From sub-columns ``\emph{R}'' of Table~\ref{table:compare}, we find
that our approach achieves relatively high recalls, but the recalls
still have space for improvements. For example, our approach does
not mine the mapping relation between
\CodeIn{java.util.ResourceBundle} and \CodeIn{System.
Resources.ResourceManager} as described in the mapping files of
Java2CSharp. Although it exists in \emph{hibernate}, our approach
fails to mine the mapping relation since \emph{hibernate} uses the
two API classes in two classes with quite different names. Our
approach also fails to mine the mapping relations between
\CodeIn{java.util.getTime()} and \CodeIn{System.DateTime.Ticks}
correctly since our approach ignores the operation of dividing 1,000
from ticks to milliseconds. We further discuss these issues in
Section~\ref{sec:discuss}.

In summary, compared with the mapping files of Java2CSharp, our
mined mapping files show a reasonably high precisions and recalls.
The precisions are relatively high since our mined mapping relations
are accurate and include new mapping relations that are not covered
by Java2CSharp. The recalls are also relatively high since our approach
mines many mapping relations although we still have space for
further improvements.
\begin{table}[t]
\centering
\begin{SmallOut}
\begin {tabular} {|p{1cm}!{\vrule width 1pt}c|c!{\vrule width 1pt}c|c!{\vrule width 1pt}c|c|c|c|c|c|}
 \hline
\multirow{2}*[-2pt]{\textbf{Projects}}& \multicolumn{2}{|c|}{\textbf{No MF}}  & \multicolumn{2}{|c|}{\textbf{MF}} & \multicolumn{4}{|c|}{\textbf{Ext. MF}}\\
\cline{2-9} &  \emph{\textbf{E}}&  \emph{\textbf{D}}&  \emph{\textbf{E}}&  \emph{\textbf{D}}& \emph{\textbf{E}}&  \emph{\textbf{\%E}}&  \emph{\textbf{D}}&  \emph{\textbf{\%D}}\\
 \hline
  \hfil rasp        &  973  &   159 &  708  & 123   &  627  &  11.4\% & 93 &  24.4\%    \\
\hline
  \hfil llrp        &  2328 &  122  & 1540  &  114  &  269  &  82.5\% & 42 & 63.2\%   \\
\hline
   simmetrics  &  217  & 13    &  12   & 0     & 6     &  50.0\% &  0  & 0\%   \\
\hline
  \hfil aligner     &  368  &  34   &  289  & 0     & 262   &  9.3\%  &  0  & 0\%    \\
\hline
 \hfil  fit         &  177  & 29    &  27   & 0     & 20    &  25.9\% &  0  & 0\%  \\
\hline \hfil Total  & 4063  & 491   & 2576  & 237   & 1174  &  54.4\% & 135 & 43.0\% \\
\hline
\end{tabular}\vspace*{-2ex}
\Caption{\label{table:errors}Compilation errors and defects}
\end{SmallOut}\vspace*{-3ex}
\end{table}

%-----------------------------------------------------------------
\subsection{Aiding Language Translation}
\label{sec:evaluation:migration}

To investigate the second research question, we feed the
mined API mapping relations to the Java2CSharp tool and
investigate whether these relations can improve the tool's
effectiveness. We choose this tool because this tool is a relatively
mature project at ILOG\footnote{\url{http://www.ilog.com/}} (now
part of IBM) and supports the extension of user-defined mapping
relations of APIs.

We use Java2CSharp to translate the last five projects listed in
Table~\ref{table:subjects} from Java to C\#, and
Table~\ref{table:errors} shows the results. For each translated C\#
project, Column ``No MF'' lists results without mapping files.
Column ``MF'' lists results with only the mapping files of Java2CSharp.
Column ``Ext. MF'' lists results with mapping files that combine
our mined API mapping relations with the existing mapping files of Java2CSharp.
Sub-columns ``\emph{E}'' and ``\emph{D}'' list the number of
compilation errors and found defects, respectively. Complication errors provide a overview for qualities of translated projects, but some complication errors are not related to APIs.
To find out the effectiveness of reducing API related defects, we manually inspect some translated C\# files. In particular, for each project,
we first select those overlapping files between translated files and existing C\# files
from the C\# version of the five projects. After that, we manually compare
the top 5 largest files among these overlapping files with existing C\# files and analyzes those differences for detecting API related defects. For example, a translated C\# statement of \emph{simmetric} in ``No MF'' is as follows.

\begin{CodeOut}\vspace*{-1.8ex}
\begin{alltt}
 totalDistance = (float)Java.Lang.Math.Sqrt(totalDistance);
\end{alltt}
\end{CodeOut}\vspace*{-1.8ex}

This statement contains an API related defect since Java2CSharp does not translate the \CodeIn{sqrt} method of Java to its corresponding API method of C\#. Sub-columns ``\emph{\%E}'' and ``\emph{\%D}'' list
percentages of improvements over the results of ``MF''. On average,
mined API mapping relations help further reduce 54.4\% compilation errors
and 43.0\% API defects. Since the five projects use different libraries,
the translated projects are different from their C\# versions. In particular,
\emph{simmetrics} and \emph{fit} use API classes of J2SE that are
covered by mapping files. Consequently, the translated projects of
\emph{simmetrics} and \emph{fit} have only a few errors and defects. The
\emph{aligner} project also mainly uses J2SE, but it uses many API
classes and methods from \CodeIn{java.awt} for its GUI. The mapping
files of Java2CSharp do not cover any classes of \CodeIn{java.awt},
so the translated project has many compilation errors. Since the existing C\#
version of \emph{aligner} does not have GUI, we do not compare those
defective translated GUI files, and we do not find any API related defects in the compared 5 files. The mined
files map \CodeIn{java.awt} to \CodeIn{System.Windows.Forms} and
thus reduce compilation errors. However, the result is not
significant since many classes of the two packages are still not
mapped. For \emph{rasp} and \emph{llrp}, they both use various
libraries besides J2SE. Consequently, the translated projects have
both many errors and API related defects. In particular, \emph{llrp} uses
log4j\footnote{\url{http://logging.apache.org/log4j/}} and
jdom\footnote{\url{http://www.jdom.org/}}, and the mined mapping
files contain mapping relations of the two libraries. As a result,
the mined API mapping relations help reduce compilation errors and
API related defects significantly. For \emph{rasp}, it uses some libraries such as
Neethi\footnote{\url{http://ws.apache.org/commons/neethi/}} and
WSS4J\footnote{\url{http://ws.apache.org/wss4j/}}. Since the used
subjects for mining and thus our mined API mapping relations do not cover the
two libraries, the translated project of \emph{rasp} contains many
compilation errors and API related defects.

In summary, the mined API mapping relations improve existing language
translation tools such as Java2CSharp. In particular, the mined API
mapping relations help effectively reduce compilation errors and
API related defects in the translated projects.

%--------------------------------------------------------------------------
\subsection{Threats to Validity}
\label{sec:evaluation:threats} The threats to external validity
include the representativeness of the subjects in true practice and
the existing translation tool being compared. Although we applied
our approach on 10 projects for mining API mapping relations and on additional
5 projects for helping language translation, our approach is
evaluated only on these limited projects. Although Java2CSharp is
the best translation tool within our knowledge, other tools may perform
better than the tool. The threat could be reduced by more
evaluations on more subjects and more translation tools in future
work. The threats to internal validity include human factors for
determining correct mined API mapping relations and for determining API related defects in
translated projects. To reduce the threats, we inspected mined
mapping relations and API related defects carefully, and we referred to existing
mapping relations and existing C\# files for determining correct API
mapping relations and API related defects, respectively. The former threat could be further
reduced by comparing with more existing mapping relations of APIs as we did to
J2SE. The latter threat could be reduced by running test cases to detect API related defects.
