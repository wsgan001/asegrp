\section{Introduction}
\label{sec:introduction} 

A programming language serves as a means for instructing computers to achieve a programming task at hand.
Since their inception, various programming languages came into existence due to several 
reasons such as existence of many platforms or requirements for different programming styles.
The HOPL\footnote{\url{http://hopl.murdoch.edu.au}} website lists 
8,512 different programming languages. 

To address business requirements and to survive in competing markets, companies
often have to develop different versions of their projects in different languages.
For example, many well-known projects such as Lucene\footnote{\url{http://lucene.apache.org/}},
Db4o\footnote{\url{http://www.db4o.com/}}, and WordNet\footnote{\url{http://wordnet.princeton.edu/}} provide
multiple versions in different languages. There are several instances where
companies incurred huge losses due to lack of multiple versions of their projects.
For example, Terekhov and Verhoef~\cite{terekhov2000realities} stated that atleast three
companies went bankrupt and another company lost 50 million dollars due to failed language migration projects.

For some open source projects, although companies do not offically provide multiple versions, external programmers often
create their versions in different languages. For example, WordNet does not
provide a C\# version. However, Simpson and Crowe developed
a C\# version of WordNet.Net\footnote{\url{http://opensource.ebswift.com/WordNet.Net/}}. 
Another example is iText\footnote{\url{http://www.lowagie.com/iText/}}, which
provides Java version only. Kazuya developed a C\# version of 
iText.Net\footnote{\url{http://www.ujihara.jp/iTextdotNET/en/}}. As described by Jones~\cite{jones1998estimating}, 
about one-third of the existing projects have multiple versions in different languages.

Migrating projects from one language to another language (such as from Java to C\#) manually
is a tedious and error-prone task. A natural way to address this issue is to develop
a translation tool that can automatically translate projects from one language to another.
However, it is challenging to develop such a translation tool as the translation tool should
have knowledge of how one programming language is mapped to the other language. In literature,
there are several approaches~\cite{mossienko2003automated, yasumatsu1995spice, hainaut2008migration}
proposed that address the problem of language migration partially. These approaches address 
the problem of language migration partially, because these approaches expect programmers
to describe how one language is mapped to another language. As programming languages provide
a large number of Application Programming Interfaces (API), writing these rules manually 
for all APIs is tedious and error-prone.

In this paper, we propose a novel approach that automatically captures
how APIs of one language are mapped to the APIs of another language. We refer this
mapping as \emph{mapping relations of APIs}. There are two possible alternatives
for capturing mapping relations of APIs. First, capture mapping relations based
on API implementations. Second, capture mapping relations based on API usages.
In our approach, we use the second alternative rather than the first alternative 
for three major reasons: (1) Often API implementations such as C\# base class 
libraries are not available. (2) Capturing relations based on API implementations


One main challenge of language migration is to map APIs from one
language into other languages. It is non-trivial to build API
mapping due to the following factors. First, APIs are typically
quite large in size. Second, mapping relations of inputs can be
complicated. For example, consider the following two API methods:

\begin{CodeOut}
$m_1$ in Java: BigDecimal java.math.BigDecimal.multiply (BigDecimal $p_1^1$)\\
\hspace*{0.11in}$m_2$ in C\#:\ \ \ \  Decimal
System.Decimal.Multiply (Decimal $p_1^2$, Decimal $p_2^2$)
\end{CodeOut}

Here, $m_1$ has a receiver, say $v_1^1$, of type \CodeIn{BigDecimal}
and has one parameter $p_1^1$, and $m_2$ has two parameters $p_1^2$
and $p_2^2$. Based on the definitions of these inputs, $v_1^1$ is
mapped to $p_1^2$, and $p_1^1$ is mapped to $p_2^2$. Third, one API
method in one language may be mapped to more than one API method in
other languages. For example, consider the following two API
methods:

\begin{CodeOut}
$m_3$ in Java: E java.util.LinkedList.removeLast()\\
\hspace*{0.11in}$m_4$ in C\#: void System.
Collections.Generic.LinkedList.RemoveLast()
\end{CodeOut}

Here, $m_3$ returns the last value, and $m_4$ does not return any
value. To get that value, C\# programmers need to call more API
methods, and thus one API method of Java is mapped to serval API
methods in C\#.


As a result, existing
approaches~\cite{mossienko2003automated,yasumatsu1995spice,hainaut2008migration}
support only a subset of APIs or even ignore the mapping relations
of APIs. Such a limitation causes many compilation errors in
migrated projects and limits their applications in practice. In this
paper, we propose an approach that mines API mapping from API client
code automatically. As the mined API mapping describes mapping
relations of APIs, our approach can improve existing language
migration approaches. This paper makes the following main
contributions:

\begin{itemize}\vspace*{-1.5ex}
\item We propose the first approach that mines API mapping of
different languages from existing client code automatically. Our
approach addresses an important and yet challenging problem
unaddressed by previous work on language migration.\vspace*{-1.5ex}
\item We propose techniques to build and to compare API
transformation graphs (ATG). ATGs describe data dependencies among
inputs and outputs of API methods, so that our approach is able to
mine complicated mapping relations of inputs and many-to-many
mapping relations.\vspace*{-1.5ex}
\item We
implemented a tool named MAM based on our approach and conducted two
evaluations on fifteen projects with both Java and C\# versions.
These projects have 18568 classes and 109,850 methods totally. The
results show that our approach mines 26,369 mapping relations of
APIs with 83.2\% accuracies and the mined API mapping reduces 55.4\%
compilation errors in migrated projects.
\end{itemize}\vspace*{-1.5ex}


The remainder of this paper is as follows. Section~\ref{sec:example}
illustrates our approach using an example. Section~\ref{sec:mapping}
presents definitions. Section~\ref{sec:approach} presents our
approach. Section~\ref{sec:evaluation} presents our evaluations.
Section~\ref{sec:discuss} discusses issues of our approach.
Section~\ref{sec:related} presents the related work.
Section~\ref{sec:colcusion} concludes.
