\section{Introduction}
\label{sec:introduction}

A programming language serves as a means for instructing computers
to achieve a programming task at hand. Since their inception,
various programming languages came into existence due to several
factors such as existence of many platforms or requirements for
different programming styles. The
HOPL\footnote{\url{http://hopl.murdoch.edu.au}} website lists 8,512
different programming languages. To address business requirements
and to survive in competing markets, companies or open source
organizations often have to release different versions of their
projects in different languages. For example, many well-known
projects such as
Lucene\footnote{\url{http://lucene.apache.org/}}\Comment{db4o\footnote{\url{http://www.db4o.com/}}}
and WordNet\footnote{\url{http://wordnet.princeton.edu/}} provide
multiple versions in different languages. For some open source
projects, although their project teams do not officially provide
multiple versions, external programmers often create their versions
in different languages. For example, the WordNet team does not
provide a C\# version, but Simpson and Crowe developed a C\# version
of
WordNet.Net\footnote{\url{http://opensource.ebswift.com/WordNet.Net/}}.
Totally, as described by Jones~\cite{jones1998estimating}, about
one-third of the existing projects have multiple versions in
different languages.

%For some open source projects, although companies do not officially
%provide multiple versions, external programmers often create their
%versions in different languages. For example, WordNet does not
%provide a C\# version. However, Simpson and Crowe developed a C\#
%version of
%WordNet.Net\footnote{\url{http://opensource.ebswift.com/WordNet.Net/}}.
%Another example is
%iText\footnote{\url{http://www.lowagie.com/iText/}}, which provides
%Java version only. Kazuya developed a C\# version of
%iText.Net\footnote{\url{http://www.ujihara.jp/iTextdotNET/en/}}.

Translating projects from one language to another language
(\emph{e.g.}, from Java to C\#) manually is a tedious and
error-prone task. Some companies have suffered from huge losses because
of failures in language translation. For example, Terekhov and
Verhoef~\cite{terekhov2000realities} stated that at least three
companies went bankrupt and another company lost 50 million dollars
due to failed language translation projects. A natural way to
address this issue is to develop a translation tool that can
automatically translate projects from one language to another.
However, it is challenging to develop such a translation tool since the
translation tool should have knowledge of how Application
Programming Interfaces (APIs) in one programming
language are mapped to APIs in the other language. In the literature, there exist
approaches~\cite{mossienko2003automated, yasumatsu1995spice} that address the problem of language
translation partially. These approaches expect programmers to
describe how APIs of one language is mapped to APIs of another
language. \Comment{Based on the mappings provided as input, these
existing approaches translate projects from one language to
another.} As programming languages provide a large number of APIs,
writing mappings manually for all APIs is tedious and error-prone.
As a result, existing approaches~\cite{mossienko2003automated,yasumatsu1995spice}
support only a subset of APIs for translation. Such a limitation
results in many compilation errors in translated projects and limits
these approaches' usage in practice.

In this paper, we propose a novel approach that automatically mines
how APIs of one language are mapped to APIs of another language. We
refer to this mapping as \emph{API mapping relations} 
(in short as relations in the rest of the paper) and our
approach as MAM. MAM mines relations based on API usages in
the client code rather based on API implementations with three major
reasons. (1) API libraries often do not come with source files
especially for those C\# libraries. (2) Relations mined based on API
implementations often have lower confidence than relations mined
based on API usages. The reason is that API implementations have
only one data point for analysis, whereas API usages can have many
data points (i.e., call sites) for mining. (3) Mapping relations of
APIs are often complex and cannot be mined based on the information
available in the API implementations. First, mapping parameters of
an API method in one language with an API method in the other
language can be complex. For example, consider the following two API
methods in Java and C\#:

\begin{CodeOut}
$m_1$ in Java: BigDecimal java.math.BigDecimal.multiply (BigDecimal $p_1^1$)\\
\hspace*{0.12in}$m_2$ in C\#:\ \ \ \  Decimal
System.Decimal.Multiply (Decimal $p_1^2$, Decimal $p_2^2$)
\end{CodeOut}

Here, $m_1$ has a receiver, say $v_1^1$, of type \CodeIn{BigDecimal}
and has one parameter $p_1^1$, whereas $m_2$ has two parameters $p_1^2$
and $p_2^2$. For these two API methods, $v_1^1$ is
mapped to $p_1^2$, and $p_1^1$ is mapped to $p_2^2$. Second, an API
method of one language can be mapped to more than one API method in the
other language. For example, consider the following two API methods:

\begin{CodeOut}
$m_3$ in Java: E java.util.LinkedList.removeLast()\\
\hspace*{0.12in}$m_4$ in C\#: void System.Collections.Generic.LinkedList.RemoveLast()
\end{CodeOut}

Although the method names of $m_3$ and $m_4$ are the same, $m_3$ in Java
cannot be directly mapped with $m_4$ in C\#. The reason is that $m_3$ in Java
returns the last element removed from the list, whereas $m_4$ does not return any
element. Therefore, $m_3$ is mapped to two API methods $m_4$ and $m_5$ (shown below) in C\#.
The API method $m_5$ returns the last element and should be called before calling $m_4$.

\begin{CodeOut}
$m_5$ in C\#: void System.Collections.Generic.LinkedList.Last()
\end{CodeOut}

To deal with the complexity of mining API mapping, we construct a
graph, referred to as \emph{API transformation graph} (ATG), for
aligned methods of the client code in both languages. These ATGs
precisely capture inputs and outputs of API methods, and help mine
complex mapping relations of API methods.

This paper makes the following major contributions:

\begin{itemize}\vspace*{-1.5ex}
\item The first approach that mines API mapping between
different languages using API client code, referred to as MAM. MAM
addresses an important and yet challenging problem that is not
addressed by previous work on language translation.\vspace*{-1.5ex}
\item API transformation graphs (ATGs) proposed to capture inputs
and outputs of API methods, and a technique for building ATGs and
comparing built ATGs for mining API mapping. As ATGs describe data
dependencies among inputs and outputs of API methods, MAM is able to
mine complex mapping relations between API methods from two
languages.\vspace*{-1.5ex}
\item A tool implemented for MAM and two
evaluations on 15 projects that include 18,568 classes and 109,850
methods with both Java and C\# versions. The results show that our
tool mines 6,695 mapping relations of API classes with accuracy of
86.7\% and 19,110 mapping relations of API methods with accuracy of
90.0\%. The results also show that the mined relations
reduce 55.4\% of compilation errors and 43.0\% defects during
translation of projects from Java to C\# using Java2CSharp.
\end{itemize}\vspace*{-1.5ex}

The rest of this paper is organized as follows.
Section~\ref{sec:mapping} presents definitions.
Section~\ref{sec:example} illustrates our approach using an example.
Section~\ref{sec:approach} presents our approach.
Section~\ref{sec:evaluation} presents our evaluations.
Section~\ref{sec:discuss} discusses issues of our approach.
Section~\ref{sec:related} presents related work.
Finally, Section~\ref{sec:conclusion} concludes.
