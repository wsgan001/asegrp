\section{Introduction}
\label{sec:introduction} In the history of software programming,
researchers and practitioners created various programming languages.
In particular, the HOPL\footnote{\url{http://hopl.murdoch.edu.au/}}
website lists 8512 different languages. Due to various
considerations such as attracting programmers with various
backgrounds and achieving better performances on particular
platforms, a project may be implemented as versions of multiple
languages. For example, many well-known projects such as
Lucene\footnote{\url{http://lucene.apache.org/}},
Db4o\footnote{\url{http://www.db4o.com/}}, and
WordNet\footnote{\url{http://wordnet.princeton.edu/}} all provide
versions of multiple languages. For those open source projects, even
if a project does not provide any versions of multiple languages,
outside programmers may implement versions of particular languages
for the project. For example, although WordNet officially does not
provide a C\# version, Simpson and Crowe developed
WordNet.Net\footnote{\url{http://opensource.ebswift.com/WordNet.Net/}}
for C\# programmers. Another example is
iText\footnote{\url{http://www.lowagie.com/iText/}}. Although it
provides only a Java version, Kazuya developed
iText.Net\footnote{\url{http://www.ujihara.jp/iTextdotNET/en/}} for
C\# programmers. In fact, as pointed out by
Jones~\cite{jones1998estimating}, about 1/3 of existing software
projects have versions of multiple languages.

To reduce the effort of programming, a natural way to develop a
version of a new language for a project is to translate from an
existing version of the project. To help programmers conduct such
migration, researchers proposed various
approaches~\cite{mossienko2003automated,yasumatsu1995spice,hainaut2008migration}.
However, language migration is still very risk even with the help of
those proposed approaches. For example, Terekhov and
Verhoef~\cite{terekhov2000realities} stated that at least three
companies went bankrupt and another company lost 50 million dollars
all because of failed language migration projects.

One main challenge of language migration is to map APIs from one
language into other languages. It is non-trivial to build API
mapping due to the following factors. First, APIs are typically
quite large in size. Second, mapping relations of inputs can be
complicated. For example, consider the following two API methods:

\begin{CodeOut}
$m_1$ in Java: BigDecimal java.math.BigDecimal.multiply (BigDecimal $p_1^1$)\\
\hspace*{0.11in}$m_2$ in C\#:\ \ \ \  Decimal
System.Decimal.Multiply (Decimal $p_1^2$, Decimal $p_2^2$)
\end{CodeOut}

Here, $m_1$ has a receiver, say $v_1^1$, of type \CodeIn{BigDecimal}
and has one parameter $p_1^1$, and $m_2$ has two parameters $p_1^2$
and $p_2^2$. Based on the definitions of these inputs, $v_1^1$ is
mapped to $p_1^2$, and $p_1^1$ is mapped to $p_2^2$. Third, one API
method in one language may be mapped to more than one API method in
other languages. For example, consider the following two API
methods:

\begin{CodeOut}
$m_3$ in Java: E java.util.LinkedList.removeLast()\\
\hspace*{0.11in}$m_4$ in C\#: void System.
Collections.Generic.LinkedList.RemoveLast()
\end{CodeOut}

Here, $m_3$ returns the last value, and $m_4$ does not return any
value. To get that value, C\# programmers need to call more API
methods, and thus one API method of Java is mapped to serval API
methods in C\#.


As a result, existing
approaches~\cite{mossienko2003automated,yasumatsu1995spice,hainaut2008migration}
support only a subset of APIs or even ignore the mapping relations
of APIs. Such a limitation causes many compilation errors in
migrated projects and limits their applications in practice. In this
paper, we propose an approach that mines API mapping from API client
code automatically. As the mined API mapping describes mapping
relations of APIs, our approach can improve existing language
migration approaches. This paper makes the following main
contributions:

\begin{itemize}\vspace*{-1.5ex}
\item We propose the first approach that mines API mapping of
different languages from existing client code automatically. Our
approach addresses an important and yet challenging problem
unaddressed by previous work on language migration.\vspace*{-1.5ex}
\item We propose techniques to build and to compare API
transformation graphs (ATG). ATGs describe data dependencies among
inputs and outputs of API methods, so that our approach is able to
mine complicated mapping relations of inputs and many-to-many
mapping relations.\vspace*{-1.5ex}
\item We
implemented a tool named MAM based on our approach and conducted two
evaluations on fifteen projects with both Java and C\# versions.
These projects have 18568 classes and 109,850 methods totally. The
results show that our approach mines 26,369 mapping relations of
APIs with 83.2\% accuracies and the mined API mapping reduces 55.4\%
compilation errors in migrated projects.
\end{itemize}\vspace*{-1.5ex}


The remainder of this paper is as follows. Section~\ref{sec:example}
illustrates our approach using an example. Section~\ref{sec:mapping}
presents definitions. Section~\ref{sec:approach} presents our
approach. Section~\ref{sec:evaluation} presents our evaluations.
Section~\ref{sec:discuss} discusses issues of our approach.
Section~\ref{sec:related} presents the related work.
Section~\ref{sec:colcusion} concludes.
