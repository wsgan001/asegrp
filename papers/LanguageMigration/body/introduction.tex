\section{Introduction}
\label{sec:introduction} 

A programming language serves as a means for instructing computers to achieve a programming task at hand.
Since their inception, various programming languages came into existence due to  
reasons such as existence of many platforms or requirements for different programming styles.
The HOPL\footnote{\url{http://hopl.murdoch.edu.au}} website lists 
8,512 different programming languages. 

To address business requirements and to survive in competing markets, companies
often have to develop different versions of their projects in different languages.
For example, many well-known projects such as Lucene\footnote{\url{http://lucene.apache.org/}},
Db4o\footnote{\url{http://www.db4o.com/}}, and WordNet\footnote{\url{http://wordnet.princeton.edu/}} provide
multiple versions in different languages. There are instances where
companies incurred huge losses due to lack of multiple versions of their projects.
For example, Terekhov and Verhoef~\cite{terekhov2000realities} stated that at least three
companies went bankrupt and another company lost 50 million dollars due to failed language migration projects.

For some open source projects, although companies do not offically provide multiple versions, external programmers often
create their versions in different languages. For example, WordNet does not
provide a C\# version. However, Simpson and Crowe developed
a C\# version of WordNet.Net\footnote{\url{http://opensource.ebswift.com/WordNet.Net/}}. 
Another example is iText\footnote{\url{http://www.lowagie.com/iText/}}, which
provides Java version only. Kazuya developed a C\# version of 
iText.Net\footnote{\url{http://www.ujihara.jp/iTextdotNET/en/}}. As described by Jones~\cite{jones1998estimating}, 
about one-third of the existing projects have multiple versions in different languages.

Migrating projects from one language to another language (such as from Java to C\#) manually
is a tedious and error-prone task. A natural way to address this issue is to develop
a translation tool that can automatically translate projects from one language to another.
However, it is challenging to develop such a translation tool as the translation tool should
have knowledge of how one programming language is mapped to the other language. In literature,
there exist approaches~\cite{mossienko2003automated, yasumatsu1995spice, hainaut2008migration}
that address the problem of language migration partially. These approaches address 
the problem of language migration partially, because these approaches expect programmers
to describe how one language is mapped to another language. Based on the mappings provided
as input, these existing approaches translate projects from one language to another. 
As programming languages provide a large number of Application Programming Interfaces (API), writing these rules manually 
for all APIs is tedious and error-prone. As a result, existing
approaches~\cite{mossienko2003automated,yasumatsu1995spice,hainaut2008migration}
support only a subset of APIs or even ignore the mapping relations
of APIs. Such a limitation causes many compilation errors in migrated projects and limits their usage in practice. 

In this paper, we propose a novel approach that automatically captures
how APIs of one language are mapped to the APIs of another language. We refer this
mapping as \emph{mapping relations of APIs}. There are two possible alternatives
for capturing mapping relations of APIs. First, capture mapping relations based
on API implementations. Second, mine mapping relations based on API usages in the client code.
In our approach, we use the second alternative rather than the first alternative 
for three major reasons: (1) Often API implementations such as implementations of C\# base class 
libraries are not available. (2) Capturing relations based on API implementations
often can have relatively low confidence than mining mapping relations based on API usages.
The reason is that API implementations have only one call site for the analysis, whereas
API usages can have many call sites for mining; providing relatively high confidence on mapped
relations. (3) Mapping relations of APIs are more complex and cannot be captured solely
based on the information available in the API implementations. We next
show why it is not possible to capture mapping relations
based on the information available in API implementations using two illustrative examples.

Consider the following two API methods in Java and C\#:

\begin{CodeOut}
$m_1$ in Java: BigDecimal java.math.BigDecimal.multiply (BigDecimal $p_1^1$)\\
\hspace*{0.12in}$m_2$ in C\#:\ \ \ \  Decimal
System.Decimal.Multiply (Decimal $p_1^2$, Decimal $p_2^2$)
\end{CodeOut}

Here, $m_1$ has a receiver, say $v_1^1$, of type \CodeIn{BigDecimal}
and has one parameter $p_1^1$, and $m_2$ has two parameters $p_1^2$
and $p_2^2$. Based on the definitions of these inputs, $v_1^1$ is
mapped to $p_1^2$, and $p_1^1$ is mapped to $p_2^2$. This preceding
example shows the complexities involved in mapping parameters of an API
method in one language with an API method in the other language. 
We next provide a more complex example where an API method of one 
language is mapped to more than one API method in the other language. Consider the following two API methods:

\begin{CodeOut}
$m_3$ in Java: E java.util.LinkedList.removeLast()\\
\hspace*{0.12in}$m_4$ in C\#: void System.Collections.Generic.LinkedList.RemoveLast()
\end{CodeOut}

Although the method names of $m_3$ and $m_4$ are the same, $m_3$ in Java
cannot be directly mapped with $m_4$ in C\#. The reason is that $m_3$ in Java
returns the last element removed from the list, whereas $m_4$ does not return any
element. Therefore, $m_3$ is mapped to two API method $m_4$ and $m_5$ (shown below) in C\#.
The API method $m_5$ is shown below and this method returns the last element
and should be called before calling $m_4$.

\begin{CodeOut}
$m_5$ in C\#: void System.Collections.Generic.LinkedList.Last()
\end{CodeOut}

This example shows that in many cases, an API method of one language is mapped
to multiple API methods of the other language. Therefore, capturing API mapping relationships
based on API implementations is often not possible. We next describe our approach
that mines mapping relations using the API client code.

TODO:

This paper makes the following main contributions:

\begin{itemize}\vspace*{-1.5ex}
\item We propose the first approach that mines API mapping of
different languages from existing client code automatically. Our
approach addresses an important and yet challenging problem
unaddressed by previous work on language migration.\vspace*{-1.5ex}
\item We propose techniques to build and to compare API
transformation graphs (ATG). ATGs describe data dependencies among
inputs and outputs of API methods, so that our approach is able to
mine complicated mapping relations of inputs and many-to-many
mapping relations.\vspace*{-1.5ex}
\item We
implemented a tool named MAM based on our approach and conducted two
evaluations on fifteen projects with both Java and C\# versions.
These projects have 18568 classes and 109,850 methods totally. The
results show that our approach mines 26,369 mapping relations of
APIs with 83.2\% accuracies and the mined API mapping reduces 55.4\%
compilation errors in migrated projects.
\end{itemize}\vspace*{-1.5ex}

The remainder of this paper is organized as follows. Section~\ref{sec:example}
illustrates our approach using an example. Section~\ref{sec:mapping}
presents definitions. Section~\ref{sec:approach} presents our
approach. Section~\ref{sec:evaluation} presents our evaluations.
Section~\ref{sec:discuss} discusses issues of our approach.
Section~\ref{sec:related} presents related work. Finally,
Section~\ref{sec:colcusion} concludes.
