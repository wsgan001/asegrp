\section{Definitions}
\label{sec:mapping}

We next present definitions of terms used in the rest of the paper.

\textbf{API.} An Application Programming Interface (API)~\cite{orenstein2000quickstudy}
is a set of classes and methods provided by frameworks or libraries.

\textbf{API library.} An API library is a framework
or library that provides reusable API classes and methods.

\textbf{Client code.} Client code is application code
that reuses or extends API classes and methods provided by API
libraries.

The definitions of API library and client code are
relative to each other. For example, Lucene uses classes and methods provided by
J2SE\footnote{\url{http://java.sun.com/j2se/1.5.0/}}, so we consider Lucene as client code and J2SE as an API library. At the same time, Nutch\footnote{\url{http://lucene.apache.org/nutch/}} uses classes and methods provided by Lucene, so we consider Nutch as client code and Lucene as an API library. In
general, for programmers of client code, source files of API libraries are often
not available.

\textbf{Mapping relation.} For a set of entities $E_1$ defined by a
language $L_1$ and another set of entities $E_2$ defined by another
language $L_2$, a mapping relation is a triple $\langle E_1, E_2,
b_i \rangle$ where $E_1$ and $E_2$ have the same behavior $b_i$.


We use mapping relations of API classes for translating data such as
variables, parameters, and constants, so we require that two mapped
API classes have the same programm behavior, referred to as
the $s$ behavior.

\textbf{1-to-1 mapping relation of API classes.} For an API class
$c_1$ defined by $L_1$ and an API class $c_2$ defined by $L_2$, a
1-to-1 mapping relation of API classes is a triple $\langle c_1,
c_2, s \rangle$, where $s$ denotes the $s$ behavior.

One API class defined by $L_1$ can have more than one 1-to-1 mapping
relation with API classes defined by $L_2$. For example, data in
\CodeIn{java.util.ArrayList} of Java can be stored in either
\CodeIn{System. Collections.ArrayList} \textbf{or}
\CodeIn{System.Collections.Generic. List} of C\#, so the Java class
has two 1-to-1 mapping relations with these two C\# classes.

\textbf{Many-to-many mapping relation of API classes.} For a set of API classes
$C_1$ defined by $L_1$ and a set of API classes $C_2$ defined by
$L_2$, a many-to-many mapping relation of API classes is a triple
$\langle C_1, C_2, s \rangle$, where $s$ denotes the $s$ behavior.

For example, the current time in \CodeIn{java.lang.System} of Java
is stored in \CodeIn{System.Environment} of C\#, whereas the
environment settings in \CodeIn{java.lang.System} is stored in
\CodeIn{System.Environment} of C\#, so the Java class has a
many-to-many mapping relation with the two C\# classes.

We use mapping relations of API methods for translating API methods
that accept inputs to produce desirable outputs, so we require two
mapped API methods have the same program behavior of inputs, outputs, and
functionalities. We refer to this behavior as the \emph{t} behavior.

\textbf{1-to-1 mapping relation of API methods.} For an API method
$m_1$ defined by $L_1$ and an API method $m_2$ defined by
$L_2$, a mapping relation of API methods is a triple $\langle m_1,
m_2, t \rangle$, where $t$ denotes the $t$ behavior.

As one API class defined by $L_1$ can have more than one 1-to-1 mapping
relation with API classes defined by $L_2$, one API method defined by $L_1$ can have more than one 1-to-1 mapping relation with API methods defined by $L_2$.

\textbf{Many-to-many mapping relation of API methods.} For a set of API methods
$M_1$ defined by $L_1$ and a set of API methods $M_2$ defined by
$L_2$, a many-to-many mapping relation of API methods is a triple
$\langle M_1, M_2, t \rangle$, where $t$ denotes the $t$ behavior.

For example, Section~\ref{sec:introduction} shows a many-to-many mapping relation between $\{m_3\}$ of Java and $\{m_4, m_5\}$ of C\#. 