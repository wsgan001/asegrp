\section{Definitions}
\label{sec:mapping}

We next present definitions of terms used in the rest of the paper.

\textbf{API.} An Application Programming Interface (API)~\cite{orenstein2000quickstudy}
is a set of classes and methods provided by frameworks or libraries.

\textbf{API library.} An API library is a framework
or library that provides reusable API classes and methods.

\textbf{Client code.} Client code is application code
that reuses or extends API classes and methods provided by API
libraries.

The definitions of API library and client code are
relative to each other. For example, Lucene uses
J2SE\footnote{\url{http://java.sun.com/j2se/1.5.0/}} as an API
library, whereas Nutch\footnote{\url{http://lucene.apache.org/nutch/}} uses Lucene as
an API library. Therefore, we consider Lucene as client code and API
library for the J2SE API library and Nutch, respectively. In
general, for programmers of client code, source files of API libraries are often
not available.

\textbf{Mapping relation.} For a set of entities $E_1$ defined by a
language $L_1$ and another set of entities $E_2$ defined by another
language $L_2$, a mapping relation is a triple $\langle E_1, E_2,
b_i \rangle$ where $E_1$ and $E_1$ have the same behavior $b_i$.


We use mapping relations of API classes for translating data such as
variables, parameters, and constants, so we require that two mapped
API classes have the same programm behavior, referred to as
the $s$ behavior.

\textbf{1-to-1 mapping relation of API classes.} For an API class
$c_1$ defined by $L_1$ and an API class $c_2$ defined by $L_2$, a
1-to-1 mapping relation of API classes is a triple $\langle c_1,
c_2, s \rangle$, where $s$ denotes the $s$ behavior.

One API class defined by $L_1$ can have more than one 1-to-1 mapping
relation with API classes defined by $L_2$. For example, data in
\CodeIn{java.util.ArrayList} of Java can be stored in either
\CodeIn{System. Collections.ArrayList} \textbf{or}
\CodeIn{System.Collections.Generic. List} of C\#, so the Java class
has two 1-to-1 mapping relations with the two C\# classes.

\textbf{Many-to-many mapping relation of API classes.} For a set of API classes
$C_1$ defined by $L_1$ and a set of API classes $C_2$ defined by
$L_2$, a many-to-many mapping relation of API classes is a triple
$\langle C_1, C_2, s \rangle$, where $s$ denotes the $s$ behavior.

For example, the current time in \CodeIn{java.lang.System} of Java
is stored in \CodeIn{System.Environment} of C\#, whereas the
environment settings in \CodeIn{java.lang.System} is stored in
\CodeIn{System.Environment} of C\#, so the Java class has a
many-to-many mapping relation with the two C\# classes.

We use mapping relations of API methods for translating API methods
that accept inputs to produce desirable outputs, so we require two
mapped API methods have the same programm behavior of inputs, outputs, and
functionalities. We refer to this behavior as the ``\emph{t}'' behavior.

\textbf{1-to-1 mapping relation of API methods.} For an API method
$m_1$ defined by $L_1$ and an API method $m_2$ defined by
$L_2$, a mapping relation of API methods is a triple $\langle m_1,
m_2, t \rangle$, where $t$ denotes the $t$ behavior.

As one API class defined by $L_1$ can have more than one 1-to-1 mapping
relation with API classes defined by $L_2$, one API method defined by $L_1$ can have more than one 1-to-1 mapping relation with API methods defined by $L_2$. 

\textbf{Many-to-many mapping relation of API classes.} For a set of API methods
$M_1$ defined by $L_1$ and a set of API methods $M_2$ defined by
$L_2$, a many-to-many mapping relation of API methods is a triple
$\langle M_1, M_2, t \rangle$, where $t$ denotes the $t$ behavior.

For example, Section~\ref{sec:introduction} shows a many-to-many mapping relation between $\{m_3\}$ of Java and $\{m_4, m_5\}$ of C\#. 