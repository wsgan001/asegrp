\section{Example}
\label{sec:example}

We next explain our approach with an illustrative example shown in Figure~\ref{fig:mut}. The figure shows a MUT, called \CodeIn{Compute}, taken from the QuickGraph library~\cite{QUICKGRAPH}. The MUT requires two non-primitive objects: \CodeIn{IVertexAndEdgeListGraph} and \CodeIn{IVertex}. The MUT requires an object of \CodeIn{IVertexAndEdgeListGraph} (which represents a graph) since the constructor of the receiver object of the MUT has the argument of type \CodeIn{IVertexAndEdgeListGraph}. The MUT accepts a vertex in the graph as argument and computes a depth-first search of the graph. To achieve high structural coverage of the MUT, the minimal requirement is that the graph object should include vertices and edges. We used both Randoop and Pex to generate unit tests for the MUT. Randoop achieved branch coverage of 31.8\% (7 of 22). The reason for low branch coverage is that the random mechanism of Randoop is not able to generate a graph object with vertices and edges. 

To generate test inputs using Pex, we created a PUT that includes \CodeIn{UndirectedDFS} as a parameter. As the constructor of \CodeIn{UndirectedDFS} accepts an interface \CodeIn{IVertexAndEdgeListGraph} as argument, Pex can automatically generate a new class implementing the \CodeIn{IVertexAndEdgeListGraph} interface. However, such a new class may not support the (implicit) contracts associated with the interface implementation. Therefore, we provided minimal assistance to Pex by describing which implementing classes can be used for interfaces. For example, we feed to Pex the information that it can use the \CodeIn{AdjacencyGraph} class as an implementing class for the \CodeIn{IVertexAndEdgeListGraph} interface. Pex achieved branch coverage of 45.5\% on the MUT. Although Pex achieved higher branch coverage than Randoop, the coverage is still low (only 45.5\%). Similar to Randoop, Pex was not able to generate a graph object with vertices and edges.

We next describe how $\smoot$ can assist Randoop and Pex by extracting sequences from existing code bases. 
We need sequences for objects of three classes\footnote{We use classes to collectively denote both classes and interfaces.}: \CodeIn{UndirectedDFS}, \CodeIn{IVertexAndEdgeListGraph}, and \CodeIn{IVertex}. We need a  sequence for an object of the \CodeIn{UndirectedDFS} class to construct a desirable receiver object state. We also need sequences for objects of classes implementing the \CodeIn{IVertexAndEdgeListGraph} and \CodeIn{IVertex} interfaces. 
%as the constructor of \CodeIn{UndirectedDFS} requires an object of \CodeIn{IVertexAndEdgeListGraph} and the \CodeIn{Compute} method requires an object of \CodeIn{IVertex} as argument, respectively. 
We collected a set of applications (code bases of 3.9 MB of .NET assembly code) from an open source C\# repository\footnote{\url{http://www.codeplex.com/}} that reuse classes of the QuickGraph library.
$\smoot$ analyzes these code bases and extracts sequences that produce objects of these classes.

%sequences generated by $\smoot$ include only one class type. When $\smoot$ encounters a code example in existing code bases including several class types, $\smoot$ automatically classifies sequences for different classes. The advantage of having such individualsequences is that these individualsequences can help generate moresequences by combining these sequences (Section~\ref{}). 
$\smoot$ extracted 5 sequences for the \CodeIn{AdjacencyGraph} class that implements the \CodeIn{IVertexAndEdgeListGraph} interface, and 11 sequences for the \CodeIn{Vertex} class that implements the \CodeIn{IVertex} interface. Figures~\ref{fig:agraphseq} and~\ref{fig:vertexseq} show example sequences for creating objects of the \CodeIn{AdjacencyGraph} and \CodeIn{Vertex} classes. The  sequence for  \CodeIn{AdjacencyGraph} satisfies our minimal requirement that the resulting graph should include vertices and edges. It is challenging to generate these sequences automatically, especially due to the large number of possible sequence combinations. In contrast, $\smoot$ can easily extract such sequences from existing code bases.

One issue with extracted sequences is that these sequences can include additional classes. For example,
Statement 3 of Figure~\ref{fig:agraphseq} shows that the  sequence requires another object of the class \CodeIn{VertexAndEdgeProvider}. $\smoot$ automatically identifies such additional classes and gathers sequences that produce objects of these classes. $\smoot$ extracted one  sequence for the \CodeIn{VertexAndEdgeProvider} class from existing code bases. Section~\ref{sec:approach} presents more details on how $\smoot$ addresses challenges for extracting these sequences.

\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
01: VertexAndEdgeProvider vo; //requires as input
02: bool bVal; //requires as input
03: AdjacencyGraph agObj = new AdjacencyGraph(vo,bVal); 
04: IVertex source = agObj.AddVertex();
05: IVertex target = agObj.AddVertex();
06: IVertex vertex3 = agObj.AddVertex();
07: IEdge edgObj1 = agObj.AddEdge(source,target); 
08: IEdge edgObj2 = agObj.AddEdge(target,vertex3);
09: IEdge edgObj3 = agObj.AddEdge(source,vertex3);
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\Caption{\label{fig:agraphseq} A  sequence for producing an \CodeIn{AdjacencyGraph} object with vertices and edges.}\vspace*{-2ex}
\end{figure}
\begin{figure}[t]
\begin{CodeOut}
\begin{alltt}
AdjacencyGraph agObj; //requires as input
IVertex vObj = agObj.AddVertex();
\end{alltt}
\end{CodeOut}\vspace*{-4ex}
\Caption{\label{fig:vertexseq} A  sequence for producing an \CodeIn{IVertex} object.}\vspace*{-4ex}
\end{figure}

We next use Randoop with additional sequences extracted by $\smoot$. Randoop generated new test inputs incorporating  sequences extracted by $\smoot$. The new test inputs achieved branch coverage of 86.4\% (19 of 22) of the \CodeIn{Compute} method. When we use our extracted sequences to assist Pex, Pex also achieved the same branch coverage for the \CodeIn{Compute} method. The remaining not-covered branches are due to lack of event handlers that need to be registered with \CodeIn{UndirectedDFS}. This example describes our $\smoot$ approach and highlights the significance of using sequences from existing code bases in achieving higher branch coverage with both random and DSE-based approaches.