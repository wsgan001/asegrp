\section{Related Work}
\label{sec:related}

Test-generation approaches~\cite{csallner:jcrasher, JTEST, pacheco:eclat, xie:rostra} were developed for object-oriented testing and these approaches accept a class under test (CUT) and generate random sequences of method calls belonging to the CUT with random values for method arguments. Another set of approaches~\cite{inkumsah08:improving} replaces random values for method arguments with symbolic values and compute concrete values for these arguments by solving constraints inside the method under test. Tonella~\cite{tonella:etoc} proposed an approach that exploits genetic algorithms to generate new sequences evolved from an initial set of sequences. Tonella's approach requires the users to provide this initial set of sequences. Inkumsah and Xie~\cite{inkumsah08:improving} extended Tonella's approach by integrating evolutionary testing with symbolic execution. However, all these approaches cannot handle multiple classes and their methods due to a large search space of possible sequences. 

Randoop~\cite{pacheco:feedback} executes constructed sequences in each iteration and computes feedback in order to guide the search process to generate valid sequences. However, Randoop still relies on random techniques and cannot effectively generate sequences for achieving target states as shown in our evaluation. Our approach extracts sequences from code bases and use those sequences to assist other approaches such as Randoop in achieving higher structural coverage.

Our approach is also related to another category of approaches based on mining source code~\cite{Engler2001deviant, acharya06:mining, wasylkowski07:detecting, thummalapenta07:parseweb, thummalapenta09:mining}. These approaches mine code bases statically and extracts frequent patterns as implicit programming rules. These approaches use mining algorithms such as frequent itemset mining~\cite{wang:bide} or association rule mining~\cite{agarwal:association} for extracting frequent patterns. These mined programming rules are used for assisting programmers in writing code or detecting violations in an application under analysis. Our approach also uses static analysis for extracting patterns as sequences that can produce objects of receiver or arguments types of a MUT. Unlike these existing approaches, our approach uses extracted sequences in a novel way for assisting test-generation approaches in achieving high structural coverage.


Another category of existing work~\cite{Elbaum:capture, orso:capture, david:java} uses a capture-and-replay approach for generating unit tests. During the capture phase, their approach monitors the interaction of a unit such as the class under test with the rest of the system (to which the class belongs to). Their approach generates unit tests for the class under test based on monitored interactions. During the replay phase, their approach executes generated unit tests. Our previous approach, called UnitPlus~\cite{song07:unitplus}, captures sequences in existing test code and suggests those sequences to developers in reducing the effort of writing new unit tests. Our new $\smoot$ approach captures sequences from existing code bases but uses those sequences for assisting test-generation approaches. Unlike existing approaches that replay exactly the same captured behavior, our $\smoot$ approach replays beyond the captured behavior using techniques such as sequence generalization or generating new sequences by combining extracted sequences. 

%assists developers in writing test code manually. UnitPlus suggests relevant test oracles for the test inputs written by developers. To reduce efforts of developers in writing test code, UnitPlus also suggests sequences that produce objects of non-primitive object types used in test oracles. UnitPlus extracts these sequences from the test code in other unit tests included in the same source file. Unlike UnitPlus that assists developers in writing sequences, our approach extracts sequences from code bases to assist automatic test-generation approaches. Furthermore, our approach includes techniques to address issues in using extracted sequences for assisting test-generation approaches. 
%Orso and Kennedy proposed an approach, called SCARPE~\cite{orso:capture}, that captures runtime interactions between a subsystem of interest and the rest of the application. These captured interactions can be used to generate test cases. Our approach is related to their approach as our approach also captures how method calls are used in practice. However, their approach uses runtime monitoring for capturing interactions, whereas our approach uses static analysis, which is more scalable and does not any setup for executing the application. Furthermore, unlike their approach, our approach uses extracted sequences for assisting state-of-the-art test-generation approaches.

