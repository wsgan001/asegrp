\section{Conclusion}
\label{sec:concl}

Generation of desirable method-call sequences for achieving high structural coverage of the code under test is a known challenging problem in unit testing of object-oriented code. Existing work~\cite{csallner:jcrasher, khurshid:symbolic, xie:rostra} in addressing this problem is based primarily on the implementation information of the class under test. In this paper, we proposed the first approach that addresses this problem from a novel perspective of incorporating other sources of information such as how method calls are used in practice. Our approach gathers the information of how method calls are used in practice by mining code bases that use receiver or argument object types of a method under test. Our approach extracts sequences related to these object types and uses extracted sequences to enhance two state-of-the-art test-generation approaches: random testing and dynamic symbolic execution. We have demonstrated the effectiveness of our approach with  evaluations. Using sequences extracted by our approach, we showed that a random testing approach achieved 8.7\% (with a maximum of 20.0\% for one namespace) higher branch coverage and a DSE-based approach achieved 17.4\% (with a maximum of 22.5\% for one namespace) higher branch coverage than without using our approach. Such an improvement is significant since the branches that are not covered by these state-of-the-art approaches are generally quite difficult to cover. Our approach represents a step towards a new direction of leveraging research in the field of mining software engineering data to assist test generation, serving as a synergy between these two major research areas.

%Our approach represents a step to wards a new direction of leveraging vast research in the field of mining software engineering data to assist test generation, serving as a synergy between these two major research areas. By leveraging research in the field of mining software engineering data, our approach explores a new research direction where multiple programmers can collaboratively improve the quality of the code under test. For example, our current approach mines client or test code written by multiple programmers and extracts sequences to assist automatic test generation tools. In future work, we plan to further expand our research by investigating broader types of problems that can be addressed by automatic approaches with an assistance from programmers.

%*. Either in intro or conclusion, you can provide a bit vision on allowing developers to provide guidance to tools indirectly or implicitly by writing client code or test code. In fact, multiple developers can collaboratively improve the quality of the code under test in this way. You may make analogy to collaborative filtering (basically one sequence from one client code site can be mixed with another sequence from another client code site, ...)

%In the conclusion to be written, as I told you, I want you to generalize a bit more to say it is a direction for allowing to incorporate other sources of info (other than the implementation of the class under test).... You can also view it as a way for client/test code developers to collabroate implicitly to help improve the quality of the classes under test... like collaborative filtering. ... encouraging sharing of knowledge....