\section{Background}
\label{sec:background}

We next provide details of two major concepts used in the rest of
the paper: dynamic symbolic execution and dynamic code coverage.

%-----------------------------------------------------------------------------
\subsection{Dynamic Symbolic Execution}

In our approach, we use Pex as an example state-of-the-art dynamic symbolic 
execution tool. Pex~\cite{tillman:pexwhite} is an automatic unit-test-generation 
tool developed by Microsoft. Unlike conventional unit tests, Pex accepts
PUTs as input and generates conventional unit tests that can achieve high 
structural coverage of the code under test. Initially, Pex
executes the code under test with random inputs. While executing
the code under test, Pex collects constraints on inputs from predicates
in branching statements. Pex next solves collected constraints
to generate new test inputs that guide future executions along
new paths. 

%-----------------------------------------------------------------------------
\subsection{Dynamic Code Coverage}

In this paper, we use Pex generated reports for measuring coverage. These coverage
reports are called dynamic, because Pex knows only about the code that was already executed.
As Pex is not aware of the code that is not yet executed, dynamic code coverage
cannot give absolute values for the coverage. The primary reason for using
dynamic code coverage in our paper is that C\# allows generate code during run time.
Therefore, it is often not possible to find out how much code exists beforehand.